This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
postcss.config.js
README.md
SETUP.md
src/app/App.tsx
src/components/game/BloodEffect.tsx
src/components/game/BulletHole.tsx
src/components/game/EntityCube.tsx
src/components/game/FloorGrid.tsx
src/components/game/Gun.tsx
src/components/game/MuzzleFlash.tsx
src/components/index.ts
src/components/systems/AudioManager.tsx
src/components/systems/FirstPersonControls.tsx
src/components/systems/MapTracker.tsx
src/components/ui/BlockroomsCard.tsx
src/components/ui/Crosshair.tsx
src/components/ui/DarknessMask.tsx
src/components/ui/Flashlight.tsx
src/components/ui/GrainVignetteOverlay.tsx
src/components/ui/HUD.tsx
src/components/ui/Instructions.tsx
src/components/ui/LightProximity.tsx
src/components/ui/MainMenu.tsx
src/components/ui/PlayerHUD.tsx
src/components/ui/TransactionPopup.tsx
src/components/ui/TutorialVideo.tsx
src/components/ui/WarningPopup.tsx
src/config/cartridgeConnector.tsx
src/config/manifest_sepolia.json
src/config/manifest.ts
src/context/game-context.tsx
src/dojo/contracts.gen.ts
src/dojo/dojoConfig.ts
src/dojo/hooks/fetchNearbyDoors.tsx
src/dojo/hooks/useAttackEntity.tsx
src/dojo/hooks/useCollectShard.tsx
src/dojo/hooks/useDoor.tsx
src/dojo/hooks/useEndGame.tsx
src/dojo/hooks/useGameData.tsx
src/dojo/hooks/useInitializePlayer.tsx
src/dojo/hooks/useMovePlayer.tsx
src/dojo/hooks/usePlayerMovement.tsx
src/dojo/hooks/useStarknetConnect.tsx
src/dojo/hooks/useStartGame.tsx
src/dojo/models.gen.ts
src/dojo/starknet-provider.tsx
src/index.css
src/main.tsx
src/models/Bloccc.tsx
src/models/Car1.tsx
src/models/Entity1.tsx
src/models/Ghost.tsx
src/models/GhostPatrol.tsx
src/models/GhostPatrol2.tsx
src/models/GhostPatrol3.tsx
src/models/GhostPatrol4.tsx
src/models/GhostPatrol5.tsx
src/models/GhostPatrol6.tsx
src/models/GhostPatrol7.tsx
src/models/Gun1.tsx
src/models/index.ts
src/models/Pop.tsx
src/models/Shotgun.tsx
src/models/Shotgunshoot.tsx
src/models/Table.tsx
src/types/game.ts
src/utils/utils.ts
src/vite-env.d.ts
src/zustand/store.ts
tailwind.config.js
tsconfig.app.json
tsconfig.app.tsbuildinfo
tsconfig.json
tsconfig.node.json
tsconfig.node.tsbuildinfo
vercel.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Dependency directories
node_modules
dist
dist-ssr
dev-dist
.pnpm-store

# Environment and local settings
*.local
.env

# mkcert certificates
dev-key.pem
dev.pem
localhost*.pem
localhost*-key.pem
mkcert+1-key.pem
mkcert+1.pem

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from "@eslint/js";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import globals from "globals";
import tseslint from "typescript-eslint";

export default tseslint.config(
    { ignores: ["dist"] },
    {
        extends: [js.configs.recommended, ...tseslint.configs.recommended],
        files: ["**/*.{ts,tsx}"],
        languageOptions: {
            ecmaVersion: 2020,
            globals: globals.browser,
        },
        plugins: {
            "react-hooks": reactHooks,
            "react-refresh": reactRefresh,
        },
        rules: {
            ...reactHooks.configs.recommended.rules,
            "react-refresh/only-export-components": [
                "warn",
                { allowConstantExport: true },
            ],
        },
    }
);
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
<!-- <link rel="preload" href="/bloccc.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/shotgunshoot.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/gun1.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/entity1.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/table.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/car1.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/ghost.glb" as="fetch" type="model/gltf-binary" crossorigin>
<link rel="preload" href="/shotgun.glb" as="fetch" type="model/gltf-binary" crossorigin> -->

        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>BlockRooms</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>
</file>

<file path="package.json">
{
  "name": "dojo-starter-react",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "dev:https": "VITE_LOCAL_HTTPS=true vite",
    "dev:http": "VITE_LOCAL_HTTPS=false vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "preview:https": "VITE_LOCAL_HTTPS=true vite preview",
    "serve": "vite preview",
    "format:check": "prettier --check .",
    "format": "prettier --write .",
    "mkcert": "mkcert -key-file dev-key.pem -cert-file dev.pem localhost 127.0.0.1 ::1"
  },
  "dependencies": {
    "@cartridge/connector": "^0.10.0",
"@cartridge/controller": "^0.10.0",
"@cartridge/presets": "^0.5.2",
"@dojoengine/core": "1.7.0-preview.2",
"@dojoengine/sdk": "1.7.0-preview.2",
"@dojoengine/torii-client": "1.7.0-preview.2",
"@dojoengine/torii-wasm": "1.7.0-preview.2",
"@dojoengine/utils": "1.7.0-preview.2",
"starknet": "^8.1.2",  
    "@dojoengine/create-burner": "1.7.0-preview.2",
    "@dojoengine/predeployed-connector": "1.7.0-preview.2", 

    "@starknet-react/chains": "^5.0.1",
    "@starknet-react/core": "^5.0.1",

    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@react-three/drei": "^9.122.0",
    "@react-three/fiber": "^8.18.0",
    "@types/uuid": "^10.0.0",
    "buffer": "^6.0.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "immer": "^10.1.1",
    "lucide-react": "^0.518.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1", 
    "tailwind-merge": "^3.3.1",
    "three": "^0.158.0",
    "three-stdlib": "^2.36.0",
    "uuid": "^10.0.0",
    "vite-plugin-top-level-await": "^1.5.0",
    "vite-plugin-wasm": "^3.4.1",
    "zustand": "^4.5.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.29.0",
    "@types/node": "^22.15.32",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.7",
    "@types/three": "^0.177.0",
    "@vitejs/plugin-react": "^4.5.2",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.29.0",
    "eslint-plugin-react-hooks": "5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^15.15.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.34.1",
    "vite": "^5.4.19"
  }
}
</file>

<file path="postcss.config.js">
export default {
    plugins: {
        tailwindcss: {},
        autoprefixer: {},
    },
};
</file>

<file path="README.md">
# üéÆ Dojo Game Starter - Frontend Integration Guide

> **Complete React + Dojo integration documentation**
> From zero to onchain game in 5 minutes ‚ö°

[![Starknet](https://img.shields.io/badge/Starknet-Ready-orange)](https://starknet.io) [![Cairo](https://img.shields.io/badge/Cairo-2.0-blue)](https://cairo-lang.org) [![Dojo](https://img.shields.io/badge/Dojo-ECS-red)](https://dojoengine.org)

## üöÄ Quick Start

> Controller requires the client to run over HTTPS, so make sure you have the `mkcert` package installed on your system

```bash
git clone https://github.com/your-username/dojo-game-starter
cd dojo-game-starter/client
npm install && npm run mkcert && npm run dev:https
```

**That's it!** Your client is running locally with wallet integration, optimistic updates, and seamless blockchain connectivity.

> Note: this quickstart will connect your client to the existing Sepolia deployment, not your local version!

---

## üìö Complete Integration Guide

This documentation series explains how to build robust onchain games using React + Dojo + Starknet. Follow the guides in order for best understanding:

### **üèóÔ∏è Foundation**
| Guide | Description | Key Topics |
|-------|-------------|------------|
| **[01. Overview](./docs/01-overview.md)** | Big picture and core concepts | Architecture, data flow, gaming UX |
| **[02. Architecture](./docs/02-architecture.md)** | System design and components | Providers, layers, performance |
| **[03. Core Files](./docs/03-core-files.md)** | Essential files and their roles | Bindings, contracts, configuration |

### **üîß Integration**
| Guide | Description | Key Topics |
|-------|-------------|------------|
| **[04. Zustand State Management](./docs/04-zustand-state-management.md)** | Global state and optimistic updates | Store patterns, performance, persistence |
| **[05. Cartridge Controller](./docs/05-cartridge-controller.md)** | Gaming wallet integration | Session policies, seamless UX |
| **[06. React Hooks Pattern](./docs/06-react-hooks-pattern.md)** | Custom hooks for blockchain | Data fetching, actions, coordination |

### **‚ö° Advanced**
| Guide | Description | Key Topics |
|-------|-------------|------------|
| **[07. Data Flow](./docs/07-data-flow.md)** | Complete request/response cycles | Real-time gameplay, state sync |
| **[08. Extending the System](./docs/08-extending-system.md)** | Building your dream game | Extension strategies, development approach |

---

## üéØ What You'll Learn

By following this guide series, you'll master:

**üèóÔ∏è Technical Integration**
- React + Dojo + Starknet architecture
- Optimistic updates for instant UX
- Type-safe contract interactions
- Custom hooks for blockchain operations

**üéÆ Gaming-Specific Patterns**
- Cartridge Controller for seamless wallet UX
- Session policies for uninterrupted gameplay
- Real-time state synchronization
- Error handling for blockchain operations

**üöÄ Production Best Practices**
- Performance optimization techniques
- Testing strategies for Web3 apps
- Deployment and environment management
- Scalable architecture patterns

---

## üéÆ Game Mechanics Demo

The starter includes three core actions that demonstrate different interaction patterns:

| Action | Effect | Demonstrates |
|--------|--------|--------------|
| üèãÔ∏è **Train** | +10 EXP | Pure advancement mechanics |
| ‚õèÔ∏è **Mine** | +5 Coins, -5 Health | Risk/reward decisions |
| üí§ **Rest** | +20 Health | Resource management |

These simple mechanics showcase the complete integration stack: from Cairo contracts to React components, with optimistic updates and error handling.

---

## üõ†Ô∏è Tech Stack

```
Frontend:  React + Vite + TypeScript + TailwindCSS
State:     Zustand + React Query patterns
Wallet:    Cartridge Controller + Starknet React
Blockchain: Dojo + Cairo + Starknet
Data:      Torii GraphQL + Optimistic Updates
```

---

## üéØ Perfect For

- üèÜ **Hackathon teams** needing quick onchain game setup
- üéÆ **Game developers** entering Web3 space
- üè¢ **Studios** prototyping blockchain games
- üìö **Developers** learning Starknet + Dojo

---

## üåü Key Features

**‚ö° Instant Feedback**
- Optimistic updates for immediate UI response
- Background blockchain confirmation
- Automatic rollback on transaction failure

**üéÆ Gaming-First UX**
- Cartridge Controller integration
- Session policies for seamless actions
- No wallet popups during gameplay

**üîß Developer Experience**
- Complete TypeScript integration
- Hot reload with contract changes
- Comprehensive error handling
- Testing strategies included

**üöÄ Production Ready**
- Environment-based configuration
- Performance optimizations
- Deployment best practices
- Monitoring and analytics patterns

---

## üöÄ Getting Started

1. **Start with [Overview](./docs/01-overview.md)** to understand the big picture
2. **Follow the guides in order** for comprehensive understanding
3. **Reference specific topics** as needed during development
4. **Use [Extending the System](./docs/09-extending-system.md)** to build your unique game

Each guide builds upon the previous ones, creating a complete learning path from basic concepts to advanced implementation patterns.

---

## üìû Support

- üí¨ **Discord**: [Dojo Engine Community](https://discord.com/invite/dojoengine)
- üìö **Docs**: [Official Dojo Documentation](https://dojoengine.org)
- üê¶ **Twitter**: [@ohayo_dojo](https://twitter.com/ohayo_dojo)

---

**Ready to build the future of onchain gaming?** Start with the [Overview](./docs/01-overview.md) and begin your journey! üöÄ
</file>

<file path="SETUP.md">
# üéÆ Game Setup Guide

## Current Status: **PARTIALLY PLAYABLE** ‚úÖ

The game has a complete hook system and UI, but needs proper configuration to be fully playable.

## üöÄ Quick Setup

### 1. Environment Configuration

Create a `.env.local` file in the `client` directory:

```bash
# Starknet RPC URL (for Sepolia testnet)
VITE_PUBLIC_NODE_URL=https://starknet-sepolia.public.blastapi.io

# Torii Indexer URL (your Dojo indexer)
VITE_PUBLIC_TORII=http://localhost:8080

# Master Account (for game initialization)
VITE_PUBLIC_MASTER_ADDRESS=0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef

# Master Private Key (for game initialization)
VITE_PUBLIC_MASTER_PRIVATE_KEY=0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef

# Game Configuration
VITE_GAME_NAMESPACE=blockrooms
VITE_GAME_SLOT=blockrooms-game
```

### 2. Start the Game

```bash
cd client
npm install
npm run dev
```

### 3. Connect Wallet

1. Open the game in your browser
2. Click "Start Game" 
3. Connect your Starknet wallet (ArgentX, Braavos, etc.)
4. The game will automatically initialize

## üéØ What's Working Now

### ‚úÖ **Complete Features:**
- **40+ Dojo Hooks** - All game functions available
- **Real-time UI** - GameInfo and GameActions panels
- **3D Game Engine** - Three.js with React Three Fiber
- **Wallet Integration** - Starknet wallet connection
- **State Management** - Zustand store with all game data
- **Event System** - Real-time blockchain event listening
- **Type Safety** - Full TypeScript integration

### üéÆ **Game Actions Available:**
- **Player Movement** - Move in 4 directions
- **Combat** - Attack entities
- **Collection** - Collect shards
- **Exploration** - Open doors
- **Turn Management** - Execute complex turns
- **Game Management** - Start/end games, respawn

### üìä **Real-time Data:**
- Player health, position, stats
- Room information and entities
- Game configuration and session data
- Event history and turn tracking

## üîß **What You Need to Complete:**

### 1. **Configure Environment Variables**
- Set up your Dojo indexer URL
- Configure Starknet RPC endpoint
- Add master account credentials

### 2. **Deploy Smart Contract**
- Ensure your Dojo world is deployed
- Verify the contract address in `cartridgeConnector.tsx`
- Make sure Torii indexer is running

### 3. **Test Wallet Connection**
- Install a Starknet wallet (ArgentX recommended)
- Connect to Sepolia testnet
- Ensure you have test tokens

## üéÆ **How to Play:**

### **Basic Gameplay:**
1. **Start Game** - Click the "Start Game" button
2. **Connect Wallet** - Connect your Starknet wallet
3. **Move Around** - Use WASD keys to move
4. **Interact** - Click to shoot, collect items, open doors
5. **Monitor** - Watch the GameInfo panel for real-time stats

### **Advanced Features:**
- **Game Actions Panel** - Execute complex game actions
- **Turn System** - Plan and execute multiple actions per turn
- **Event Tracking** - Monitor blockchain events in real-time
- **Debug Mode** - Development mode shows connection status

## üêõ **Troubleshooting:**

### **Common Issues:**

1. **"Wallet not connected"**
   - Install ArgentX or Braavos wallet
   - Connect to Sepolia testnet
   - Ensure wallet is unlocked

2. **"Player data error"**
   - Check Torii indexer is running
   - Verify environment variables
   - Ensure contract is deployed

3. **"Action failed"**
   - Check wallet has test tokens
   - Verify network connection
   - Check console for detailed errors

### **Debug Information:**
- Development mode shows connection status
- Console logs all game actions
- GameInfo panel shows real-time data
- GameActions panel shows error details

## üöÄ **Next Steps:**

1. **Configure Environment** - Set up your `.env.local`
2. **Deploy Contract** - Ensure Dojo world is live
3. **Test Connection** - Verify wallet and indexer work
4. **Start Playing** - Enjoy the fully integrated game!

## üìà **Game Features:**

### **Core Gameplay:**
- ‚úÖ First-person 3D movement
- ‚úÖ Real-time combat system
- ‚úÖ Item collection mechanics
- ‚úÖ Door/room exploration
- ‚úÖ Turn-based action system

### **Blockchain Integration:**
- ‚úÖ Wallet connection
- ‚úÖ Smart contract interactions
- ‚úÖ Real-time state updates
- ‚úÖ Event listening
- ‚úÖ Transaction management

### **UI/UX:**
- ‚úÖ Game information display
- ‚úÖ Action controls
- ‚úÖ Debug information
- ‚úÖ Connection status
- ‚úÖ Error handling

The game is **architecturally complete** and ready for full playability once configured! üéâ
</file>

<file path="src/app/App.tsx">
import React, { useState, useCallback, useEffect, useRef } from "react";

import { Canvas, useFrame, useThree } from "@react-three/fiber";

import { PointerLockControls } from "@react-three/drei";
import { Vector3 } from "three";
import * as THREE from "three";
import { TransactionPopup } from "../components/ui/TransactionPopup";
import { usePlayerMovement } from "../dojo/hooks/usePlayerMovement";
import { useAttackEntity } from "../dojo/hooks/useAttackEntity";
import useAppStore, { GamePhase } from "../zustand/store";

import { MainMenu } from "../components/ui/MainMenu";
import { Crosshair } from "../components/ui/Crosshair";
import { PlayerHUD } from "../components/ui/PlayerHUD";
// import { MapTracker } from "../components/systems/MapTracker";
import { Gun } from "../components/game/Gun";
import ShotgunShoot from "../models/Shotgunshoot";

import { BloodEffect } from "../components/game/BloodEffect";
import { BulletHole } from "../components/game/BulletHole";
import { EntityCube } from "../components/game/EntityCube";
import { AudioManager } from "../components/systems/AudioManager";
import { FirstPersonControls } from "../components/systems/FirstPersonControls";
import { Model } from "../models/Bloccc";
// import NearbyDoorsComponent from "../components/ui/NearbyDoorsComponent";
import FloorGrid from "../components/game/FloorGrid";

import BlockroomsCard from "../components/ui/BlockroomsCard";
import { HUD } from "../components/ui/HUD";
import GrainVignetteOverlay from "../components/ui/GrainVignetteOverlay";
import DarknessMask from "../components/ui/DarknessMask";
import Flashlight from "../components/ui/Flashlight";
import Table from "../models/Table";
// near your other model imports
import { Ghost } from "../models/Ghost";
// import Pop, { PopHandle } from "../models/Pop";
import GhostPatrol from "../models/GhostPatrol";
import GhostPatrol2 from "../models/GhostPatrol2";
import GhostPatrol3 from "../models/GhostPatrol3";
import GhostPatrol4 from "../models/GhostPatrol4";
import GhostPatrol5 from "../models/GhostPatrol5";
import GhostPatrol6 from "../models/GhostPatrol6";
import GhostPatrol7 from "../models/GhostPatrol7";


import LightProximity from "../components/ui/LightProximity";

import { Shotgun } from "../models/Shotgun";


// Import types
import {
  BloodEffect as BloodEffectType,
  BulletHole as BulletHoleType,
} from "../types/game";
import { useOpenDoor } from "../dojo/hooks/useDoor";
import { useCollectShard } from "../dojo/hooks/useCollectShard";
import { useGameData } from "../dojo/hooks/useGameData";
import { useEndGame } from "../dojo/hooks/useEndGame";

// Door Wall Component
const DoorWall = ({  //THESE ARE DOORS WHICH ARE RED COLOURED. BEING NEAR THEM OPENS UP THE DOOR BY E AND SPAWNS THE ENTITY.
  position,
  rotation,
  doorOpening,
  doorOpened,
}: {
  position: [number, number, number];
  rotation: [number, number, number];
  doorOpening: [number, number, number];
  doorOpened: boolean;
}) => {
  return (
    <group position={position} rotation={rotation}>
      {/* Left wall section */}
      <mesh position={[-2, 1.5, 0]}>
        <boxGeometry args={[3, 3, 0.2]} />
        <meshStandardMaterial color="#612211" />
      </mesh>

      {/* Right wall section */}
      <mesh position={[2, 1.5, 0]}>
        <boxGeometry args={[2, 3, 0.2]} />
        <meshStandardMaterial color="#612211" />
      </mesh>

      {/* Top wall section (above door) */}
      <mesh position={[0, 2.5, 0]}>
        <boxGeometry args={[2, 1, 0.2]} />
        <meshStandardMaterial color="#612211" />
      </mesh>

      {/* Door frame - only show if door is not opened */}
      {!doorOpened && (
        <mesh position={[0, 1, 0]}>
          <boxGeometry args={[2.2, 2.2, 0.15]} />
          <meshStandardMaterial color="#B5BDA8" />
        </mesh>
      )}
    </group>
  );
};

// Center-screen raycast to know if the crosshair is on an enemy
// DONT CHANGE THIS IS JUST THE FRONTEND ENEMY.
const AimProbe = ({ onUpdate }: { onUpdate: (aiming: boolean) => void }) => {
  const { camera, scene } = useThree();
  const raycasterRef = useRef(new THREE.Raycaster());
  const center = useRef(new THREE.Vector2(0, 0)); // crosshair = screen center

  useFrame(() => {
    const ray = raycasterRef.current;
    ray.setFromCamera(center.current, camera);

    const hits = ray.intersectObjects(scene.children, true);

    // consider a hit if any intersected object (or its parent chain) has userData.isEntity
    const onEnemy = hits.some((h) => {
      let o: THREE.Object3D | null = h.object;
      while (o) {
        if (o.userData && o.userData.isEntity) return true;
        o = o.parent as THREE.Object3D | null;
      }
      return false;
    });

    onUpdate(onEnemy);
  });

  return null;
};


// Force the internal WebGL buffer to 1280x720 and DPR=1.
// The canvas will still fill the screen via CSS, but it renders at 720p.
function Force720pHighPerf() {
  const { gl } = useThree();
  useEffect(() => {
    // exact 720p render buffer
    gl.setPixelRatio(1);
    gl.setSize(1280, 720, false);

    // make sure the <canvas> still fills the window (upscaled by the browser)
    const c = gl.domElement as HTMLCanvasElement;
    c.style.width = "100vw";
    c.style.height = "100vh";
    // optional: let the browser choose the best upscaler
    c.style.imageRendering = "auto";
  }, [gl]);
  return null;
}

// Left-click shooter that only affects Ghost 1 / Ghost 2
// FUNCTION TO KILL THE FE GHOST
const GhostClickShooter = ({
  ghost1Ref,
  ghost2Ref,
  enabled = true,
  onGhostShot,
}: {
  ghost1Ref: React.RefObject<THREE.Group>;
  ghost2Ref: React.RefObject<THREE.Group>;
  enabled?: boolean;
  onGhostShot: (which: 1 | 2, hit: THREE.Intersection) => void;
}) => {
  const { camera, scene } = useThree();
  const raycasterRef = useRef(new THREE.Raycaster());
  const center = useRef(new THREE.Vector2(0, 0)); // screen center

  useEffect(() => {
    const onMouseDown = (e: MouseEvent) => {
      if (!enabled) return;
      if (e.button !== 0) return; // only left-click

      const ray = raycasterRef.current;
      ray.setFromCamera(center.current, camera);

      const hits = ray.intersectObjects(scene.children, true);
      if (!hits.length) return;

      // find if any hit belongs under ghost1Ref or ghost2Ref
      const first = hits[0];
      let o: THREE.Object3D | null = first.object;

      const g1 = ghost1Ref.current;
      const g2 = ghost2Ref.current;

      let which: 1 | 2 | null = null;
      while (o) {
        if (g1 && o === g1) {
          which = 1;
          break;
        }
        if (g2 && o === g2) {
          which = 2;
          break;
        }
        o = o.parent as THREE.Object3D | null;
      }

      if (which) onGhostShot(which, first);
    };

    window.addEventListener("mousedown", onMouseDown);
    return () => window.removeEventListener("mousedown", onMouseDown);
  }, [enabled, camera, scene, ghost1Ref, ghost2Ref, onGhostShot]);

  return null;
};

// Small glowing cubes that bob/float near where the enemy cube was
// I WILL REMOVE THIS NOT NEEDED
const ShardCluster = ({
  position,
  visible,
}: {
  position: [number, number, number];
  visible: boolean;
}) => {
  const groupRef = useRef<THREE.Group>(null);

  useFrame((state, delta) => {
    const g = groupRef.current;
    if (!g) return;
    g.rotation.y += delta * 0.6; // gentle spin

    const t = state.clock.getElapsedTime();
    // bob each shard a bit differently
    g.children.forEach((child, i) => {
      const base = 0.18 + i * 0.02;
      child.position.y = base + Math.sin(t * 2 + i * 0.7) * 0.06;
    });
  });

  if (!visible) return null;

  return (
    <group ref={groupRef} position={position}>
      {/* three tiny cubes with different emissive colors */}
      <mesh position={[-0.25, 0.2, 0.15]}>
        <boxGeometry args={[0.26, 0.26, 0.26]} />
        <meshStandardMaterial
          color="#ff5a54"
          emissive="#ff5a54"
          emissiveIntensity={1.6}
          toneMapped={false}
        />
      </mesh>
      <mesh position={[0.18, 0.24, -0.2]}>
        <boxGeometry args={[0.22, 0.22, 0.22]} />
        <meshStandardMaterial
          color="#5aff7c"
          emissive="#5aff7c"
          emissiveIntensity={1.6}
          toneMapped={false}
        />
      </mesh>
      <mesh position={[0.05, 0.28, 0.25]}>
        <boxGeometry args={[0.24, 0.24, 0.24]} />
        <meshStandardMaterial
          color="#4aa8ff"
          emissive="#4aa8ff"
          emissiveIntensity={1.6}
          toneMapped={false}
        />
      </mesh>
    </group>
  );
};

// DO NOT CHANGE
function ExposeCamera() {
  const { camera } = useThree();
  useFrame(() => {
    (window as any).__R3F_CAMERA = camera;
  });
  return null;
}
// DO NOT CHANGE
function AutoLightHoles() {
  const { scene } = useThree();
  const tmp = useRef(new THREE.Vector3());

  useFrame(() => {
    const holes: { x: number; y: number; z: number; r: number }[] = [];
    scene.traverse((obj) => {
      // Only local lights should reduce darkness
      const isSpot = (obj as any).isSpotLight;
      const isPoint = (obj as any).isPointLight;
      if (!isSpot && !isPoint) return;

      const light = obj as THREE.Light & {
        distance?: number;
        intensity: number;
      };
      obj.getWorldPosition(tmp.current);

      // Map light strength -> small world radius for DarknessMask
      // (DarknessMask multiplies 'r' by ~90px internally; keep r small)
      let r = 1.0 + (light.intensity ?? 1) * 0.12; // base
      if (isPoint) r += 0.15; // point lights a touch wider
      if (typeof light.distance === "number" && isFinite(light.distance)) {
        r += Math.min(1.0, light.distance / 120); // gentle widen with distance
      }

      holes.push({ x: tmp.current.x, y: tmp.current.y, z: tmp.current.z, r });
    });

    (window as any).__LIGHT_HOLES = holes; // DarknessMask will read this
  });

  return null;
}
// DO NOT CHANGE, CLEARS CLIENT STORAGE AFTER PRESSING B
async function clearClientStorage(): Promise<void> {
  try {
    // Web Storage
    try { localStorage.clear(); } catch {}
    try { sessionStorage.clear(); } catch {}

    // Cache Storage (service worker caches)
    if ("caches" in window) {
      try {
        const keys = await caches.keys();
        await Promise.all(keys.map((k) => caches.delete(k)));
      } catch {}
    }

    // IndexedDB (delete all known DBs; databases() not on all browsers)
    if ("indexedDB" in window) {
      try {
        const anyIDB = indexedDB as any;
        if (anyIDB.databases) {
          const dbs = await anyIDB.databases();
          await Promise.all(
            (dbs || [])
              .filter((d: any) => d?.name)
              .map(
                (d: any) =>
                  new Promise<void>((resolve) => {
                    const req = indexedDB.deleteDatabase(d.name);
                    req.onsuccess = () => resolve();
                    req.onerror = () => resolve();
                    req.onblocked = () => resolve();
                  })
              )
          );
        }
        // If .databases() doesn‚Äôt exist, we can‚Äôt enumerate names safely‚Äîskip.
      } catch {}
    }

    // Service Workers (optional, if you want a truly clean slate)
    if ("serviceWorker" in navigator) {
      try {
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map((r) => r.unregister()));
      } catch {}
    }

    // Cookies (non-HttpOnly only)
    try {
      const raw = document.cookie;
      if (raw) {
        const parts = raw.split(";"); // "name=value"
        const paths = ["/", location.pathname.split("/").slice(0, 2).join("/") || "/"];
        const domains = [
          location.hostname,
          "." + location.hostname.replace(/^www\./, ""),
        ];

        for (const c of parts) {
          const eq = c.indexOf("=");
          const name = (eq > -1 ? c.slice(0, eq) : c).trim();
          // Delete cookie across common path/domain variants
          for (const p of paths) {
            document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=${p}`;
            for (const d of domains) {
              document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=${p}; domain=${d}`;
            }
          }
        }
      }
    } catch {}
    console.log("‚úÖ Cleared cookies & persistent storage (where allowed by the browser).");
  } catch (e) {
    console.warn("‚ö†Ô∏è Failed to clear some client storage:", e);
  }
}


const App = (): JSX.Element => {
  
// DO NOT CHANGE UNNDER THIS AREA ---------------------------------------------------------------------------
    const [activeWeapon, setActiveWeapon] =
    useState<"pistol" | "shotgun">("pistol");


    useEffect(() => {
  window.dispatchEvent(new CustomEvent("hud:weapon", { detail: { weapon: activeWeapon } }));
}, [activeWeapon]);



      // === MUSIC SYSTEM (BG) ===========================================
  // Files are served from /public/audio/*.mp3
  const mapReadyRef = useRef(false);                   // Canvas created?
  const startedRef = useRef(false);                    // Music started?
  const musicElRef = useRef<HTMLAudioElement | null>(null);

  // timers
  const startTimerRef = useRef<number | null>(null);   // 10s initial delay
  const gapTimerRef = useRef<number | null>(null);     // 30s gap between tracks

  // bookkeeping
  const lastTrackRef = useRef<string | null>(null);
  const playedCountRef = useRef(0);                    // how many tracks finished
  const longPlayedRef = useRef(false);                 // long.mp3 played?
  // --- SFX (shoot & reload) ---------------------------------------------
const shotSfxRef = useRef<HTMLAudioElement | null>(null);
const pistolReloadSfxRef = useRef<HTMLAudioElement | null>(null);
const shotgunReloadSfxRef = useRef<HTMLAudioElement | null>(null);

const playShot = () => playSfx(shotSfxRef, "/audio/shot2.mp3");
const playPistolReload = () => playSfx(pistolReloadSfxRef, "/audio/shotreload.mp3");

  // Create a base <audio>, then clone per play so rapid shots can overlap
  const ensureSfx = (
    ref: React.MutableRefObject<HTMLAudioElement | null>,
    src: string,
    volume = 0.9
  ) => {
    if (!ref.current) {
      const a = new Audio(src);
      a.preload = "auto";
      a.volume = volume;
      ref.current = a;
    }
    return ref.current;
  };

  const playSfx = (
    ref: React.MutableRefObject<HTMLAudioElement | null>,
    src: string
  ) => {
    const base = ensureSfx(ref, src);
    try {
      const a = base.cloneNode(true) as HTMLAudioElement;
      a.currentTime = 0;
      void a.play();
    } catch (e) {
      console.warn("[SFX] play failed:", e);
    }
  };

  

  const bgTracksRef = useRef<string[]>([
    "/audio/music1.mp3",
    "/audio/music2.mp3",
    "/audio/music3.mp3",
    "/audio/muisc4.mp3",
  ]);
  const longTrack = "audio/long.mp3";
const pendingPlayRef = useRef(false);
const resumeHandlersAttachedRef = useRef(false);

  const clearMusicTimers = () => {
    if (startTimerRef.current) { window.clearTimeout(startTimerRef.current); startTimerRef.current = null; }
    if (gapTimerRef.current)   { window.clearTimeout(gapTimerRef.current);   gapTimerRef.current   = null; }
  };

  const stopMusic = () => {
    clearMusicTimers();
    const a = musicElRef.current;
    if (a) {
      try { a.pause(); } catch {}
      a.src = "";
      try { a.load(); } catch {}
    }
    musicElRef.current = null;
    startedRef.current = false;
    playedCountRef.current = 0;
    longPlayedRef.current = false;
    lastTrackRef.current = null;
  };

  const pickRandomShortTrack = (): string => {
    const list = bgTracksRef.current;
    const candidates = list.filter((t) => t !== lastTrackRef.current);
    const pool = candidates.length ? candidates : list; // fallback if all same
    const idx = Math.floor(Math.random() * pool.length);
    return pool[idx];
  };

const playTrack = (src: string) => {
  let a = musicElRef.current;

  // Create once; reuse forever
  if (!a) {
    a = new Audio();
    a.preload = "auto";
    a.loop = false;
    a.volume = 0.35;

    a.onerror = (ev) => {
      console.error("[BG-MUSIC] audio error for", a?.src, ev);
    };

    a.onended = () => {
      playedCountRef.current += 1;
      lastTrackRef.current = a?.src || null;
      console.log("[BG-MUSIC] ended:", lastTrackRef.current, "playedCount =", playedCountRef.current);
      console.log("[BG-MUSIC] waiting 30s before next‚Ä¶");
      gapTimerRef.current = window.setTimeout(() => {
        scheduleNextTrack();
      }, 30_000);
    };

    musicElRef.current = a;
  } else {
    try { a.pause(); } catch {}
  }

  a.currentTime = 0;
  a.src = src;
  console.log("[BG-MUSIC] trying to play:", src);

  a.play().then(() => {
    console.log("[BG-MUSIC] playing:", src);
    pendingPlayRef.current = false;
  }).catch((err) => {
    console.warn("[BG-MUSIC] play blocked (autoplay). Will resume on next gesture.", err);
    pendingPlayRef.current = true;
  });
};


  const scheduleNextTrack = () => {
    let next: string;
    // After more than 2 tracks have played (i.e., 3rd finished), play long.mp3 once
    if (!longPlayedRef.current && playedCountRef.current >= 3) {
      next = longTrack;
      longPlayedRef.current = true;
    } else {
      next = pickRandomShortTrack();
    }
    playTrack(next);
  };

  const maybeStartMusic = () => {
    if (startedRef.current || !mapReadyRef.current) return;
    startedRef.current = true;
    // 10s after map (Canvas) is ready
    startTimerRef.current = window.setTimeout(() => {
      scheduleNextTrack();
    }, 10_000);
  };

  useEffect(() => {
  if (resumeHandlersAttachedRef.current) return;

  const resume = () => {
    if (!pendingPlayRef.current) return;
    const a = musicElRef.current;
    if (!a) return;
    a.play().then(() => {
      console.log("[BG-MUSIC] resumed via global gesture");
      pendingPlayRef.current = false;
    }).catch((e) => console.warn("[BG-MUSIC] global resume failed:", e));
  };

  window.addEventListener("pointerdown", resume, true);
  window.addEventListener("mousedown",  resume, true);
  window.addEventListener("click",       resume, true);
  window.addEventListener("touchstart",  resume, { capture: true, passive: true } as any);
  window.addEventListener("keydown",     resume, true);

  resumeHandlersAttachedRef.current = true;
  return () => {
    window.removeEventListener("pointerdown", resume, true);
    window.removeEventListener("mousedown",  resume, true);
    window.removeEventListener("click",       resume, true);
    window.removeEventListener("touchstart",  resume, { capture: true } as any);
    window.removeEventListener("keydown",     resume, true);
    resumeHandlersAttachedRef.current = false;
  };
}, []);

  // ========================================================================TILL HERE DO NOT CHANGE



  // THIS IS WHERE THE FUCKERY STARTS :)
  // IMPORTANT: All hooks must be called unconditionally at the top
  // Get game session state, UI state, and player state from Zustand store
  const [doorOpened, setDoorOpened] = useState<boolean>(false); // Room 1 doors (1 & 2)
  const [door2Opened, setDoor2Opened] = useState<boolean>(false); // Room 2 doors (3 & 4)
  const [door3Opened, setDoor3Opened] = useState<boolean>(false); // Doors 5 & 6
  const [door4Opened, setDoor4Opened] = useState<boolean>(false);
  const [door5Opened, setDoor5Opened] = useState<boolean>(false); // Room 5 (doors 8 & 9)
  const [door6Opened, setDoor6Opened] = useState<boolean>(false); // Room 6 (doors 10 & 11)
  const [door7Opened, setDoor7Opened] = useState<boolean>(false); // Room 7 (doors 12 & 13)
  // const [door8Opened, setDoor8Opened] = useState<boolean>(false);   // Room 8 (doors 14 & 15)
  // const [door9Opened, setDoor9Opened] = useState<boolean>(false);   // Room 9 (doors 16 & 17)

  const {
    gameStarted,
    showGun,
    showCrosshair,
    showMapTracker,
    position: playerPosition,
    rotation: playerRotation,
    connectionStatus,
    player,
    currentRoom,
    gamePhase,
    updatePosition,
    updateRotation,
    entities,
  } = useAppStore();
// THESE BELOW ARE FE GHOSTS========================================================
  // const popRef = useRef<PopHandle | null>(null);
  // Refs for click-detection wrappers around the ghosts
  const ghost1Ref = useRef<THREE.Group | null>(null);
  const ghost2Ref = useRef<THREE.Group | null>(null);
  const ghost3Ref = useRef<THREE.Group | null>(null);
  const ghost4Ref = useRef<THREE.Group | null>(null);
  const ghost5Ref = useRef<THREE.Group | null>(null);
  const ghost6Ref = useRef<THREE.Group | null>(null);
  const ghost7Ref = useRef<THREE.Group | null>(null);

  // Local HP counters (3 hits to kill)
  const [ghost1Hits, setGhost1Hits] = useState(0);
  const [ghost2Hits, setGhost2Hits] = useState(0);
  const [ghost1Dead, setGhost1Dead] = useState(false);
  const [ghost2Dead, setGhost2Dead] = useState(false);
  const [ghost3Dead, setGhost3Dead] = useState(false);
  const [ghost4Dead, setGhost4Dead] = useState(false);
  const [ghost5Dead, setGhost5Dead] = useState(false);
  const [ghost6Dead, setGhost6Dead] = useState(false);
  const [ghost7Dead, setGhost7Dead] = useState(false);

  // --- Ghost spawn gating --- (v2)

  const GHOST4 = { x: 294, z: 346, radius: 10 };
  const GHOST7 = { x: 402, z: 322, radius: 10 };

  const [ghost1Spawned, setGhost1Spawned] = useState(false);
  const [ghost2Spawned, setGhost2Spawned] = useState(false);
  const [ghost3Spawned, setGhost3Spawned] = useState(false);
  const [ghost4Spawned, setGhost4Spawned] = useState(false);
  const [ghost7Spawned, setGhost7Spawned] = useState(false);
  const [ghostsPreloaded, setGhostsPreloaded] = useState(false);






  const nearGhost4 =
    Math.hypot(playerPosition.x - GHOST4.x, playerPosition.z - GHOST4.z) <=
    GHOST4.radius;

 

  const nearGhost7 =
    Math.hypot(playerPosition.x - GHOST7.x, playerPosition.z - GHOST7.z) <=
    GHOST7.radius;

useEffect(() => {
  if (ghostsPreloaded && !ghost1Spawned) setGhost1Spawned(true);
}, [ghostsPreloaded, ghost1Spawned]);

useEffect(() => {
  if (ghostsPreloaded && !ghost2Spawned) setGhost2Spawned(true);
}, [ghostsPreloaded, ghost2Spawned]);


  useEffect(() => {
    if (ghostsPreloaded && !ghost3Spawned) setGhost3Spawned(true);
  }, [ghostsPreloaded, ghost3Spawned]);
  useEffect(() => {
    if (!ghost4Spawned && nearGhost4) setGhost4Spawned(true);
  }, [nearGhost4, ghost4Spawned]);



  useEffect(() => {
    if (ghostsPreloaded && !ghost7Spawned) setGhost7Spawned(true);
  }, [ghostsPreloaded, ghost7Spawned]);;

  // First pickup: equip gun only (no ammo), at (399, 392)
  const FIRST_PICKUP = { x: 399, z: 392 };
  const [firstPickupTaken, setFirstPickupTaken] = useState(false);

  // within RANGE of first pickup, and gun not yet shown
  const isNearFirstPickup =
    !showGun &&
    !firstPickupTaken &&
    Math.abs(playerPosition.x - FIRST_PICKUP.x) <= 2.0 &&
    Math.abs(playerPosition.z - FIRST_PICKUP.z) <= 2.0;

  // --- Gun pickups (session-local; non-persistent) ---
  type Pickup = { id: "P1" | "P2" | "P3"; x: number; z: number };
  const PICKUPS: Pickup[] = [
    { id: "P1", x: 350, z: 392 },
    { id: "P2", x: 369, z: 277 },
    { id: "P3", x: 338, z: 322 },
  ];

  const [pickupTaken, setPickupTaken] = useState<Record<Pickup["id"], boolean>>(
    {
      P1: false,
      P2: false,
      P3: false,
    }
  );

  const PICK_RANGE = 2.0;
  const activePickup = (() => {
    for (const p of PICKUPS) {
      if (pickupTaken[p.id]) continue;
      if (
        Math.abs(playerPosition.x - p.x) <= PICK_RANGE &&
        Math.abs(playerPosition.z - p.z) <= PICK_RANGE
      )
        return p;
    }
    return null;
  })();
// UPTIL HERE NOT CHANGE==============================================================================================
// AGAIN SOME FUCKERY BELOW
  const {
    showTransactionPopup,
    transactionError,
    isProcessingTransaction,
    closeTransactionPopup,
  } = usePlayerMovement();
  const { isLoading, enterDoor, exitDoor } = useOpenDoor();
  const { attackEntity } = useAttackEntity();
  const { collectShard } = useCollectShard();
  const { refetch: refetchGameData } = useGameData();

  // Track shard collection per room (session-local UI state)
  const [room1ShardCollected, setRoom1ShardCollected] = useState(false);
  const [room2ShardCollected, setRoom2ShardCollected] = useState(false);
  const [room3ShardCollected, setRoom3ShardCollected] = useState(false); // shard for room 3
  const [room4ShardCollected, setRoom4ShardCollected] = useState(false); // shard for room 4
  const [room5ShardCollected, setRoom5ShardCollected] = useState(false); // shard for room 5
  const [room6ShardCollected, setRoom6ShardCollected] = useState(false); // shard for room 6
  const [room7ShardCollected, setRoom7ShardCollected] = useState(false); // shard for room 7

  // State for entity cubes, THESE ARE THE ONCHAIN ENEMIES
  const [entityCubeVisible, setEntityCubeVisible] = useState<boolean>(false); // room 1
  const [cubePosition] = useState<[number, number, number]>([389, 1.5, 308]);
  const [entityCube2Visible, setEntityCube2Visible] = useState<boolean>(false); // room 2
  const [cube2Position] = useState<[number, number, number]>([343, 1.5, 299]);
  const [entityCube3Visible, setEntityCube3Visible] = useState<boolean>(false);
  const [cube3Position] = useState<[number, number, number]>([349, 1.5, 393]); // pick a spot in R3z
  const [entityCube4Visible, setEntityCube4Visible] = useState<boolean>(false);
  const [cube4Position] = useState<[number, number, number]>([322, 1.5, 372]); // spawn entity R4
  const [entityCube5Visible, setEntityCube5Visible] = useState<boolean>(false);
  const [cube5Position] = useState<[number, number, number]>([300, 1.5, 350]); // spawn entity R5
  const [entityCube6Visible, setEntityCube6Visible] = useState<boolean>(false);
  const [cube6Position] = useState<[number, number, number]>([274, 1.5, 334]); // spawn entity R6
  const [entityCube7Visible, setEntityCube7Visible] = useState<boolean>(false);
  const [cube7Position] = useState<[number, number, number]>([277, 1.5, 295]); // spawn entity R7

  // Local VFX/UI state, CONTAINS SOME FE, REST E,X,Q AND B ARE THE ONCHAIN FUNCTIONS
  const [aimingAtEntity, setAimingAtEntity] = useState(false);

  const [bulletHoles, setBulletHoles] = useState<BulletHoleType[]>([]);
  const [bloodEffects, setBloodEffects] = useState<BloodEffectType[]>([]);
  const [ePressed, setEPressed] = useState<boolean>(false);
  const [fPressed, setFPressed] = useState<boolean>(false);
  const [showShootPrompt, setShowShootPrompt] = useState<boolean>(false);

  const [xPressed, setXPressed] = useState<boolean>(false);
  const [showShardPrompt, setShowShardPrompt] = useState<boolean>(false);
  const [shardPromptKey, setShardPromptKey] = useState<number>(0);
  const [qPressed, setQPressed] = useState<boolean>(false);
  const [bPressed, setBPressed] = useState<boolean>(false);

const [canEndGame, setCanEndGame] = useState<boolean>(true);

  const [showExitPrompt, setShowExitPrompt] = useState<boolean>(false);
  const [exitPromptKey, setExitPromptKey] = useState<number>(0);
  const [shootPanelEnabled, setShootPanelEnabled] = useState<boolean>(false);
  const [shardPanelEnabled, setShardPanelEnabled] = useState<boolean>(false);
  const [exitPanelEnabled, setExitPanelEnabled] = useState<boolean>(false);
  const [promptKey, setPromptKey] = useState<number>(0);

  const { endGame } = useEndGame();

  // Reloading HUD state from Gun.tsx events, NO CHANGES SER
  const [isReloadingHud, setIsReloadingHud] = useState(false);
    // When a reload starts, play a one-shot SFX
useEffect(() => {
  if (!isReloadingHud) return;
  if (activeWeapon === "shotgun") {
    playShotgunReload();
  } else {
    playPistolReload();
  }
}, [isReloadingHud, activeWeapon]);

// A LITTLE CONFUSION HERE
  useEffect(() => {
    const onRel = (e: Event) => {
      const ce = e as CustomEvent<{ reloading: boolean }>;
      setIsReloadingHud(!!ce.detail?.reloading);
    };
    window.addEventListener("hud:reloading", onRel as EventListener);
    return () =>
      window.removeEventListener("hud:reloading", onRel as EventListener);
  }, []);
  // Initialize player position at map center on component mount
  useEffect(() => {
    const mapCenterPosition = new Vector3(400, 1.5, 400);
    updatePosition(mapCenterPosition);
  }, [updatePosition]);
// FUCKERY FUCKERY FUCKERY
  // Room 1: hide cube when entity dies (open is gated to Q+shard)
  useEffect(() => {
    if (entityCubeVisible) {
      const entity = entities.filter((e) => e.room_id.toString() === "1");
      if (entity.length > 0) {
        const target = entity[0];
        if (!target.is_alive || Number(target.health) <= 0) {
          console.log("Room 1 entity died, hiding cube");
          setEntityCubeVisible(false);
          setShootPanelEnabled(false);
          if (!room1ShardCollected) setShardPanelEnabled(true); // enable only if not collected yet
        } else {
          setShardPanelEnabled(false);
        }
      }
    }
  }, [entities, entityCubeVisible, room1ShardCollected]);

  // Room 2: hide cube when entity dies
  useEffect(() => {
    if (!entityCube2Visible) return;
    const entity = entities.filter((e) => e.room_id.toString() === "2");
    if (entity.length > 0) {
      const target = entity[0];
      if (!target.is_alive || Number(target.health) <= 0) {
        console.log("Room 2 entity died, hiding cube");
        setEntityCube2Visible(false);
        setShootPanelEnabled(false);
        if (!room2ShardCollected) setShardPanelEnabled(true);
      } else {
        setShardPanelEnabled(false);
      }
    }
    // NOTE: if list is empty temporarily after enterDoor, do nothing
  }, [entities, entityCube2Visible, room2ShardCollected]);

  // Room 3: hide cube when entity dies
  useEffect(() => {
    if (!entityCube3Visible) return;
    const entity = entities.filter((e) => e.room_id.toString() === "3");
    if (entity.length > 0) {
      const target = entity[0];
      if (!target.is_alive || Number(target.health) <= 0) {
        console.log("Room 3 entity died, hiding cube");
        setEntityCube3Visible(false);
        setShootPanelEnabled(false);
        if (!room3ShardCollected) setShardPanelEnabled(true);
      } else {
        setShardPanelEnabled(false);
      }
    }
    // NOTE: if list is empty temporarily after enterDoor, do nothing
  }, [entities, entityCube3Visible, room3ShardCollected]);

  // Room 4: hide cube when entity dies
  useEffect(() => {
    if (!entityCube4Visible) return;
    const entity = entities.filter((e) => e.room_id.toString() === "4");
    if (entity.length > 0) {
      const target = entity[0];
      if (!target.is_alive || Number(target.health) <= 0) {
        console.log("Room 4 entity died, hiding cube");
        setEntityCube4Visible(false);
        setShootPanelEnabled(false);
        if (!room4ShardCollected) setShardPanelEnabled(true);
      } else {
        setShardPanelEnabled(false);
      }
    }
    // NOTE: if list is empty temporarily after enterDoor, do nothing
  }, [entities, entityCube4Visible, room4ShardCollected]);

  // Room 5: hide cube when entity dies
  useEffect(() => {
    if (!entityCube5Visible) return;
    const entity = entities.filter((e) => e.room_id.toString() === "5");
    if (entity.length > 0) {
      const target = entity[0];
      if (!target.is_alive || Number(target.health) <= 0) {
        console.log("Room 5 entity died, hiding cube");
        setEntityCube5Visible(false);
        setShootPanelEnabled(false);
        if (!room5ShardCollected) setShardPanelEnabled(true);
      } else {
        setShardPanelEnabled(false);
      }
    }
    // NOTE: if list is empty temporarily after enterDoor, do nothing
  }, [entities, entityCube5Visible, room5ShardCollected]);

  // Room 6: hide cube when entity dies
  useEffect(() => {
    if (!entityCube6Visible) return;
    const entity = entities.filter((e) => e.room_id.toString() === "6");
    if (entity.length > 0) {
      const target = entity[0];
      if (!target.is_alive || Number(target.health) <= 0) {
        console.log("Room 6 entity died, hiding cube");
        setEntityCube6Visible(false);
        setShootPanelEnabled(false);
        if (!room6ShardCollected) setShardPanelEnabled(true);
      } else {
        setShardPanelEnabled(false);
      }
    }
    // NOTE: if list is empty temporarily after enterDoor, do nothing
  }, [entities, entityCube6Visible, room6ShardCollected]);

  // Room 7: hide cube when entity dies
  useEffect(() => {
    if (!entityCube7Visible) return;
    const entity = entities.filter((e) => e.room_id.toString() === "7");
    if (entity.length > 0) {
      const target = entity[0];
      if (!target.is_alive || Number(target.health) <= 0) {
        console.log("Room 7 entity died, hiding cube");
        setEntityCube7Visible(false);
        setShootPanelEnabled(false);
        if (!room7ShardCollected) setShardPanelEnabled(true);
      } else {
        setShardPanelEnabled(false);
      }
    }
    // NOTE: if list is empty temporarily after enterDoor, do nothing
  }, [entities, entityCube7Visible, room7ShardCollected]);
// IF THE PLAYER IS NEAR THESE COORDINATES, THE DOOR MAPPED TO THOSE COORDINATES WOULD BE ENABLED IN THE UI.
// THEN PRESS E TO ENTER AND ENTUTY SPAWNS
  // Helper: door proximity
  const isAtDoorPosition = useCallback(() => {
    const x = Math.round(playerPosition.x);
    const z = Math.round(playerPosition.z);

    // Room 1
    const atDoor1 = x >= 370 && x <= 374 && z >= 305 && z <= 308;
    const atDoor2 = x >= 382 && x <= 387 && z >= 324 && z <= 328;

    // Room 2
    const atDoor3 = x >= 350 && x <= 360 && z >= 290 && z <= 300;
    const atDoor4 = x >= 335 && x <= 345 && z >= 290 && z <= 300;

    // Room 3 (frontend coords; "y" == z)
    const atDoor5 = x >= 363 && x <= 370 && z >= 398 && z <= 405;
    const atDoor6 = x >= 363 && x <= 364 && z >= 367 && z <= 370;

    // Room 4
    const atDoor7 = x >= 323 && x <= 324 && z >= 358 && z <= 359;

    // Room 5
    const atDoor8 = x >= 303 && x <= 304 && z >= 349 && z <= 350;
    const atDoor9 = x >= 288 && x <= 289 && z >= 377 && z <= 378;
    //this is correct and works

    // Room 6  (doors 10, 11)
    const atDoor10 = x >= 278 && x <= 282 && z >= 347 && z <= 349; // include 282 (281.5 ‚Üí 282)
    const atDoor11 = x >= 269 && x <= 274 && z >= 320 && z <= 322;
    //this is showing room5 in ui and gql --> must be room6

    // Room 7
    const atDoor12 = x >= 275 && x <= 278 && z >= 281 && z <= 283;
    const atDoor13 = x >= 281 && x <= 283 && z >= 308 && z <= 311;
    //this is showing room6 in ui and gql --> must be room7

    return {
      atDoor1,
      atDoor2,
      atDoor3,
      atDoor4,
      atDoor5,
      atDoor6,
      atDoor7,
      atDoor8,
      atDoor9,
      atDoor10,
      atDoor11,
      atDoor12,
      atDoor13,
      atAnyDoor:
        atDoor1 ||
        atDoor2 ||
        atDoor3 ||
        atDoor4 ||
        atDoor5 ||
        atDoor6 ||
        atDoor7 ||
        atDoor8 ||
        atDoor9 ||
        atDoor10 ||
        atDoor11 ||
        atDoor12 ||
        atDoor13,
    };
  }, [playerPosition]);

  // Helper: Resolve the active room id from store.currentRoom / player.current_room / door proximity
  // "1" | "2" | "3" | "4" | "5" | "6" | "7"
  const resolveRoomId = useCallback(():
    | "1"
    | "2"
    | "3"
    | "4"
    | "5"
    | "6"
    | "7" => {
    const store = useAppStore.getState();
    const cr: any = store.currentRoom;

    let id: any = cr;
    if (cr && typeof cr === "object") {
      id = cr.room_id ?? cr.id ?? cr.current_room ?? null;
    }
    if (id == null) id = store.player?.current_room ?? null;

    if (id == null) {
      const d = isAtDoorPosition();
      if (d.atDoor3 || d.atDoor4) return "2";
      if (d.atDoor5 || d.atDoor6) return "3";
      if (d.atDoor7) return "4";
      if (d.atDoor8 || d.atDoor9) return "5";
      if (d.atDoor10 || d.atDoor11) return "6";
      if (d.atDoor12 || d.atDoor13) return "7";

      return "1";
    }

    const s = String(id);
    if (s === "2") return "2";
    if (s === "3") return "3";
    if (s === "4") return "4";
    if (s === "5") return "5";
    if (s === "6") return "6";
    if (s === "7") return "7";
    return "1";
  }, [isAtDoorPosition]);

  const getActiveRoomId = useCallback(():
    | "1"
    | "2"
    | "3"
    | "4"
    | "5"
    | "6"
    | "7" => {
    const cr = currentRoom?.toString?.();
    if (
      cr === "1" ||
      cr === "2" ||
      cr === "3" ||
      cr === "4" ||
      cr === "5" ||
      cr === "6" ||
      cr === "7"
    )
      return cr as "1" | "2" | "3" | "4" | "5" | "6" | "7";
    const d = isAtDoorPosition();
    if (d.atDoor3 || d.atDoor4) return "2";
    if (d.atDoor5 || d.atDoor6) return "3";
    if (d.atDoor7) return "4";
    if (d.atDoor8 || d.atDoor9) return "5";
    if (d.atDoor10 || d.atDoor11) return "6";
    if (d.atDoor12 || d.atDoor13) return "7";
    return "1";
  }, [currentRoom, isAtDoorPosition]);

  // Key handlers DO NOT CHANGE, IT PICKS UP THE GUNS
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // T ‚Üí pick up / show gun (runtime only)
      if (event.key.toLowerCase() === "t") {
        // 1) First pickup: only equips the gun at (399, 392)
        if (isNearFirstPickup) {
          useAppStore.getState().setShowGun(true);
          setFirstPickupTaken(true); // hide the first pickup's asset/prop if you guard it
          return;
        }

        // 2) Other pickups: grant +10 reserve and hide that pickup
        const p = activePickup;
        if (p) {
          // NOTE: these are the three ammo pickups you already defined
          window.dispatchEvent(
            new CustomEvent("gun:addAmmo", { detail: { amount: 10 } })
          );
          setPickupTaken((prev) => ({ ...prev, [p.id]: true }));
          return;
        }

        return;
      }

      // 1/2 ‚Üí switch weapons (pistol / shotgun)
      if (event.key === "1") {
        // Only switch if the gun is visible/equipped
        if (useAppStore.getState().showGun) setActiveWeapon("pistol");
        window.dispatchEvent(new CustomEvent("hud:weapon", { detail: { weapon: "pistol" } }));

        return;
      }
      if (event.key === "2") {
        if (useAppStore.getState().showGun) setActiveWeapon("shotgun");
        window.dispatchEvent(new CustomEvent("hud:weapon", { detail: { weapon: "shotgun" } }));

        return;
      }


      // ENTER a door with E (unchanged), SOME FUCKERY HERE
      if (event.key.toLowerCase() === "e" && !isLoading) {
        const doorCheck = isAtDoorPosition();

        if (!doorCheck.atAnyDoor) {
          console.log("‚ùå Not at door position. Current:", {
            x: Math.round(playerPosition.x),
            z: Math.round(playerPosition.z),
          });
          console.log("Door 1: X=370-374, Z=305-308");
          console.log("Door 2: X=382-387, Z=324-328");
          console.log("Door 3: X=350-360, Z=290-300");
          console.log("Door 4: X=335-345, Z=290-300");
          return;
        }

        setEPressed(true);

        // Determine door id by position
        let doorId = "1";
        if (doorCheck.atDoor2) doorId = "2";
        else if (doorCheck.atDoor3) doorId = "3";
        else if (doorCheck.atDoor4) doorId = "4";
        else if (doorCheck.atDoor5) doorId = "5";
        else if (doorCheck.atDoor6) doorId = "6";
        else if (doorCheck.atDoor7) doorId = "7";
        else if (doorCheck.atDoor8) doorId = "8";
        else if (doorCheck.atDoor9) doorId = "9";
        else if (doorCheck.atDoor10) doorId = "10";
        else if (doorCheck.atDoor11) doorId = "11";
        else if (doorCheck.atDoor12) doorId = "12";
        else if (doorCheck.atDoor13) doorId = "13";

        enterDoor(doorId)
        
          .then((result) => {
            if (result.success) 
              {
              console.log(`Door ${doorId} opened successfully...`);
              setCanEndGame(false); // disable "B" until we exit via Q


              // Map door -> room
              const targetRoomId =
                doorId === "3" || doorId === "4"
                  ? "2"
                  : doorId === "5" || doorId === "6"
                  ? "3"
                  : doorId === "7"
                  ? "4"
                  : doorId === "8" || doorId === "9"
                  ? "5"
                  : doorId === "10" || doorId === "11"
                  ? "6"
                  : doorId === "12" || doorId === "13"
                  ? "7"
                  : "1";

              if (targetRoomId === "1") {
                setDoorOpened(true);
                setTimeout(() => setEntityCubeVisible(true), 1000);
              } else if (targetRoomId === "2") {
                setDoor2Opened(true);
                setTimeout(() => setEntityCube2Visible(true), 1000);
              } else if (targetRoomId === "3") {
                setDoor3Opened(true);
                setTimeout(() => setEntityCube3Visible(true), 1000);
              } else if (targetRoomId === "4") {
                setDoor4Opened(true);
                setTimeout(() => setEntityCube4Visible(true), 1000);
              } else if (targetRoomId === "5") {
                setDoor5Opened(true);
                setTimeout(() => setEntityCube5Visible(true), 1000);
              } else if (targetRoomId === "6") {
                setDoor6Opened(true);
                setTimeout(() => setEntityCube6Visible(true), 1000);
              } else if (targetRoomId === "7") {
                setDoor7Opened(true);
                setTimeout(() => setEntityCube7Visible(true), 1000);
              }

              setShardPanelEnabled(false); // shard stays disabled until kill
              setExitPanelEnabled(false); // exit stays disabled until shard is collected
              setShootPanelEnabled(true); // (ensure F panel is enabled on entry)
            } else {
              console.error("Failed to open door:", result.error);
            }
          })
          .catch((error) => console.error("Door opening error:", error));

        setTimeout(() => setEPressed(false), 1000);
        setTimeout(() => {
          refetchGameData();
        }, 1200);
      }
if (event.key.toLowerCase() === "b") {
  if (!canEndGame) {
    // ignore B while between E (entered) and Q (exited)
    return;
  }
  setBPressed(true);

  // üî• Clear browser cookies & persistent storage immediately on B
  clearClientStorage();

  const gameState = useAppStore.getState();
  if (gameState.player && gameState.currentRoom) {
    console.log(`üè† End the game`);
  }

  endGame()
    .then((result) => {
      if (result.success) {
        stopMusic(); // üí° stop bg music when game session ends
        console.log(`Ended game successfully`);
      } else {
        console.error("Failed to exit door:", result.error);
      }
    })

    .catch((error) => {
      console.error("Door exit error:", error);
    });

  setTimeout(() => setBPressed(false), 1000);
}


      // SHOOT with F ‚Äî FIXED to use currentRoom (not door proximity)
      // Handle F key press for shooting (use currentRoom from GraphQL/store)
      // Handle F key press for shooting (normalize room id)
       // SHOOT with F ‚Äî disabled. Attacks now come from shotgun left-click hits.


       // YES IF YOU EQUIPB THE SHOTGUN AND SHOOT, IT DOES THE F FUNCTION WE USED TO HAVE
      if (event.key.toLowerCase() === "f") {
        return;
      }


      // COLLECT shard with X ‚Äî FIXED to use currentRoom (not door proximity)
      // Handle X key press for shard collection (normalize room id)
      if (event.key.toLowerCase() === "x") {
        if (!shardPanelEnabled) return; // üö´ ignore when panel is disabled
        setXPressed(true);

        const store = useAppStore.getState();
        const shardLocations = store.shardLocations ?? []; // ‚úÖ add this

        const targetRoomId = resolveRoomId();

        const shard = shardLocations.filter(
          (s: any) => String(s.room_id) === targetRoomId
        );
        const shardId = shard[0]?.shard_id?.toString() || "";

        if (!shardId) {
          console.warn(`No shard found in room ${targetRoomId}`);
          setTimeout(() => setXPressed(false), 200);
          return;
        }

        collectShard(shardId).then((result) => {
          if (result.success) {
            console.log("‚úÖ Shard collected");
            if (targetRoomId === "1") setRoom1ShardCollected(true);
            else if (targetRoomId === "2") setRoom2ShardCollected(true);
            else if (targetRoomId === "3") setRoom3ShardCollected(true);
            else if (targetRoomId === "4") setRoom4ShardCollected(true);
            else if (targetRoomId === "5") setRoom5ShardCollected(true);
            else if (targetRoomId === "6") setRoom6ShardCollected(true);
            else setRoom7ShardCollected(true);

            setExitPanelEnabled(true);
            setShardPanelEnabled(false);
            refetchGameData();
          }
        });

        setTimeout(() => setXPressed(false), 200);
      }

      // EXIT + open-and-keep-open via Q (unchanged logic, now works for both rooms)
      if (event.key.toLowerCase() === "q") {
        if (!exitPanelEnabled) return; // üö´ ignore when panel is disabled
        setQPressed(true);

        const roomId = resolveRoomId(); // which room we're in
        // ...

        const allEntities = useAppStore.getState().entities;
        const roomEntities = allEntities.filter(
          (e) => e.room_id.toString() === roomId
        );
        const entityDead =
          roomEntities.length === 0 ||
          roomEntities.every((e) => !e.is_alive || Number(e.health) <= 0);

        const shardCollected =
          roomId === "1"
            ? room1ShardCollected
            : roomId === "2"
            ? room2ShardCollected
            : roomId === "3"
            ? room3ShardCollected
            : roomId === "4"
            ? room4ShardCollected
            : roomId === "5"
            ? room5ShardCollected
            : roomId === "6"
            ? room6ShardCollected
            : room7ShardCollected;

        if (!entityDead || !shardCollected) {
          console.log(
            `‚ùå Room ${roomId}: kill entity and collect shard first, then press Q.`
          );
          setTimeout(() => setQPressed(false), 1000);
          return;
        }

        // üîÑ make sure store.currentRoom.cleared === true (required by useOpenDoor)
        refetchGameData().then(() => {
          const cleared = useAppStore.getState().currentRoom?.cleared === true;
          if (!cleared) {
            // one quick retry for indexer lag
            setTimeout(() => {
              refetchGameData().then(() => {
                const cleared2 =
                  useAppStore.getState().currentRoom?.cleared === true;
                if (!cleared2) {
                  console.warn(
                    `Cannot exit Room ${roomId} yet ‚Äì room not marked cleared by chain.`
                  );
                  setTimeout(() => setQPressed(false), 1000);
                  return;
                }

                if (roomId === "1") setDoorOpened(true);
                else if (roomId === "2") setDoor2Opened(true);
                else if (roomId === "3") setDoor3Opened(true);
                else setDoor4Opened(true);

                // choose door id for exit (1‚Üí1/2, 2‚Üí3/4, 3‚Üí5/6, 4‚Üí7, 5‚Üí8/9)
                const here = isAtDoorPosition();
                let doorIdForExit: string = roomId;

                if (roomId === "1") {
                  if (here.atDoor1) doorIdForExit = "1";
                  else if (here.atDoor2) doorIdForExit = "2";
                  else doorIdForExit = "1";
                } else if (roomId === "2") {
                  if (here.atDoor3) doorIdForExit = "3";
                  else if (here.atDoor4) doorIdForExit = "4";
                  else doorIdForExit = "3";
                } else if (roomId === "3") {
                  if (here.atDoor5) doorIdForExit = "5";
                  else if (here.atDoor6) doorIdForExit = "6";
                  else doorIdForExit = "5";
                } else if (roomId === "4") {
                  doorIdForExit = "7"; // only one door
                } else if (roomId === "5") {
                  if (here.atDoor8) doorIdForExit = "8";
                  else if (here.atDoor9) doorIdForExit = "9";
                  else doorIdForExit = "8";
                } else if (roomId === "6") {
                  if (here.atDoor10) doorIdForExit = "10";
                  else if (here.atDoor11) doorIdForExit = "11";
                  else doorIdForExit = "10";
                } else if (roomId === "7") {
                  if (here.atDoor12) doorIdForExit = "12";
                  else if (here.atDoor13) doorIdForExit = "13";
                  else doorIdForExit = "12";
                }

                setExitPanelEnabled(false); // hide exit panel once used

                exitDoor(doorIdForExit)
                .then((res) => {
  if (res?.success) {
    setCanEndGame(true); // re-enable "B" after exit confirms
    refreshRoomAfterExit(roomId); // ‚úÖ pull fresh HUD state
  }
})

                  .catch((error) =>
                    console.error("‚ùå Door exit error:", error)
                  );

                setTimeout(() => setQPressed(false), 1000);
              });
            }, 700);
            return;
          }

          if (roomId === "1") setDoorOpened(true);
          else if (roomId === "2") setDoor2Opened(true);
          else if (roomId === "3") setDoor3Opened(true);
          else if (roomId === "4") setDoor4Opened(true);
          else if (roomId === "5") setDoor5Opened(true);
          else if (roomId === "6") setDoor6Opened(true);
          else setDoor7Opened(true);

          // choose door id for exit (1‚Üí1/2, 2‚Üí3/4, 3‚Üí5/6, 4‚Üí7)
          const here = isAtDoorPosition();
          let doorIdForExit: string = roomId;

          if (roomId === "1") {
            if (here.atDoor1) doorIdForExit = "1";
            else if (here.atDoor2) doorIdForExit = "2";
            else doorIdForExit = "1";
          } else if (roomId === "2") {
            if (here.atDoor3) doorIdForExit = "3";
            else if (here.atDoor4) doorIdForExit = "4";
            else doorIdForExit = "3";
          } else if (roomId === "3") {
            if (here.atDoor5) doorIdForExit = "5";
            else if (here.atDoor6) doorIdForExit = "6";
            else doorIdForExit = "5";
          } else if (roomId === "4") {
            doorIdForExit = "7"; // only one door
          } else if (roomId === "5") {
            if (here.atDoor8) doorIdForExit = "8";
            else if (here.atDoor9) doorIdForExit = "9";
            else doorIdForExit = "8";
          } else if (roomId === "6") {
            if (here.atDoor10) doorIdForExit = "10";
            else if (here.atDoor11) doorIdForExit = "11";
            else doorIdForExit = "10";
          } else if (roomId === "7") {
            if (here.atDoor12) doorIdForExit = "12";
            else if (here.atDoor13) doorIdForExit = "13";
            else doorIdForExit = "12";
          }

          setExitPanelEnabled(false);

          exitDoor(doorIdForExit)
          .then((res) => {
  if (res?.success) {
    setCanEndGame(true); // re-enable "B" after exit confirms
    refreshRoomAfterExit(roomId); // keep your poller
  }
})

            .catch((error) => console.error("‚ùå Door exit error:", error));

          setTimeout(() => setQPressed(false), 1000);
        });
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [
    isLoading,
    enterDoor,
    exitDoor,
    attackEntity,
    collectShard,
    isAtDoorPosition,
    getActiveRoomId,
    resolveRoomId,
    room1ShardCollected,
    room2ShardCollected,
    room3ShardCollected,
    room4ShardCollected, // add
    room5ShardCollected, // add
    room6ShardCollected, // add
    room7ShardCollected, // add
    playerPosition,
    shootPanelEnabled,
    shardPanelEnabled,
    exitPanelEnabled,
    refetchGameData,
    exitPanelEnabled,
    refetchGameData,
    aimingAtEntity,
    canEndGame,
    
  ]);

  // Keep BOTH rooms' doors open for the entire session once opened via Q.
  // I WILL CHANGE THIS LATER TO CLOSE ONCE ENTERED
  useEffect(() => {
    // Intentionally no-op (no auto-close)
  }, [playerPosition, isAtDoorPosition, doorOpened, door2Opened]);
  // After exiting a room, poll a few times so HUD (Current Room) updates
  const refreshRoomAfterExit = useCallback(
    async (prevRoomId: string) => {
      for (let i = 0; i < 6; i++) {
        await new Promise((r) => setTimeout(r, 500));
        await refetchGameData();
        const st = useAppStore.getState();
        const cr =
          st.currentRoom?.toString?.() ??
          st.player?.current_room?.toString?.() ??
          "";
        if (cr && cr !== prevRoomId) break; // room changed -> stop polling
      }
    },
    [refetchGameData]
  );

  // Pass-through to store
  const handlePositionUpdate = useCallback(
    (position: Vector3): void => {
      updatePosition(position);
    },
    [updatePosition]
  );
  const handleRotationUpdate = useCallback(
    (rotation: number): void => {
      updateRotation(rotation);
    },
    [updateRotation]
  );

  // DO NOT CHANGE
  // Handle a successful left-click hit on ghost 1 or 2
  const handleGhostShot = useCallback(
    (which: 1 | 2, hit: THREE.Intersection) => {
      // Small on-screen pulse (reuses your existing prompt system)
      setShowShootPrompt(true);
      setPromptKey((k) => k + 1);
      setTimeout(() => setShowShootPrompt(false), 350);

      if (which === 1) {
        setGhost1Hits((h) => {
          const n = h + 1;
          if (n >= 3) setGhost1Dead(true);
          return n;
        });
      } else {
        setGhost2Hits((h) => {
          const n = h + 1;
          if (n >= 3) setGhost2Dead(true);
          return n;
        });
      }
// DO NOT CHANGE
      // Optional: add a little blood puff at the hit point
      if (hit?.point) {
        const bloodId = Date.now() + Math.random();
        setBloodEffects((prev) => [
          ...prev,
          { id: bloodId, position: hit.point.clone() },
        ]);
        setTimeout(() => {
          setBloodEffects((prev) => prev.filter((b) => b.id !== bloodId));
        }, 600);
      }
    },
    [setBloodEffects]
  );
// DO NOT CHANGE
  // Gun hit handling (unchanged)
   const handleGunShoot = useCallback(
    
    async (hit: THREE.Intersection, cameraPosition: Vector3): Promise<void> => {




      const hitObject = hit.object;
      const hitPoint = hit.point;
      const hitNormal = hit.face?.normal;

      // VFX (unchanged)// DO NOT CHANGE
      if (hitObject.userData?.isEntity) {
        const bloodId = Date.now() + Math.random();
        setBloodEffects((prev: BloodEffectType[]) => [
          ...prev,
          { id: bloodId, position: hitPoint.clone() },
        ]);
        setTimeout(() => {
          setBloodEffects((prev) => prev.filter((b) => b.id !== bloodId));
        }, 600);
      } else if (hitNormal) {
        const holeId = Date.now() + Math.random();
        const offsetPosition = hitPoint
          .clone()
          .add(hitNormal.clone().multiplyScalar(0.01));
        setBulletHoles((prev: BulletHoleType[]) => [
          ...prev,
          {
            id: holeId,
            position: offsetPosition,
            normal: hitNormal.clone(),
            cameraPosition: cameraPosition.clone(),
          },
        ]);
      }

    // ‚úÖ Count as a transaction ONLY if:
      // 1) the shot actually hit an entity (flag may be on a parent),
      // 2) the active weapon is the SHOTGUN, and
      // 3) the shoot panel is currently enabled (inside a room with a target).



      // HERE THE MF ENTITY DIES AND I DID SOME FUCKERY HERE TOO
      let o: THREE.Object3D | null = hitObject;
      let entityCarrier: THREE.Object3D | null = null;
      while (o) {
        if ((o as any).userData && (o as any).userData.isEntity) {
          entityCarrier = o;
          break;
        }
        o = o.parent as THREE.Object3D | null;
      }
      if (!entityCarrier) return;
      if (activeWeapon !== "shotgun") return;
      if (!shootPanelEnabled) return;

      const store = useAppStore.getState()
      const targetRoomId = resolveRoomId();

      // Find alive target in the current room
      const targets = store.entities.filter(
        (e) => e.is_alive && e.room_id.toString() === targetRoomId
      );
      if (targets.length === 0) return;

      const entityId = targets[0].entity_id.toString();

      try {
        const result = await attackEntity(entityId);
        if (result?.success) {
          // Re-check a moment later and hide the cube / enable shard UI
          setTimeout(() => {
            const updated = useAppStore
              .getState()
              .entities.filter((e) => e.room_id.toString() === targetRoomId);

            const dead =
              updated.length === 0 ||
              !updated[0].is_alive ||
              Number(updated[0].health) <= 0;

            if (dead) {
              if (targetRoomId === "1") setEntityCubeVisible(false);
              else if (targetRoomId === "2") setEntityCube2Visible(false);
              else if (targetRoomId === "3") setEntityCube3Visible(false);
              else if (targetRoomId === "4") setEntityCube4Visible(false);
              else if (targetRoomId === "5") setEntityCube5Visible(false);
              else if (targetRoomId === "6") setEntityCube6Visible(false);
              else if (targetRoomId === "7") setEntityCube7Visible(false);

              setShootPanelEnabled(false);

              const shardAlready =
                targetRoomId === "1" ? room1ShardCollected
                : targetRoomId === "2" ? room2ShardCollected
                : targetRoomId === "3" ? room3ShardCollected
                : targetRoomId === "4" ? room4ShardCollected
                : targetRoomId === "5" ? room5ShardCollected
                : targetRoomId === "6" ? room6ShardCollected
                : room7ShardCollected;

              if (!shardAlready) setShardPanelEnabled(true);
            }
          }, 1000);

          // Pull fresh room state
          setTimeout(() => refetchGameData(), 600);
        } else {
          console.error("‚ùå Failed to attack entity:", result?.error);
        }
      } catch (err) {
        console.error("‚ùå attack entity error:", err);
      }
    },
    [
      activeWeapon,
      attackEntity,
      resolveRoomId,
      shootPanelEnabled,
      refetchGameData,
      room1ShardCollected,
      room2ShardCollected,
      room3ShardCollected,
      room4ShardCollected,
      room5ShardCollected,
      room6ShardCollected,
      room7ShardCollected,
    ]
  );

  // Remove effects helpers
  // DO NOT CHANGE
  const removeBloodEffect = useCallback((id: number): void => {
    setBloodEffects((prev) => prev.filter((b) => b.id !== id));
  }, []);
  const removeBulletHole = useCallback((id: number): void => {
    setBulletHoles((prev) => prev.filter((h) => h.id !== id));
  }, []);

  // Render gate
  // FUCKERY MAYBE
  const isConnected = connectionStatus === "connected";
  const hasPlayer = player !== null;
  const isGameActive = gamePhase === GamePhase.ACTIVE;
  const shouldShowGame =
    isConnected && hasPlayer && isGameActive && gameStarted;
  // When the game becomes visible, try to start the music flow.
  // When leaving the game (back to menu/unmount), stop music.
  useEffect(() => {
    if (shouldShowGame) {
      // Canvas may mark map ready later; we also call maybeStartMusic from onCreated.
      // If Canvas was already ready, this call will start the 10s timer immediately.
      maybeStartMusic();
      setGhostsPreloaded(true); // ‚úÖ mark ghosts ready to spawn during loading

    } else {
      // back to menu
      stopMusic();
    }
  }, [shouldShowGame]);

  if (!shouldShowGame) return <MainMenu />;

  const activeRoomId = getActiveRoomId();

  // For UI panels
  const doorCheck = isAtDoorPosition();

  return (
    <div style={{ width: "100vw", height: "100vh", position: "relative" }}>
      {/* Silent audio manager - no UI */}

      <AudioManager />

      {/* Player HUD */}
      <PlayerHUD />

      {/* Transaction Popup */}
      <TransactionPopup
        isVisible={showTransactionPopup}
        isLoading={isProcessingTransaction}
        error={transactionError}
        onClose={closeTransactionPopup}
      />


  {/* Door Entry Panel */}
<div
  style={{
    position: "fixed",
    bottom: "20px",
    left: "20px",
    zIndex: 3000,
    backgroundColor: ePressed ? "rgba(255, 255, 255, 0.9)" : "rgba(0, 0, 0, 0.9)",
    border: `2px solid ${doorCheck.atAnyDoor ? "#E1CF48" : "#666"}`,
    borderRadius: "8px",
    padding: "20px",
    color: ePressed ? "black" : "white",
    fontFamily: "monospace",
    minWidth: "300px",
    textAlign: "center",
    opacity: doorCheck.atAnyDoor ? 1 : 0.5,
  }}
>
  <div
    style={{
      fontSize: "18px",
      fontWeight: "bold",
      color: doorCheck.atAnyDoor
        ? (ePressed ? "black" : "#E1CF48")
        : (ePressed ? "black" : "#666"),
    }}
  >
    Press E to Open Door
  </div>
</div>


      {/* Shooting Panel */}
      
      <div
        style={{
          position: "fixed",
          bottom: "20px",
          right: "20px",
          zIndex: 3000,
          backgroundColor: fPressed
            ? "rgba(255, 255, 255, 0.9)"
            : "rgba(0, 0, 0, 0.9)",
          border: shootPanelEnabled ? "2px solid #ff4444" : "2px solid #555",
          borderRadius: "8px",
          padding: "20px",
          color: fPressed ? "black" : "white",
          fontFamily: "monospace",
          minWidth: "300px",
          textAlign: "center",
          opacity: shootPanelEnabled ? 1 : 0.45,
          pointerEvents: "none", // purely visual panel; avoid accidental hovers/clicks
        }}
      >
        <div style={{ fontSize: "18px", fontWeight: "bold" }}>
          {activeWeapon === "shotgun"
            ? "Left-click to Shoot Enemy (shotgun)"
            : "Switch to Shotgun (2) to damage enemy"}
        </div>

        {doorCheck.atAnyDoor && (
          <div style={{ marginTop: "8px", fontSize: "14px", color: "#ff6666" }}>
            {(doorCheck.atDoor1 || doorCheck.atDoor2) && "Targeting Room 1"}
            {(doorCheck.atDoor3 || doorCheck.atDoor4) && "Targeting Room 2"}
            {(doorCheck.atDoor5 || doorCheck.atDoor6) && "Targeting Room 3"}
            {doorCheck.atDoor7 && "Targeting Room 4"}
            {(doorCheck.atDoor8 || doorCheck.atDoor9) && "Targeting Room 5"}
            {(doorCheck.atDoor10 || doorCheck.atDoor11) && "Targeting Room 6"}
            {(doorCheck.atDoor12 || doorCheck.atDoor13) && "Targeting Room 7"}
          </div>
        )}
      </div>

      {/* Centered reload spinner */}
      {isReloadingHud && (
        <>
          {/* spinner keyframes once */}
          <style>{`
      @keyframes hud-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    `}</style>

          <div></div>
        </>
      )}

      {/* Shard Panel */}
      <div
        style={{
          position: "fixed",
          bottom: "120px",
          right: "20px",
          zIndex: 3000,
          backgroundColor: xPressed
            ? "rgba(255, 255, 255, 0.9)"
            : "rgba(0, 0, 0, 0.9)",
          border: shardPanelEnabled ? "2px solid #44ff44" : "2px solid #555",
          borderRadius: "8px",
          padding: "20px",
          color: xPressed ? "black" : "white",
          fontFamily: "monospace",
          minWidth: "300px",
          textAlign: "center",
          opacity: shardPanelEnabled ? 1 : 0.45,
          pointerEvents: "none", 
        }}
      >
        <div style={{ fontSize: "18px", fontWeight: "bold" }}>
          Press X to Collect Shard
        </div>
        {doorCheck.atAnyDoor && (
          <div style={{ marginTop: "8px", fontSize: "14px", color: "#66ff66" }}>
            {(doorCheck.atDoor1 || doorCheck.atDoor2) && "Targeting Room 1"}
            {(doorCheck.atDoor3 || doorCheck.atDoor4) && "Targeting Room 2"}
          </div>
        )}
      </div>
  {
  <div
    style={{
      position: "fixed",
      bottom: "320px",
      right: "20px",
      zIndex: 3000,
      backgroundColor: bPressed
        ? "rgba(255, 255, 255, 0.9)"
        : "rgba(0, 0, 0, 0.9)",
      border: canEndGame ? "2px solid #44ff44" : "2px solid #555",
      borderRadius: "8px",
      padding: "20px",
      color: bPressed ? "black" : "white",
      fontFamily: "monospace",
      minWidth: "300px",
      textAlign: "center",
      opacity: canEndGame ? 1 : 0.45,
      pointerEvents: "none", // visual panel only
    }}
  >
    {/* First equip panel (only near 399,392 until picked) */}
    {isNearFirstPickup && (
      <div
        style={{
          position: "fixed",
          bottom: "420px",
          right: "20px",
          zIndex: 3000,
          backgroundColor: "rgba(0, 0, 0, 0.9)",
          border: "2px solid #4488ff",
          borderRadius: "8px",
          padding: "20px",
          color: "white",
          fontFamily: "monospace",
          minWidth: "300px",
          textAlign: "center",
          pointerEvents: "none",
        }}
      >
        <div style={{ fontSize: "18px", fontWeight: "bold" }}>
          Press T to Pick Up Gun
        </div>
        <div style={{ fontSize: "12px", opacity: 0.7, marginTop: 6 }}>
          (Stand near X:{FIRST_PICKUP.x}, Z:{FIRST_PICKUP.z})
        </div>
      </div>
    )}

    {/* Ammo pickups panel (only near an untaken ammo pickup) */}
    {!isNearFirstPickup && activePickup && (
      <div
        style={{
          position: "fixed",
          bottom: "420px",
          right: "20px",
          zIndex: 3000,
          backgroundColor: "rgba(0, 0, 0, 0.9)",
          border: "2px solid #4488ff",
          borderRadius: "8px",
          padding: "20px",
          color: "white",
          fontFamily: "monospace",
          minWidth: "300px",
          textAlign: "center",
          pointerEvents: "none",
        }}
      >
        <div style={{ fontSize: "18px", fontWeight: "bold" }}>
          Press T to Collect Ammo (+10)
        </div>
        <div style={{ fontSize: "12px", opacity: 0.7, marginTop: 6 }}>
          (Stand near X:{activePickup.x}, Z:{activePickup.z})
        </div>
      </div>
    )}

    <div style={{ fontSize: "18px", fontWeight: "bold" }}>
      {canEndGame ? "Press B to End Game" : "End Game disabled while inside room"}
    </div>
  </div>
}


      {/* Exit Panel */}
      <div
        style={{
          position: "fixed",
          bottom: "220px",
          right: "20px",
          zIndex: 3000,
          backgroundColor: qPressed
            ? "rgba(255, 255, 255, 0.9)"
            : "rgba(0, 0, 0, 0.9)",
          border: exitPanelEnabled ? "2px solid #ff8844" : "2px solid #555",
          borderRadius: "8px",
          padding: "20px",
          color: qPressed ? "black" : "white",
          fontFamily: "monospace",
          minWidth: "300px",
          textAlign: "center",
          opacity: exitPanelEnabled ? 1 : 0.45,
          pointerEvents: "none", // purely visual panel
        }}
      >
        <div style={{ fontSize: "18px", fontWeight: "bold" }}>
          Press Q to Exit Game
        </div>
        {doorCheck.atAnyDoor && (
          <div style={{ marginTop: "8px", fontSize: "14px", color: "#ff8866" }}>
            {(doorCheck.atDoor1 || doorCheck.atDoor2) && "Exiting Room 1"}
            {(doorCheck.atDoor3 || doorCheck.atDoor4) && "Exiting Room 2"}
            {(doorCheck.atDoor5 || doorCheck.atDoor6) && "Exiting Room 3"}
            {(doorCheck.atDoor8 || doorCheck.atDoor9) && "Exiting Room 5"}
            {(doorCheck.atDoor10 || doorCheck.atDoor11) && "Exiting Room 6"}
            {(doorCheck.atDoor12 || doorCheck.atDoor13) && "Exiting Room 7"}
          </div>
        )}
      </div>

      {/* On-screen prompts */}
      {showShootPrompt && (
        <div
          key={promptKey}
          style={{
            position: "fixed",
            top: "16px",
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 5000,
            backgroundColor: "rgba(255, 68, 68, 0.9)",
            border: "2px solid #ff6666",
            borderRadius: "8px",
            padding: "15px 25px",
            color: "white",
            fontFamily: "monospace",
            fontSize: "18px",
            fontWeight: "bold",
            textAlign: "center",
            animation: "fadeOut 1s ease-out forwards",
            boxShadow: "0 4px 12px rgba(255, 68, 68, 0.4)",
          }}
        >
          ENEMY SHOT!
        </div>
      )}
      {showShardPrompt && (
        <div
          key={shardPromptKey}
          style={{
            position: "fixed",
            top: "16px",
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 5000,
            backgroundColor: "rgba(68, 255, 68, 0.9)",
            border: "2px solid #66ff66",
            borderRadius: "8px",
            padding: "15px 25px",
            color: "white",
            fontFamily: "monospace",
            fontSize: "18px",
            fontWeight: "bold",
            textAlign: "center",
            animation: "fadeOut 1s ease-out forwards",
            boxShadow: "0 4px 12px rgba(68, 255, 68, 0.4)",
          }}
        >
          SHARD COLLECTED!
        </div>
      )}

      <style>{`
        @keyframes fadeOut {
          0% { opacity: 1; transform: translateX(-50%) translateY(0px); }
          70% { opacity: 1; transform: translateX(-50%) translateY(-5px); }
          100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
      `}</style>

      {/* New lightweight UI overlays (purely visual) */}
      <BlockroomsCard />
      <HUD />
      <GrainVignetteOverlay
        intensity={0.14}
        fps={24}
        tint="rgba(8,6,6,0.22)"
        vignette={0.7}
      />
      <DarknessMask radiusPct={0.36} feather={220} darkness={0.96} />

      {/* Crosshair */}
      {showCrosshair && <Crosshair />}

      {/* Map Tracker (optional) */}
      {/* {showMapTracker && (
        <MapTracker
          playerPosition={playerPosition}
          playerRotation={playerRotation}
          mapScale={30}
          size={250}
        />
      )} */}

      <Canvas
       // ‚úÖ exact 720p buffer + max perf hints
  dpr={1}
  gl={{
    powerPreference: "high-performance", // ask for discrete GPU when available
    antialias: false,        // cheaper (turn on if you really want smoother edges)
    alpha: false,            // opaque canvas = faster
    depth: true,
    stencil: false,
    preserveDrawingBuffer: false, // better perf (unless you need to read pixels / screenshots)
  }}
  frameloop="always"         // keep rendering (don‚Äôt auto-throttle)
  shadows                    // keep if you use shadows; remove for extra perf

  camera={{
  fov: 60,
  position: [400, 1.5, 400],
  near: 0.2,
  far: 1000,
}}

        onCreated={({ camera }) => {
          camera.rotation.set(0, 0, 0);
          camera.lookAt(400, 1.5, 399);
          (window as any).__R3F_CAMERA = camera; // let DarknessMask project lights

             // üîä mark map ready & possibly start 10s countdown
          mapReadyRef.current = true;
          maybeStartMusic();
        }}
      >
        {/* Lighting */}
        <Force720pHighPerf />

        <ambientLight intensity={0.2} color="#fff8dc" />
        <LightProximity reach={18} minA={0.06} maxA={0.96} />
        <ExposeCamera />
        <AutoLightHoles />

        <Flashlight />
        <GhostClickShooter
          ghost1Ref={ghost1Ref}
          ghost2Ref={ghost2Ref}
          enabled={true}
          onGhostShot={handleGhostShot}
        />

        <directionalLight
          position={[420, 20, 420]}
          intensity={0.8}
          color="#fff8dc"
          castShadow
        shadow-mapSize-width={1024}

shadow-mapSize-height={2048}

          shadow-camera-far={100}
          shadow-camera-left={-50}
          shadow-camera-right={50}
          shadow-camera-top={50}
          shadow-camera-bottom={-50}
        />
        <directionalLight
          position={[380, 15, 380]}
          intensity={0.4}
          color="#f4e4bc"
        />
        <pointLight
          position={[400, 10, 400]}
          intensity={0.5}
          color="#fff8dc"
          distance={100}
        />

        <FloorGrid minorStep={1} highlightStep={20} y={0.01} />
        {/* <Pop
          ref={popRef}

        /> */}
        {/* GHOST 1 */}
        {ghost1Spawned && !ghost1Dead && (
          <group ref={ghost1Ref} userData={{ isGhost: true, ghostId: 1 }}>
            <GhostPatrol
              y={1.2}
              loops={4}
              speed={2.5}
              yawOffset={-1}
              scale={1.5} // ‚¨ÖÔ∏è was 1
              // collideRadius={2.7}  // ‚¨ÖÔ∏è optional: 1.5 √ó 1.8 to keep spacing
            />
          </group>
        )}

        {/* GHOST 2 */}
        {ghost2Spawned && !ghost2Dead && (
          <group ref={ghost2Ref} userData={{ isGhost: true, ghostId: 2 }}>
            <GhostPatrol2
              y={0.9}
              loops={4}
              speed={2.5}
              yawOffset={-1}
              scale={1.5}
              // collideRadius={2.7}
            />
          </group>
        )}

        {/* GHOST 3 */}
        {ghost3Spawned && !ghost3Dead && (
          <group ref={ghost3Ref} userData={{ isGhost: true, ghostId: 3 }}>
            <GhostPatrol3
              y={0.9}
              loops={4}
              speed={2.5}
              yawOffset={-1}
              scale={1.5}
              // collideRadius={2.7}
            />
          </group>
        )}

        {/* GHOST 4 */}
        {ghost4Spawned && !ghost4Dead && (
          <group ref={ghost4Ref} userData={{ isGhost: true, ghostId: 4 }}>
            <GhostPatrol4
              y={0.9}
              speed={2.5}
              yawOffset={-1}
              scale={1.5}
              // collideRadius={2.7}
              onVanish={() => setGhost4Dead(true)}
            />
          </group>
        )}

        {/* GHOST 5 ‚Äî spawns at game start, vanishes 5s after first seen */}
        {!ghost5Dead && (
          <group ref={ghost5Ref} userData={{ isGhost: true, ghostId: 5 }}>
            <GhostPatrol5
              y={0.9}
              speed={2.0}
              yawOffset={-1}
              scale={2} // change if you want bigger/smaller
              onVanish={() => setGhost5Dead(true)}
            />
          </group>
        )}

        {/* GHOST 6 ‚Äî spawns at game start, vanishes 5s after first seen */}
        {!ghost6Dead && (
          <group ref={ghost6Ref} userData={{ isGhost: true, ghostId: 6 }}>
            <GhostPatrol6
              y={0.9}
              speed={2.0}
              yawOffset={-1}
              scale={2} // change if you want bigger/smaller
              onVanish={() => setGhost6Dead(true)}
            />
          </group>
        )}


                {/* GHOST 7 */}
        {ghost7Spawned && !ghost7Dead && (
          <group ref={ghost7Ref} userData={{ isGhost: true, ghostId: 7 }}>
            <GhostPatrol7
              y={0.9}
              speed={2.5}
              yawOffset={-1}
              scale={1.5}
              // collideRadius={2.7}
              onVanish={() => setGhost7Dead(true)}
            />
          </group>
        )}

        {/* Room 1 Doors */}
        <DoorWall
          position={[372, 0, 306.5]}
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={doorOpened}
        />
        <DoorWall
          position={[384.5, 0, 326]}
          rotation={[0, 0, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={doorOpened}
        />

        {/* Room 2 Doors */}
        <DoorWall
          position={[355, 0, 293.5]}
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door2Opened}
        />
        <DoorWall
          position={[338, 0, 293]}
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door2Opened}
        />

        {/* Room 3 Doors */}
        <DoorWall
          position={[368, 0, 400]} // center of Door 5 range
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door3Opened}
        />
        <DoorWall
          position={[363.5, 0, 368.5]} // center of Door 6 range
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door3Opened}
        />
        {/* Room 4 Door */}
        <DoorWall
          position={[323.5, 0, 358.5]} // center of Door 7 range
          rotation={[0, 0, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door4Opened}
        />
        {/* Room 5 Doors */}
        <DoorWall
          position={[303.5, 0, 349.5]}
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door5Opened}
        />
        <DoorWall
          position={[288.5, 0, 377.5]}
          rotation={[0, 0, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door5Opened}
        />

        {/* Room 6 Doors */}
        <DoorWall
          position={[279, 0, 347.5]} // center of Door 10 range
          rotation={[0, 0, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door6Opened}
        />
        <DoorWall
          position={[269.5, 0, 320.5]} // center of Door 11 range
          rotation={[0, Math.PI / 2, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door6Opened}
        />

        {/* Room 7 Doors */}
        <DoorWall
          position={[276, 0, 281.5]} // center of Door 12 range
          rotation={[0, 0, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door7Opened}
        />
        <DoorWall
          position={[276, 0, 311.5]} // center of Door 13 range
          rotation={[0, 0, 0]}
          doorOpening={[0, 1, 0.5]}
          doorOpened={door7Opened}
        />

        <AimProbe onUpdate={setAimingAtEntity} />

        {/* Pointer lock */}
        <PointerLockControls />

        {/* Controls */}
        <FirstPersonControls
          onPositionUpdate={handlePositionUpdate}
          onRotationUpdate={handleRotationUpdate}
        />

        {/* Level */}
        <Model />
        {/* Gun pickup placeholders (remove if you swap for real models) */}
        {!pickupTaken.P1 && (
          <mesh position={[350, 0.2, 392]}>
            <boxGeometry args={[0.4, 0.2, 1.0]} />
            <meshStandardMaterial
              color="#222"
              emissive="#4aa8ff"
              emissiveIntensity={0.6}
              toneMapped={false}
            />
          </mesh>
        )}
        {!pickupTaken.P2 && (
          <mesh position={[369, 0.2, 277]}>
            <boxGeometry args={[0.4, 0.2, 1.0]} />
            <meshStandardMaterial
              color="#222"
              emissive="#4aa8ff"
              emissiveIntensity={0.6}
              toneMapped={false}
            />
          </mesh>
        )}
        {!pickupTaken.P3 && (
          <mesh position={[338, 0.2, 322]}>
            <boxGeometry args={[0.4, 0.2, 1.0]} />
            <meshStandardMaterial
              color="#222"
              emissive="#4aa8ff"
              emissiveIntensity={0.6}
              toneMapped={false}
            />
          </mesh>
        )}

{!firstPickupTaken && (
  <>
    <Table position={[392, 0, 392]} />
    {/* Shotgun on top of the table; tweak Y if it clips or floats */}
    <group position={[392, 0, 392]}>
      <Shotgun
        position={[5.7, 1.1, -0.4 ]}         // height above table surface
        rotation={[0, - Math.PI / 4, -1.5]} // face it sideways for style
        scale={0.65}                   // adjust to your table size
      />
    </group>
  </>
)}

        {/* <Ghost position={[391, 0, 399]} /> */}

{/* Weapons */}
{showGun && (
  activeWeapon === "pistol" ? (
    <Gun key="pistol" isVisible={showGun} onShoot={handleGunShoot} />
  ) : (
    <ShotgunShoot key="shotgun" isVisible={showGun} onShoot={handleGunShoot} />
  )
)}


        {/* Blood effects */}
        {bloodEffects.map((effect: BloodEffectType) => (
          <BloodEffect
            key={effect.id}
            position={effect.position}
            onComplete={() => removeBloodEffect(effect.id)}
          />
        ))}

        {/* Bullet holes */}
        {/* {bulletHoles.map((hole: BulletHoleType[]) => null) /* silence TS types in map below */}
        {/* {bulletHoles.map((hole: any) => (
          <BulletHole
            key={hole.id}
            position={hole.position}
            normal={hole.normal}
            cameraPosition={hole.cameraPosition}
            onComplete={() => removeBulletHole(hole.id)}
          />
        ))} */}

        {/* Room 1 Entity Cube */}
        <EntityCube
          position={cubePosition}
          isVisible={entityCubeVisible}
          onSpawn={() => console.log("üéØ Room 1 Entity cube spawned!")}
          entityId="door_entity_1"
        />

        <ShardCluster
          position={[cubePosition[0], 1.6, cubePosition[2]]}
          visible={
            shardPanelEnabled && !room1ShardCollected && resolveRoomId() === "1"
          }
        />

        {/* Room 2 Entity Cube */}
        <EntityCube
          position={cube2Position}
          isVisible={entityCube2Visible}
          onSpawn={() => console.log("üéØ Room 2 Entity cube spawned!")}
          entityId="door_entity_2"
        />

        <ShardCluster
          position={[cube2Position[0], 1.6, cube2Position[2]]}
          visible={
            shardPanelEnabled && !room2ShardCollected && resolveRoomId() === "2"
          }
        />

        {/* Room 3 Entity Cube */}
        <EntityCube
          position={cube3Position}
          isVisible={entityCube3Visible}
          onSpawn={() => console.log("üéØ Room 3 Entity cube spawned!")}
          entityId="door_entity_3"
        />

        <ShardCluster
          position={[cube3Position[0], 1.6, cube3Position[2]]}
          visible={
            shardPanelEnabled && !room3ShardCollected && resolveRoomId() === "3"
          }
        />

        {/* Room 4 Entity Cube */}
        <EntityCube
          position={cube4Position}
          isVisible={entityCube4Visible}
          onSpawn={() => console.log("üéØ Room 4 Entity cube spawned!")}
          entityId="door_entity_4"
        />

        <ShardCluster
          position={[cube4Position[0], 1.6, cube4Position[2]]}
          visible={
            shardPanelEnabled && !room4ShardCollected && resolveRoomId() === "4"
          }
        />

        {/* Room 5 Entity Cube */}
        <EntityCube
          position={cube5Position}
          isVisible={entityCube5Visible}
          onSpawn={() => console.log("üéØ Room 5 Entity cube spawned!")}
          entityId="door_entity_5"
        />

        <ShardCluster
          position={[cube5Position[0], 1.6, cube5Position[2]]}
          visible={
            shardPanelEnabled && !room5ShardCollected && resolveRoomId() === "5"
          }
        />

        {/* Room 6 Entity Cube */}
        <EntityCube
          position={cube6Position}
          isVisible={entityCube6Visible}
          onSpawn={() => console.log("üéØ Room 6 Entity cube spawned!")}
          entityId="door_entity_6"
        />
        <ShardCluster
          position={[cube6Position[0], 1.6, cube6Position[2]]}
          visible={
            shardPanelEnabled && !room6ShardCollected && resolveRoomId() === "6"
          }
        />

        {/* Room 7 Entity Cube */}
        <EntityCube
          position={cube7Position}
          isVisible={entityCube7Visible}
          onSpawn={() => console.log("üéØ Room 7 Entity cube spawned!")}
          entityId="door_entity_7"
        />

        <ShardCluster
          position={[cube7Position[0], 1.6, cube7Position[2]]}
          visible={
            shardPanelEnabled && !room7ShardCollected && resolveRoomId() === "7"
          }
        />
      </Canvas>
    </div>
  );
};

export default App;
function playShotgunReload() {
  throw new Error("Function not implemented.");
}
</file>

<file path="src/components/game/BloodEffect.tsx">
import { useRef, useEffect, useState } from "react";
import * as THREE from "three";
import { BloodEffectProps } from "../../types/game";

export function BloodEffect({
  position,
  onComplete,
}: BloodEffectProps): JSX.Element {
  const bloodRef = useRef<THREE.Mesh>(null);
  const [opacity, setOpacity] = useState<number>(1);

  useEffect(() => {
    // Load blood texture
    const textureLoader = new THREE.TextureLoader();
    const bloodTexture = textureLoader.load("/blood.png");

    if (bloodRef.current) {
      (bloodRef.current.material as THREE.MeshBasicMaterial).map = bloodTexture;
      (bloodRef.current.material as THREE.MeshBasicMaterial).transparent = true;
      (bloodRef.current.material as THREE.MeshBasicMaterial).needsUpdate = true;
    }

    // Fade out blood effect over 3 seconds
    const fadeInterval = setInterval(() => {
      setOpacity((prev: number) => {
        const newOpacity = prev - 0.02;
        if (newOpacity <= 0) {
          clearInterval(fadeInterval);
          if (onComplete) onComplete();
          return 0;
        }
        return newOpacity;
      });
    }, 50);

    return () => clearInterval(fadeInterval);
  }, [onComplete]);

  useEffect(() => {
    if (bloodRef.current) {
      (bloodRef.current.material as THREE.MeshBasicMaterial).opacity = opacity;
    }
  }, [opacity]);

  return (
    <mesh ref={bloodRef} position={position}>
      <planeGeometry args={[0.7, 0.7]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}
</file>

<file path="src/components/game/BulletHole.tsx">
import { useRef, useEffect, useState } from "react";
import * as THREE from "three";
import { BulletHoleProps } from "../../types/game";

export function BulletHole({
  position,
  normal,
  cameraPosition,
  onComplete,
}: BulletHoleProps): JSX.Element {
  const holeRef = useRef<THREE.Mesh>(null);
  const [opacity, setOpacity] = useState<number>(1);

  useEffect(() => {
    // Load hole texture
    const textureLoader = new THREE.TextureLoader();
    const holeTexture = textureLoader.load("/hole.png");

    if (holeRef.current) {
      (holeRef.current.material as THREE.MeshBasicMaterial).map = holeTexture;
      (holeRef.current.material as THREE.MeshBasicMaterial).transparent = true;
      (holeRef.current.material as THREE.MeshBasicMaterial).needsUpdate = true;

      // Orient the hole to face towards the camera (player)
      holeRef.current.lookAt(cameraPosition);
    }

    // Remove bullet hole after 10 seconds
    const removeTimeout = setTimeout(() => {
      if (onComplete) onComplete();
    }, 10000);

    return () => clearTimeout(removeTimeout);
  }, [position, normal, cameraPosition, onComplete]);

  return (
    <mesh ref={holeRef} position={position}>
      <planeGeometry args={[0.5, 0.5]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}
</file>

<file path="src/components/game/EntityCube.tsx">
import React, { useEffect, useRef, useState } from "react";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import useAppStore from "../../zustand/store";
// GLTF model (Hound)
import { Model as Hound } from "../../models/Entity1";

interface EntityCubeProps {
  position: [number, number, number];
  isVisible: boolean;
  onSpawn?: () => void;
  entityId?: string;
  onShardCollected?: (pos: [number, number, number]) => void;
}

/** Small floating, spinning shard that glows */
const Shard: React.FC<{ position: [number, number, number] }> = ({ position }) => {
  const ref = useRef<THREE.Mesh>(null);
  useFrame((_, delta) => {
    if (!ref.current) return;
    ref.current.rotation.y += 0.7 * delta;
    const t = performance.now() * 0.002;
    ref.current.position.y = position[1] + 0.1 + Math.sin(t) * 0.04;
  });
  return (
    <mesh ref={ref} position={position}>
      <octahedronGeometry args={[0.2, 0]} />
      <meshStandardMaterial
        color="#66ccff"
        emissive="#66ccff"
        emissiveIntensity={1.5}
        roughness={0.2}
        metalness={0.1}
      />
      <pointLight position={[0, 0, 0]} intensity={1.2} distance={3} decay={2} />
    </mesh>
  );
};

// ---- BRIGHTNESS: boost all MeshStandardMaterials inside a loaded GLTF ----
function boostModelMaterials(root: THREE.Object3D) {
  root.traverse((obj) => {
    const mesh = obj as THREE.Mesh;
    const mat = (mesh as any)?.material;
    if (!mat) return;
    const apply = (m: any) => {
      if (m.isMeshStandardMaterial) {
        const ms = m as THREE.MeshStandardMaterial;
        // Gentle emissive so details show even in dark
        if (!ms.emissive) ms.emissive = new THREE.Color("#202020");
        ms.emissive = new THREE.Color("#202020");
        ms.emissiveIntensity = Math.max(0.5, ms.emissiveIntensity || 0.0);
        // Slightly stronger reflections if you have an envMap in the scene
        (ms as any).envMapIntensity = Math.max(1.2, (ms as any).envMapIntensity || 1.0);
        // Slight tweak to roughness helps catch light
        ms.roughness = Math.min(0.8, Math.max(0.2, ms.roughness ?? 0.6));
        ms.needsUpdate = true;
      }
    };
    if (Array.isArray(mat)) mat.forEach(apply);
    else apply(mat);
  });
}

export const EntityCube: React.FC<EntityCubeProps> = ({
  position,
  isVisible,
  onSpawn,
  entityId,
  onShardCollected,
}) => {
  // spawn animation
  const [spawned, setSpawned] = useState(false);
  const [scale, setScale] = useState(0.1);

  // live position for following
  const [cubePos, setCubePos] = useState<[number, number, number]>([
    position[0],
    1, // your current spawn Y
    position[2],
  ]);

  const [isFollowing, setIsFollowing] = useState(false);

  // shard state created on death
  const [shardPos, setShardPos] = useState<[number, number, number] | null>(null);
  const [hasSpawnedShard, setHasSpawnedShard] = useState(false);
  const prevVisibleRef = useRef<boolean>(false);

  // model wrapper (so we can rotate the whole body) + optional head bone
  const modelRef = useRef<THREE.Group>(null);
  const headBoneRef = useRef<THREE.Bone | null>(null);

  // keep latest shardPos in a ref for useFrame
  const shardPosRef = useRef<[number, number, number] | null>(null);
  useEffect(() => {
    shardPosRef.current = shardPos;
  }, [shardPos]);

  // reset on show
  useEffect(() => {
    if (isVisible) {
      setCubePos([position[0], 1, position[2]]);
      setSpawned(false);
      setIsFollowing(false);
      setScale(0.1);
      setHasSpawnedShard(false);
      setShardPos(null);

      // (re)discover head bone once model is in the scene + BRIGHTNESS material boost
      queueMicrotask(() => {
        if (!modelRef.current) return;

        // BRIGHTNESS: boost GLTF materials
        boostModelMaterials(modelRef.current);

        let found: THREE.Bone | null = null;
        modelRef.current.traverse((obj) => {
          const anyObj = obj as any;
          if (anyObj.isBone && /head|neck/i.test(obj.name)) {
            found = obj as THREE.Bone;
          }
        });
        headBoneRef.current = found;
      });
    }
  }, [isVisible, position]);

  // spawn animation ‚Üí wait 2s ‚Üí follow
  useEffect(() => {
    if (isVisible && !spawned) {
      setSpawned(true);

      const startScale = 0.1;
      const endScale = 1;
      const duration = 1000; // ms
      const startTime = Date.now();

      const animateScale = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeOutCubic = 1 - Math.pow(1 - progress, 3);
        const currentScale = startScale + (endScale - startScale) * easeOutCubic;
        setScale(currentScale);

        if (progress < 1) {
          requestAnimationFrame(animateScale);
        } else {
          onSpawn?.();
          const t = setTimeout(() => setIsFollowing(true), 2000);
          return () => clearTimeout(t);
        }
      };

      animateScale();
    }
  }, [isVisible, spawned, onSpawn]);

  // Follow logic + face-the-player + shard collection
  useFrame((_, delta) => {
    // live store read (avoids extra re-renders)
    const p = useAppStore.getState().position;

    // 1) Follow: keep exactly 2 units away on XZ plane
    if (isVisible && isFollowing) {
      setCubePos(([x, y, z]) => {
        const current = new THREE.Vector3(x, y, z);
        const player = new THREE.Vector3(p.x, y, p.z);

        const dir = player.clone().sub(current);
        let dist = dir.length();
        if (dist < 1e-4) {
          dir.set(1, 0, 0);
          dist = 1;
        }

        const n = dir.clone().divideScalar(dist);
        const stopDistance = 2.0;
        const desired = player.clone().addScaledVector(n, -stopDistance);

        const toDesired = desired.clone().sub(current);
        const remaining = toDesired.length();
        if (remaining < 1e-4) return [x, y, z];

        const speed = 2.0;
        const step = Math.min(remaining, speed * delta);
        const next = current.add(toDesired.normalize().multiplyScalar(step));
        return [next.x, next.y, next.z];
      });
    }

    // 2) Rotate body to face the player (yaw only)
    if (modelRef.current) {
      const me = new THREE.Vector3(cubePos[0], 0, cubePos[2]);
      const you = new THREE.Vector3(p.x, 0, p.z);
      const dir = you.sub(me);
      if (dir.lengthSq() > 1e-6) {
        const yaw = Math.atan2(dir.x, dir.z); // +Z forward ‚Üí rotate around Y
        modelRef.current.rotation.set(0, yaw, 0);
      }
    }

    // 3) Aim head bone toward the player (if found)
    const head = headBoneRef.current;
    if (head) {
      head.parent?.updateWorldMatrix(true, false);
      const headWorld = new THREE.Vector3();
      head.getWorldPosition(headWorld);
      const p = useAppStore.getState().position;
      const targetWorld = new THREE.Vector3(p.x, headWorld.y, p.z);
      const localTarget = head.parent ? head.parent.worldToLocal(targetWorld.clone()) : targetWorld;
      head.lookAt(localTarget);
      // Optional clamps:
      // const e = head.rotation;
      // e.x = THREE.MathUtils.clamp(e.x, -0.6, 0.6);
      // e.y = THREE.MathUtils.clamp(e.y, -0.8, 0.8);
    }

    // 4) Shard pickup
    const sp = shardPosRef.current;
    if (sp) {
      const playerXZ = new THREE.Vector3(p.x, 0, p.z);
      const shardXZ = new THREE.Vector3(sp[0], 0, sp[2]);
      const collectRadius = 1.25;
      if (playerXZ.distanceTo(shardXZ) <= collectRadius) {
        setShardPos(null);
        onShardCollected?.(sp);
      }
    }
  });

  // Detect death (visible -> not visible) and drop a shard near last position
  useEffect(() => {
    const prev = prevVisibleRef.current;

    if (prev && !isVisible && !hasSpawnedShard) {
      const [cx, cy, cz] = cubePos;
      const jitter = () => (Math.random() - 0.5) * 0.6; // ¬±0.3
      setShardPos([cx + jitter(), cy + 0.1, cz + jitter()]);
      setHasSpawnedShard(true);
    }

    prevVisibleRef.current = isVisible;
  }, [isVisible, cubePos, hasSpawnedShard]);

  // Don't early-return on invisibility; shard may need to render
  return (
    <group>
      {/* BRIGHTNESS: ambient + key/fill/rim */}
      {isVisible && (
        <>
          <ambientLight intensity={0.35} />
          {/* Key light slightly above-front */}
          <pointLight position={[0.6, 1.2, 0.8]} intensity={8} distance={8} decay={2} />
          {/* Fill light from the side */}
          <pointLight position={[-0.8, 0.8, 0.2]} intensity={3} distance={6} decay={2} />
          {/* Rim/back light to outline the silhouette */}
          <pointLight position={[0, 1.0, -1.2]} intensity={5} distance={8} decay={2} />
        </>
      )}

      {isVisible && (
        // Wrap model so we can rotate whole body & keep our own position/scale
        <group
          ref={modelRef}
          position={cubePos}
          scale={scale}
          userData={{ isEntity: true, entityId: entityId || "unknown" }}
        >
          <Hound />

          {/* Enlarged hitbox (raycast-only) */}
<mesh
  name="EntityHitbox"
  position={[0, 1.0, 0]}                 // center around chest/torso
  castShadow={false}
  receiveShadow={false}
>
  {/* pick one: box, sphere, or capsule */}
  <boxGeometry args={[1.4, 2.2, 1.4]} />  {/* width, height, depth in local units */}
  {/* <sphereGeometry args={[1.1, 16, 16]} /> */}
  {/* new THREE.CapsuleGeometry(0.8, 1.2, 4, 8)  // if your three version has it */}

  {/* Keep it ‚Äúvisible‚Äù for raycasting but not rendered */}
  <meshBasicMaterial transparent opacity={0} depthWrite={false} />
</mesh>

        </group>
      )}

      {shardPos && <Shard position={shardPos} />}
    </group>
  );
};
</file>

<file path="src/components/game/FloorGrid.tsx">
import { useMemo, useEffect } from 'react';
import * as THREE from 'three';

type Props = {
  minorStep?: number;     // spacing for faint grid, in world units
  highlightStep?: number; // yellow lines every N units
  size?: number;          // total grid width/height (centered at origin)
  y?: number;             // slight lift above the floor to prevent z-fighting
};

export default function FloorGrid({
  minorStep = 1,
  highlightStep = 20,
  size = 2000,
  y = 0.01,
}: Props) {
  // Minor grid (e.g., every 1 unit), faint green
  const minor = useMemo(() => {
    const divisions = Math.max(1, Math.round(size / minorStep));
    const g = new THREE.GridHelper(size, divisions, 0x00ff00, 0x00ff00);
    const mat = g.material as THREE.LineBasicMaterial;
    mat.transparent = true;
    mat.opacity = 0.15;
    // GridHelper is already on XZ (Y-up). No rotation needed.
    g.position.y = y;
    g.renderOrder = -1;
    return g;
  }, [size, minorStep, y]);

  // Major grid (highlight): every 20 units, yellow and more opaque
  const major = useMemo(() => {
    const divisions = Math.max(1, Math.round(size / highlightStep));
    const g = new THREE.GridHelper(size, divisions, 0xffff00, 0xffff00);
    const mat = g.material as THREE.LineBasicMaterial;
    mat.transparent = true;
    mat.opacity = 0.9;
    g.position.y = y + 0.001; // tiny offset above minor grid
    g.renderOrder = 0;
    return g;
  }, [size, highlightStep, y]);

  // Clean up on unmount
  useEffect(() => {
    return () => {
      minor.geometry.dispose();
      (minor.material as THREE.Material).dispose();
      major.geometry.dispose();
      (major.material as THREE.Material).dispose();
    };
  }, [minor, major]);

  return (
    <>
      <primitive object={minor} />
      {/* highlight lines */}
      <primitive object={major} />
    </>
  );
}
</file>

<file path="src/components/game/Gun.tsx">
// client/src/components/game/Gun.tsx
import { useRef, useEffect, useState } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import Pop, { PopHandle } from "../../models/Pop";
import { GunProps } from "../../types/game";
import useAppStore from "../../zustand/store";
import MuzzleFlash from "./MuzzleFlash";
import React from "react";



export function Gun({
  isVisible,           // optional (kept for compatibility)
  onShoot,
  canShoot = true,     // optional flag (UI-only gating)
}: GunProps): JSX.Element | null {
  const gunRef = useRef<THREE.Group>(null);
  const popRef = useRef<PopHandle | null>(null);
  const muzzleRef = useRef<THREE.Group>(null);
/** bump this to trigger a flash */
const [flashKick, setFlashKick] = React.useState(0);

  const { camera, scene } = useThree();

  // Get gun visibility from store
  const { showGun } = useAppStore();

  // Use store value, but allow prop override
  const shouldShow = isVisible !== undefined ? isVisible : showGun;

  // Play pickup/cock once when gun becomes visible
  const prevShowRef = useRef<boolean>(false);
  useEffect(() => {
    if (shouldShow && !prevShowRef.current) {
      popRef.current?.playPickup();
    }
    prevShowRef.current = shouldShow;
  }, [shouldShow]);

  // Timer to drive breathing motion
  const swayTime = useRef<number>(0);

  // Shooting and recoil state
  const [isRecoiling, setIsRecoiling] = useState<boolean>(false);
  const recoilTime = useRef<number>(0);
  const shootSound = useRef<HTMLAudioElement | null>(null);

  // --- Local ammo state (non-persistent) ---
  const MAG_SIZE = 6;
  const [ammoInMag,   setAmmoInMag]   = useState<number>(6);
  const [ammoReserve, setAmmoReserve] = useState<number>(10);

  // --- Reloading state (non-persistent) ---
  const [isReloading, setIsReloading] = useState(false);
  const reloadTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // keep reserve & mag in refs for event handler closures
  const ammoReserveRef = useRef(ammoReserve);
  useEffect(() => { ammoReserveRef.current = ammoReserve; }, [ammoReserve]);

  const ammoMagRef = useRef(ammoInMag);
  useEffect(() => { ammoMagRef.current = ammoInMag; }, [ammoInMag]);

  // Broadcast reloading status to UI
  useEffect(() => {
    window.dispatchEvent(new CustomEvent("hud:reloading", { detail: { reloading: isReloading } }));
  }, [isReloading]);

  // Cleanup any pending timer on unmount
  useEffect(() => {
    return () => { if (reloadTimerRef.current) clearTimeout(reloadTimerRef.current); };
  }, []);

  // Broadcast ammo to HUD (no persistence)
  useEffect(() => {
    window.dispatchEvent(
      new CustomEvent("hud:ammo", { detail: { mag: ammoInMag, reserve: ammoReserve } })
    );
  }, [ammoInMag, ammoReserve]);

  // Listen for external ammo awards (e.g., world pickups)
  useEffect(() => {
    const onAddAmmo = (e: Event) => {
      const ce = e as CustomEvent<{ amount?: number }>;
      const add = Math.max(0, Number(ce?.detail?.amount ?? 0));
      if (!add) return;
      setAmmoReserve((r) => r + add);
    };
    window.addEventListener("gun:addAmmo", onAddAmmo as EventListener);
    return () => window.removeEventListener("gun:addAmmo", onAddAmmo as EventListener);
  }, []);

  // Reload with explicit variant to pick the right animation
  const reload = (variant: "short" | "long" = "short"): void => {
    // guards (use refs to avoid stale reads from event handlers)
    if (isReloading) return;
    if (ammoMagRef.current >= MAG_SIZE) return;
    if (ammoReserveRef.current <= 0) return;

    setIsReloading(true);

    // Play the correct reload animation immediately
    if (variant === "short") {
      popRef.current?.playReloadShort();
    } else {
      popRef.current?.playReloadLong();
    }

    // 2s reload delay with mid-screen spinner
    reloadTimerRef.current = setTimeout(() => {
      setAmmoInMag((mPrev) => {
        // compute how many we can take
        const need = Math.max(0, MAG_SIZE - mPrev);
        const take = Math.min(need, ammoReserveRef.current);
        // apply both updates and keep refs in sync immediately
        setAmmoReserve((rPrev) => {
          const nextReserve = rPrev - take;
          ammoReserveRef.current = nextReserve;
          return nextReserve;
        });
        const nextMag = mPrev + take;
        ammoMagRef.current = nextMag;
        return nextMag;
      });
      setIsReloading(false);
    }, 2000);
  };

  // Press R to reload (short variant)
  // Listen on both window and document (PointerLock sometimes routes to document)
  useEffect(() => {
    const onKeyDown = (e: KeyboardEvent) => {
      const k = e.key?.toLowerCase?.();
      if (k === "r" || e.code === "KeyR") {
        e.preventDefault();
        reload("short"); // explicit: short/tactical reload
      }
    };
    window.addEventListener("keydown", onKeyDown, { passive: false });
    document.addEventListener("keydown", onKeyDown, { passive: false });
    return () => {
      window.removeEventListener("keydown", onKeyDown as EventListener);
      document.removeEventListener("keydown", onKeyDown as EventListener);
    };
  }, [isReloading]); // reload uses refs for ammo

  // Load sound and bind click
  // IMPORTANT: the handler does not make ammo/reload decisions ‚Äî shoot() does.
  useEffect(() => {
    const audio = new Audio("/audio/shot.mp3");
    audio.volume = 0.7;
    shootSound.current = audio;

    const handleMouseClick = (event: MouseEvent) => {
      if (event.button !== 0) return;
      if (!shouldShow || !canShoot) return;
      if (isReloading) return; // block during reload
      shoot();                 // single source of truth
    };

    document.addEventListener("mousedown", handleMouseClick);
    return () => {
      document.removeEventListener("mousedown", handleMouseClick);
      shootSound.current = null;
    };
  }, [shouldShow, canShoot, isReloading]);

  const shoot = (): void => {
    if (!canShoot || isRecoiling || isReloading) return;

    // If mag is empty, either trigger long reload (if reserve) or do nothing
    if (ammoMagRef.current <= 0) {
      if (ammoReserveRef.current > 0 && !isReloading) reload("long");
      return;
    }

    // We have bullets ‚Üí fire one
    setAmmoInMag((mPrev) => {
      const next = Math.max(0, mPrev - 1);
      ammoMagRef.current = next; // keep ref in sync immediately
      // if this shot empties the mag and we have reserve, auto long-reload
      if (next === 0 && ammoReserveRef.current > 0 && !isReloading) {
        reload("long");
      }
      return next;
    });

    // Sound only when a shot actually happened
    if (shootSound.current) {
      try {
        shootSound.current.currentTime = 0;
        shootSound.current.play();
      } catch (err) {
        console.log("Failed to play shoot sound:", err);
      }
    }

    // Kick the model's shoot animation
    popRef.current?.playShoot();

    // Raycast / hit detection (unchanged)
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    raycaster.set(camera.position, direction);
    const intersects = raycaster.intersectObjects(scene.children, true);
    const validIntersects = intersects.filter((intersect: THREE.Intersection) => {
      const object = intersect.object;
      return (
        !(object as THREE.Light).isLight &&
        !(object as THREE.Camera).isCamera &&
        !gunRef.current?.children.some(
          (child: THREE.Object3D) => child === object || child.children.includes(object)
        ) &&
        (object.userData?.isEntity ||
          ((object as THREE.Mesh).geometry && (object as THREE.Mesh).material)) &&
        object.visible
      );
    });
    // trigger muzzle flash for a frame or two
setFlashKick((n) => n + 1);

    if (validIntersects.length > 0 && onShoot) {
      const hit = validIntersects[0];
      onShoot(hit, camera.position);
    }

    // Recoil animation
    setIsRecoiling(true);
    recoilTime.current = 0;
    setTimeout(() => setIsRecoiling(false), 200);
  };

  useFrame((_, delta: number) => {
    if (!gunRef.current || !shouldShow) return;

    // Breathing sway
    swayTime.current += delta;
    const swayY = Math.sin(swayTime.current * 2) * 0.01;


    
    // Base position from camera
    const gunPosition = new THREE.Vector3();
    camera.getWorldPosition(gunPosition);

    const forward = new THREE.Vector3(0, 0, -1);
    const right = new THREE.Vector3(1, 0, 0);
    const down = new THREE.Vector3(0, -1, 0);

    forward.applyQuaternion(camera.quaternion);
    right.applyQuaternion(camera.quaternion);
    down.applyQuaternion(camera.quaternion);

    gunPosition.add(forward.multiplyScalar(0.5));
    gunPosition.add(right.multiplyScalar(0.3));
    gunPosition.add(down.multiplyScalar(0.2 + swayY));

    // Recoil offsets
    let recoilOffset = new THREE.Vector3();
    let recoilRotation = { x: 0, y: 0, z: 0 };

    if (isRecoiling) {
      recoilTime.current += delta;

      const recoilDuration = 0.2;
      const recoilProgress = Math.min(recoilTime.current / recoilDuration, 1);
      const eased = 1 - Math.pow(1 - recoilProgress, 3);

      const maxBackward = 0.15;
      const maxUpward = 0.08;
      const maxRot = -0.3;

      const backward = Math.sin(eased * Math.PI) * maxBackward;
      const upward = Math.sin(eased * Math.PI) * maxUpward;
      const rot = Math.sin(eased * Math.PI) * maxRot;

      recoilOffset.add(forward.clone().multiplyScalar(-backward));
      recoilOffset.add(down.clone().multiplyScalar(-upward));

      recoilRotation.x = -rot;
      recoilRotation.z = (Math.random() - 0.5) * 0.1;
    }

    // Apply final transform
    gunPosition.add(recoilOffset);
    gunRef.current.position.copy(gunPosition);

    gunRef.current.quaternion.copy(camera.quaternion);
    gunRef.current.rotateX(0.1 + recoilRotation.x);
    gunRef.current.rotateY(Math.PI); // remove this if Pop appears mirrored
    gunRef.current.rotateZ(recoilRotation.z);
  });

  if (!shouldShow) return null;

  return (<group dispose={null} visible={shouldShow}>

    <group ref={gunRef}>
      <Pop ref={popRef} />
       {/* MUZZLE ANCHOR ‚Äî tweak this local offset to sit exactly at your barrel tip */}
  <group ref={muzzleRef} position={[0.05, -0.01, -0.82]}>
    <MuzzleFlash trigger={flashKick} />
  </group>
    </group>
    </group>
  );
}
</file>

<file path="src/components/game/MuzzleFlash.tsx">
import React, { useRef, useState } from "react";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";

type Props = {
  /** bump this number to trigger a new flash */
  trigger: number;
};

export default function MuzzleFlash({ trigger }: Props) {
  const last = useRef<number>(-1);
  const startedAt = useRef<number>(-1);
  const [visible, setVisible] = useState(false);
  const strengthRef = useRef(0); // 0..1 animated per frame

  const LIFE = 0.085; // seconds the flash lasts

  useFrame((state) => {
    const t = state.clock.getElapsedTime();

// On first mount, just sync the trigger without flashing.
// This prevents a flash when switching weapons (component remount).
if (last.current === -1) {
  last.current = trigger;
} else if (trigger !== last.current) {
  last.current = trigger;
  startedAt.current = t;
  strengthRef.current = 1;
  setVisible(true);
}


    if (!visible) return;

    const dt = t - startedAt.current;
    if (dt >= LIFE) {
      setVisible(false);
      strengthRef.current = 0;
      return;
    }

    // simple ease-out for brightness/opacity
    const k = 1 - dt / LIFE;
    strengthRef.current = k * k;
  });

  if (!visible) return null;

  const k = strengthRef.current;

  return (
    <group>
      {/* short, bright point light at muzzle */}
      <pointLight
        intensity={28 * k}
        distance={4.5}
        decay={2}
        color={"#ffd87a"}
      />

      {/* hot core cone (points forward along -Z) */}
      <mesh rotation={[Math.PI / 2, 0, 0]}>
        <coneGeometry args={[0.12, 0.28, 20, 1, true]} />
        <meshBasicMaterial
          color={"#fff3c6"}
          transparent
          opacity={0.85 * k}
          depthWrite={false}
          toneMapped={false}
        />
      </mesh>

      {/* outer flare */}
      <mesh rotation={[Math.PI / 2, 0, 0]} position={[0, 0, -0.12]}>
        <coneGeometry args={[0.25, 0.42, 16, 1, true]} />
        <meshBasicMaterial
          color={"#ffb340"}
          transparent
          opacity={0.45 * k}
          depthWrite={false}
          toneMapped={false}
        />
      </mesh>

      {/* tiny tracer stub */}
      <mesh position={[0, 0, -0.35]} rotation={[Math.PI / 2, 0, 0]}>
        <cylinderGeometry args={[0.01, 0.01, 0.5, 6]} />
        <meshBasicMaterial
          color={"#fff9d8"}
          transparent
          opacity={0.6 * k}
          depthWrite={false}
          toneMapped={false}
        />
      </mesh>
    </group>
  );
}
</file>

<file path="src/components/index.ts">
// UI Components
export { MainMenu } from "./ui/MainMenu";
export { Crosshair } from "./ui/Crosshair";
export { PlayerHUD } from "./ui/PlayerHUD";
export { TransactionPopup } from "./ui/TransactionPopup";
export { default as BlockroomsCard } from "./ui/BlockroomsCard";
// export { GrainVignetteOverlay } from "./ui/GrainVignetteOverlay";
// export { DarknessMask } from "./ui/DarknessMask";
// export { Flashlight } from "./ui/Flashlight";

// Game Components
export { Gun } from "./game/Gun";
export { BloodEffect } from "./game/BloodEffect";
export { BulletHole } from "./game/BulletHole";

// System Components
// export { AudioManager } from "./systems/AudioManager";
export { FirstPersonControls } from "./systems/FirstPersonControls";
export { EntityCube } from "./game/EntityCube";
export { HUD } from "./ui/HUD";
</file>

<file path="src/components/systems/AudioManager.tsx">
import { useRef, useEffect, useState } from "react";

export function AudioManager(): null {
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [hasInteracted, setHasInteracted] = useState<boolean>(false);

  useEffect(() => {
    // Create background music audio element
    const audio = new Audio("/bgmusicd.mp3");
    audio.loop = true;
    audio.volume = 0.3; // Set to moderate volume since no entity distance scaling
    audioRef.current = audio;

    // Try to play background music immediately (will fail without user interaction)
    const tryAutoPlay = async (): Promise<void> => {
      try {
        await audio.play();
        setIsPlaying(true);
      } catch (error) {
        console.log("Autoplay blocked, waiting for user interaction");
      }
    };

    tryAutoPlay();

    // Listen for any user interaction to enable audio
    const handleInteraction = async (): Promise<void> => {
      if (!hasInteracted) {
        setHasInteracted(true);
        try {
          await audio.play();
          setIsPlaying(true);
        } catch (error) {
          console.log("Failed to play audio:", error);
        }
      }
    };

    // Add event listeners for user interaction
    document.addEventListener("click", handleInteraction);
    document.addEventListener("keydown", handleInteraction);
    document.addEventListener("touchstart", handleInteraction);

    return () => {
      document.removeEventListener("click", handleInteraction);
      document.removeEventListener("keydown", handleInteraction);
      document.removeEventListener("touchstart", handleInteraction);
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
    };
  }, [hasInteracted]);

  // Audio manager runs silently with no UI
  return null;
}
</file>

<file path="src/components/systems/FirstPersonControls.tsx">
import { useRef, useEffect } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Vector3 } from "three";
import * as THREE from "three";
import { FirstPersonControlsProps, Keys } from "../../types/game";
import useAppStore from "../../zustand/store";

export function FirstPersonControls({
  onPositionUpdate, // Keep for backward compatibility
  onRotationUpdate, // Keep for backward compatibility
}: FirstPersonControlsProps): null {
  const { camera, scene } = useThree();
  
  // Get player state and actions from store
  const { 
    position: playerPosition,
    rotation: playerRotation,
    updatePosition, 
    updateRotation,
    setMoving,
    setVelocity 
  } = useAppStore();
  
  const moveSpeed = 8;
  const playerRadius = 0.7; // Collision radius around player
  const baseHeight = 1.5; // Base camera height (eye level)
  const bobAmplitude = 0.08; // How much the camera bobs up and down
  const bobFrequency = 1; // How fast the bobbing occurs
  const bobTimeRef = useRef<number>(0); // Track time for bobbing animation
  const isMovingRef = useRef<boolean>(false); // Track if player is moving

  // ADD (right after isMovingRef):
const lastPushRef = useRef(0);                 // throttle store updates (~20Hz)
const raycasterRef = useRef(new THREE.Raycaster()); // reuse one raycaster


  const keys = useRef<Keys>({
    forward: false,
    backward: false,
    left: false,
    right: false,
  });

  // Sync camera position with store on mount and when store position changes
  useEffect(() => {
    camera.position.set(playerPosition.x, playerPosition.y, playerPosition.z);
  }, [camera, playerPosition]);

// Ensure gun starts hidden so table props render (overrides any cached value)
useEffect(() => {
  useAppStore.setState({ showGun: false });
}, []);

  
// Handle keyboard input
useEffect(() => {
  const handleKeyDown = (event: KeyboardEvent): void => {
    switch (event.code) {
      // üëá NEW: press T to pick up / show the gun
      case "KeyT":
        // flips the existing store flag; no schema changes
        useAppStore.setState({ showGun: true });
        return;

      case "KeyW":
      case "ArrowUp":
        keys.current.forward = true;
        break;
      case "KeyS":
      case "ArrowDown":
        keys.current.backward = true;
        break;
      case "KeyA":
      case "ArrowLeft":
        keys.current.left = true;
        break;
      case "KeyD":
      case "ArrowRight":
        keys.current.right = true;
        break;
      default:
        break;
    }
  };

  const handleKeyUp = (event: KeyboardEvent): void => {
    switch (event.code) {
      case "KeyW":
      case "ArrowUp":
        keys.current.forward = false;
        break;
      case "KeyS":
      case "ArrowDown":
        keys.current.backward = false;
        break;
      case "KeyA":
      case "ArrowLeft":
        keys.current.left = false;
        break;
      case "KeyD":
      case "ArrowRight":
        keys.current.right = false;
        break;
      default:
        break;
    }
  };

  document.addEventListener("keydown", handleKeyDown);
  document.addEventListener("keyup", handleKeyUp);

  return () => {
    document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("keyup", handleKeyUp);
  };
}, []);


  // Check for collisions using raycasting
  const checkCollision = (newPosition: Vector3): boolean => {
  const raycaster = raycasterRef.current;

    const directions = [
      new Vector3(1, 0, 0), // right
      new Vector3(-1, 0, 0), // left
      new Vector3(0, 0, 1), // forward
      new Vector3(0, 0, -1), // backward
      new Vector3(0.707, 0, 0.707), // diagonal
      new Vector3(-0.707, 0, 0.707), // diagonal
      new Vector3(0.707, 0, -0.707), // diagonal
      new Vector3(-0.707, 0, -0.707), // diagonal
    ];

    // Check collision in multiple directions around the player
    for (const direction of directions) {
      raycaster.set(newPosition, direction);
      const intersects = raycaster.intersectObjects(scene.children, true);

      // Filter out non-solid objects (lights, cameras, etc.)
      const solidIntersects = intersects.filter(
        (intersect: THREE.Intersection) => {
          const object = intersect.object;
          // Check if object has geometry and is likely a wall/floor
          return (
            (object as THREE.Mesh).geometry &&
            (object as THREE.Mesh).material &&
            !(object as THREE.Light).isLight &&
            !(object as THREE.Camera).isCamera &&
            object.visible
          );
        }
      );

      if (
        solidIntersects.length > 0 &&
        solidIntersects[0].distance < playerRadius
      ) {
        return true; // Collision detected
      }
    }
    return false; // No collision
  };

  // Update camera position based on input with collision detection and running animation
  useFrame((state, delta: number) => {
    const dt = delta; // don't clamp for movement


    const velocity = new Vector3();
    const direction = new Vector3();

    camera.getWorldDirection(direction);
    direction.y = 0; // Keep movement horizontal
    direction.normalize();

    const right = new Vector3();
    right.crossVectors(direction, camera.up).normalize();

    if (keys.current.forward) velocity.add(direction);
    if (keys.current.backward) velocity.sub(direction);
    if (keys.current.right) velocity.add(right);
    if (keys.current.left) velocity.sub(right);

    // Check if player is moving
    const isMoving = velocity.length() > 0;
    isMovingRef.current = isMoving;
    
    // Update store with movement state
    setMoving(isMoving);

    if (isMoving) {
      velocity.normalize();
velocity.multiplyScalar(moveSpeed * delta);

      
      // Update store with current velocity
      setVelocity({
        x: velocity.x,
        y: velocity.y,
        z: velocity.z
      });

      // Calculate new position
      const newPosition = camera.position.clone().add(velocity);

      // Check for collision before moving
      if (!checkCollision(newPosition)) {
        camera.position.copy(newPosition);
      } else {
        // Try moving in individual axes if diagonal movement is blocked
        const xMovement = new Vector3(velocity.x, 0, 0);
        const zMovement = new Vector3(0, 0, velocity.z);

        const xPosition = camera.position.clone().add(xMovement);
        const zPosition = camera.position.clone().add(zMovement);

        if (!checkCollision(xPosition)) {
          camera.position.add(xMovement);
        } else if (!checkCollision(zPosition)) {
          camera.position.add(zMovement);
        }
        // If both individual axes are blocked, don't move
      }
    } else {
      // Update store with zero velocity when not moving
      setVelocity({ x: 0, y: 0, z: 0 });
    }

    // Handle running animation (head bob)
    if (isMovingRef.current) {
      // Increment bob time when moving
      bobTimeRef.current += delta * bobFrequency;

      // Calculate bobbing offset using sine wave
      const bobOffset = Math.sin(bobTimeRef.current) * bobAmplitude;

      // Apply bobbing to camera Y position
      camera.position.y = baseHeight + bobOffset;
    } else {
      // When not moving, gradually return to base height
      const currentHeight = camera.position.y;
      const heightDiff = baseHeight - currentHeight;

      // Smooth interpolation back to base height
      if (Math.abs(heightDiff) > 0.001) {
 camera.position.y += heightDiff * delta * 5;

      } else {
        camera.position.y = baseHeight;
      }

      // Reset bob time when not moving
      bobTimeRef.current = 0;
    }

    // Update store with current position
    updatePosition({
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z
    });

    // Update store with current rotation
    const rotation = camera.rotation.y;
    updateRotation(rotation);

    // Call legacy callbacks for backward compatibility
    if (onPositionUpdate) {
      onPositionUpdate(camera.position.clone());
    }
    if (onRotationUpdate) {
      onRotationUpdate(rotation);
    }
  });

  return null;
}
</file>

<file path="src/components/systems/MapTracker.tsx">
// import React from 'react';
// import { Vector3 } from 'three';

// interface MapTrackerProps {
//   playerPosition: { x: number; y: number; z: number };
//   playerRotation?: number; // Optional rotation in radians
//   mapScale?: number; // Scale factor for the map
//   size?: number; // Size of the tracker in pixels
// }

// export const MapTracker: React.FC<MapTrackerProps> = ({
//   playerPosition,
//   playerRotation = 0,
//   mapScale = 20, // Adjust this to fit your game world scale
//   size = 200
// }) => {
//   // Convert 3D world position to 2D map coordinates (positive values only)
//   // Offset by mapScale to ensure positive coordinates, then scale to map size
//    const mapX = ((playerPosition.x + mapScale) / (mapScale * 2)) * size;
//   const mapZ = ((playerPosition.z + mapScale) / (mapScale * 2)) * size;

//   // Clamp coordinates to stay within the map bounds
//   const clampedX = Math.max(10, Math.min(size - 10, mapX));
//   const clampedZ = Math.max(10, Math.min(size - 10, mapZ));

//   // Convert rotation for the player indicator arrow
//   const rotationDegrees = (playerRotation * 180) / Math.PI;

//   const containerStyle: React.CSSProperties = {
//     position: 'fixed',
//     top: '20px',
//     right: '20px',
//     width: `${size}px`,
//     height: `${size}px`,
//     backgroundColor: 'rgba(0, 0, 0, 0.8)',
//     border: '2px solid #333',
//     borderRadius: '8px',
//     zIndex: 1000,
//     fontFamily: 'monospace',
//     color: '#00ff00',
//     fontSize: '12px',
//   };

//   const mapStyle: React.CSSProperties = {
//     position: 'relative',
//     width: '100%',
//     height: '100%',
//     backgroundColor: 'rgba(20, 20, 20, 0.9)',
//     border: '1px solid #444',
//     borderRadius: '4px',
//     overflow: 'hidden',
//   };

//   const gridStyle: React.CSSProperties = {
//     position: 'absolute',
//     top: 0,
//     left: 0,
//     width: '100%',
//     height: '100%',
//     backgroundImage: `
//       linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
//       linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px)
//     `,
//     backgroundSize: '20px 20px',
//   };

//   const playerDotStyle: React.CSSProperties = {
//     position: 'absolute',
//     left: `${clampedX - 6}px`,
//     top: `${clampedZ - 6}px`,
//     width: '12px',
//     height: '12px',
//     backgroundColor: '#ff0000',
//     borderRadius: '50%',
//     border: '2px solid #fff',
//     zIndex: 2,
//     boxShadow: '0 0 8px rgba(255, 0, 0, 0.8)',
//   };

//   const playerArrowStyle: React.CSSProperties = {
//     position: 'absolute',
//     left: `${clampedX - 8}px`,
//     top: `${clampedZ - 8}px`,
//     width: '16px',
//     height: '16px',
//     zIndex: 3,
//     transform: `rotate(${rotationDegrees}deg)`,
//     transformOrigin: 'center',
//   };

//   const infoStyle: React.CSSProperties = {
//     position: 'absolute',
//     bottom: '4px',
//     left: '4px',
//     right: '4px',
//     backgroundColor: 'rgba(0, 0, 0, 0.8)',
//     padding: '4px',
//     borderRadius: '2px',
//     fontSize: '10px',
//     lineHeight: '1.2',
//   };

//   return (
//     <div style={containerStyle}>
//       <div style={mapStyle}>
//         {/* Grid overlay */}
//         <div style={gridStyle} />
        
//         {/* Player position indicator */}
//         <div style={playerDotStyle} />
        
//         {/* Player direction arrow */}
//         <div style={playerArrowStyle}>
//           <svg
//             width="16"
//             height="16"
//             viewBox="0 0 16 16"
//             fill="none"
//             xmlns="http://www.w3.org/2000/svg"
//           >
//             <path
//               d="M8 2L12 14L8 10L4 14L8 2Z"
//               fill="#ffffff"
//               stroke="#000000"
//               strokeWidth="1"
//             />
//           </svg>
//         </div>
        
//         {/* Position info */}
//         <div style={infoStyle}>
//           <div>X: {Math.abs(playerPosition.x).toFixed(1)}</div>
//           <div>Y: {Math.abs(playerPosition.y).toFixed(1)}</div>
//           <div>Z: {Math.abs(playerPosition.z).toFixed(1)}</div>
//         </div>
//       </div>
//     </div>
//   );
// };
</file>

<file path="src/components/ui/BlockroomsCard.tsx">
import React, { useMemo } from "react";
import useAppStore from "../../zustand/store";

/**
 * Exact ‚ÄúBlockroomsCard‚Äù UI, wired to the same data the old HUD used.
 * Pure UI only ‚Äî no gameplay logic changed.
 */
export const PlayerHUD: React.FC = () => {
  // same selectors as the old HUD
  const {
    player,
    gameStats,
    gamePhase,               // kept to mirror old HUD signature (unused visually)
    getActionsRemaining,
    position: playerPosition,
    currentRoom,
    connectionStatus,
  } = useAppStore();

  // keep the same early return as old HUD
  if (!player) return null;

  const actionsLeft = getActionsRemaining();
  const pad = (n: number) => Math.round(n || 0);

  // shortened id, identical to old HUD logic
  const playerShortId = useMemo(
    () => `${player.player_id.slice(0, 6)}...${player.player_id.slice(-4)}`,
    [player.player_id]
  );

  // avatar/feed image (UI only, won‚Äôt break pointer lock)
  const avatarSrc =
    (player as any)?.avatarUrl ??
    "/feed.png";

  // colors
  const C = {
    bgShell: "#0b1216",
    border: "#293941",
    text: "#d0e5ee",
    dim: "#9eb3bb",
    headerBg: "#0d1519",
    ribbonBg: "#162129",
    gold: "#E1CF48",
    ok: "#90EE90",
    warn: "#ffaa00",
    bad: "#ff6666",
    panelBg: "#070a0c",
    label: "#ccc",
    gridGreen: "#7DF17C",
  };

  const healthColor =
    gameStats.currentHealth > gameStats.maxHealth * 0.5
      ? C.ok
      : gameStats.currentHealth > gameStats.maxHealth * 0.25
      ? C.warn
      : C.bad;

  // match the old HUD‚Äôs ‚Äúcurrent room‚Äù behavior; fall back to player.current_room
  const currentRoomId =
    (currentRoom as any)?.room_id?.toString?.() ??
    (player as any)?.current_room?.toString?.() ??
    "-";

  return (
    <div
      style={{
        position: "fixed",
        top: 20,
        left: 20,
        zIndex: 1200,
        fontFamily: "'Joystix', monospace",
        color: C.text,
        pointerEvents: "none",
        transform: "scale(0.7)",
        transformOrigin: "top left",
      }}
    >
      <link href="https://fonts.cdnfonts.com/css/joystix" rel="stylesheet" />

      {/* Card shell */}
      <div
        style={{
          width: 300,
          background: C.bgShell,
          border: `3px solid ${C.border}`,
          boxShadow: "0 0 0 4px #222 inset",
          pointerEvents: "none",
        }}
      >
        {/* Header bar */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "10px 12px",
            borderBottom: `3px solid ${C.border}`,
            background: C.headerBg,
            letterSpacing: 2,
            pointerEvents: "none",
          }}
        >
          <div style={{ fontSize: 18 }}>BLOCKROOMS</div>

          {/* tiny battery/signal cluster */}
          <div
            style={{
              display: "flex",
              alignItems: "center",
              gap: 8,
              color: C.dim,
              fontSize: 7,
            }}
          >
            <span style={{ textTransform: "uppercase" }}>
              {connectionStatus === "connected" ? "" : ""}
            </span>
            <div
              style={{
                width: 36,
                height: 14,
                border: `2px solid ${C.dim}`,
                position: "relative",
                display: "flex",
                gap: 2,
                padding: 2,
              }}
            >
              <div style={{ flex: 1, background: C.dim }} />
              <div style={{ flex: 1, background: C.dim }} />
              <div
                style={{
                  flex: 1,
                  background:
                    connectionStatus === "connected" ? C.dim : "transparent",
                }}
              />
              {/* stub */}
              <div
                style={{
                  position: "absolute",
                  right: -6,
                  top: 3,
                  width: 4,
                  height: 6,
                  background: C.dim,
                }}
              />
            </div>
          </div>
        </div>

        {/* CONNECT ribbon */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "8px 12px",
            background: C.ribbonBg,
            borderBottom: `3px solid ${C.border}`,
            fontSize: 16,
            letterSpacing: 2,
            color: connectionStatus === "connected" ? C.ok : C.warn,
          }}
        >
          <div>IDENTITY</div>
          <div
            style={{
              width: 22,
              height: 18,
              border: `3px solid ${C.dim}`,
              borderRadius: 4,
              position: "relative",
            }}
          >
            <div
              style={{
                position: "absolute",
                right: 4,
                bottom: -6,
                width: 8,
                height: 6,
                borderLeft: `3px solid ${C.dim}`,
                borderBottom: `3px solid ${C.dim}`,
                transform: "skewX(-20deg)",
              }}
            />
          </div>
        </div>

        {/* --- FACE / FEED IMAGE --- */}
        <div
          style={{
            border: `3px solid ${C.border}`,
            background: "#0e1418",
            aspectRatio: "1 / 1",
            position: "relative",
            overflow: "hidden",
            marginBottom: 10,
            pointerEvents: "none",
          }}
        >
          <img
            src={avatarSrc}
            alt="Feed"
            style={{
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter:
                "grayscale(100%) contrast(140%) brightness(95%) sepia(22%) hue-rotate(160deg) saturate(120%)",
              imageRendering: "pixelated" as any,
              pointerEvents: "none",
              userSelect: "none",
            }}
            draggable={false}
          />
        </div>

        {/* Body ‚Äî stacked panes (no clicks to preserve pointer lock) */}
        <div style={{ padding: 10, borderBottom: `3px solid ${C.border}` }}>
          {/* --- PLAYER STATUS --- */}
          <div
            style={{
              border: `3px solid ${C.border}`,
              background: "#0e1418",
              padding: 10,
              marginBottom: 10,
            }}
          >
            <div
              style={{
                fontSize: 14,
                letterSpacing: 2,
                marginBottom: 8,
                color: C.gold,
              }}
            >
              PLAYER STATUS
            </div>

            {/* ID */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>ID: </span>
              <span style={{ color: C.ok }}>{playerShortId}</span>
            </div>

            {/* Health */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Health: </span>
              <span style={{ color: healthColor }}>
                {gameStats.currentHealth}/{gameStats.maxHealth}
              </span>
              <div
                style={{
                  width: 120,
                  height: 8,
                  backgroundColor: "rgba(255,255,255,0.15)",
                  borderRadius: 4,
                  marginTop: 3,
                  overflow: "hidden",
                }}
              >
                <div
                  style={{
                    width: `${
                      (gameStats.currentHealth /
                        Math.max(1, gameStats.maxHealth)) *
                      100
                    }%`,
                    height: "100%",
                    backgroundColor: healthColor,
                    transition: "width 0.25s ease",
                  }}
                />
              </div>
            </div>

            {/* Shards */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Shards: </span>
              <span style={{ color: C.ok }}>{gameStats.currentShards}</span>
            </div>

            {/* Numbered shards */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Special Shards: </span>
              <span style={{ color: C.gold }}>
                {player.has_shard_one ? "‚ë†" : "‚óã"}{" "}
                {player.has_shard_two ? "‚ë°" : "‚óã"}{" "}
                {player.has_shard_three ? "‚ë¢" : "‚óã"}
              </span>
              {gameStats.hasAllNumberedShards && (
                <span style={{ color: C.ok, marginLeft: 6 }}>‚úì COMPLETE</span>
              )}
            </div>

            {/* Key */}
            <div style={{ marginBottom: 0 }}>
              <span style={{ color: C.label }}>Key: </span>
              <span style={{ color: gameStats.hasKey ? C.ok : C.bad }}>
                {gameStats.hasKey ? "YES" : "NO"}
              </span>
            </div>
          </div>

          {/* --- GAME PROGRESS --- */}
          <div
            style={{
              border: `3px solid ${C.border}`,
              background: "#0e1418",
              padding: 10,
              marginBottom: 10,
            }}
          >
            <div
              style={{
                fontSize: 14,
                letterSpacing: 2,
                marginBottom: 8,
                color: C.gold,
              }}
            >
              GAME PROGRESS
            </div>

            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Rooms Cleared: </span>
              <span style={{ color: C.ok }}>{gameStats.roomsCleared}</span>
            </div>

            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Current Room: </span>
              <span style={{ color: C.ok }}>{currentRoomId}</span>
            </div>

            <div>
              <span style={{ color: C.label }}>Actions Left: </span>
              <span style={{ color: C.ok }}>{actionsLeft}</span>
            </div>
          </div>

          {/* --- GRID POSITION --- */}
          <div
            style={{
              border: `3px solid ${C.border}`,
              background: "#0e1418",
              padding: 10,
            }}
          >
            <div
              style={{
                fontSize: 14,
                letterSpacing: 2,
                marginBottom: 8,
                color: C.gold,
              }}
            >
              Grid Position:
            </div>

            <div style={{ marginBottom: 4 }}>
              <span style={{ color: C.gridGreen }}>X:</span>{" "}
              <span style={{ color: C.text }}>{pad(playerPosition.x)}</span>
            </div>
            <div style={{ marginBottom: 4 }}>
              <span style={{ color: C.gridGreen }}>Y:</span>{" "}
              <span style={{ color: C.text }}>{pad(playerPosition.z)}</span>
            </div>
          </div>
        </div>

        {/* Footer strip (tiny) */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: 8,
            padding: "8px 10px",
            color: C.text,
            borderTop: `3px solid ${C.border}`,
            background: C.headerBg,
            letterSpacing: 2,
            fontSize: 11,
          }}
        >
          <span
            style={{
              width: 0,
              height: 0,
              borderLeft: "6px solid transparent",
              borderRight: "6px solid transparent",
              borderBottom: `10px solid ${C.text}`,
              transform: "translateY(2px)",
            }}
          />
          <span>PROPERTY OF KEPLER22BEE GAMING STUDIO</span>
          <span
            style={{
              width: 0,
              height: 0,
              borderLeft: "6px solid transparent",
              borderRight: "6px solid transparent",
              borderBottom: `10px solid ${C.text}`,
              transform: "translateY(2px)",
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default PlayerHUD;
</file>

<file path="src/components/ui/Crosshair.tsx">
export function Crosshair(): JSX.Element {
  return (
    <div
      style={{
        position: "fixed",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        zIndex: 2000,
        pointerEvents: "none", // Allow clicks to pass through
        color: "white",
        fontSize: "20px",
        fontWeight: "bold",
        textShadow: "2px 2px 4px rgba(0,0,0,0.8)",
        userSelect: "none",
      }}
    >
      <div
        style={{
          position: "relative",
          width: "20px",
          height: "20px",
        }}
      >
        {/* Horizontal line */}
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "0",
            width: "20px",
            height: "2px",
            backgroundColor: "white",
            transform: "translateY(-50%)",
            boxShadow: "0 0 4px rgba(0,0,0,0.8)",
          }}
        />
        {/* Vertical line */}
        <div
          style={{
            position: "absolute",
            top: "0",
            left: "50%",
            width: "2px",
            height: "20px",
            backgroundColor: "white",
            transform: "translateX(-50%)",
            boxShadow: "0 0 4px rgba(0,0,0,0.8)",
          }}
        />
        {/* Center dot */}
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "4px",
            height: "4px",
            backgroundColor: "white",
            borderRadius: "50%",
            transform: "translate(-50%, -50%)",
            boxShadow: "0 0 4px rgba(0,0,0,0.8)",
          }}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/DarknessMask.tsx">
// components/ui/DarknessMask.tsx
import React, { useEffect, useRef } from "react";

type Props = {
  darkness?: number;   // fallback alpha when no proximity info yet
  radiusPct?: number;  // optional center bright spot (set 0 to disable)
  feather?: number;    // softness of the center spot
};

const clamp = (v:number,a:number,b:number) => Math.min(b, Math.max(a, v));

export default function DarknessMask({
  darkness = 0.96,
  radiusPct = 0,      // <- disable center spot by default
  feather = 220,
}: Props) {
  const ref = useRef<HTMLCanvasElement | null>(null);

  useEffect(() => {
    const cvs = ref.current!;
    const ctx = cvs.getContext("2d")!;
    let cssW = 0, cssH = 0, dpr = 1, raf = 0;

    const resize = () => {
      dpr = clamp(window.devicePixelRatio || 1, 1, 2);
      cssW = Math.floor(window.innerWidth);
      cssH = Math.floor(window.innerHeight);
      cvs.width = Math.floor(cssW * dpr);
      cvs.height = Math.floor(cssH * dpr);
      cvs.style.width = `${cssW}px`;
      cvs.style.height = `${cssH}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // drawing in CSS px now
    };
    resize();
    window.addEventListener("resize", resize);

    const draw = () => {
      raf = requestAnimationFrame(draw);

      const a = clamp((window as any).__DARK_ALPHA ?? darkness, 0, 1);

      // full-screen darkness
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0, 0, cssW, cssH);
      ctx.fillStyle = `rgba(0,0,0,${a})`;
      ctx.fillRect(0, 0, cssW, cssH);

      // optional central bright spot (legacy look)
      if (radiusPct > 0) {
        const minSide = Math.min(cssW, cssH);
        const baseR = minSide * clamp(radiusPct, 0, 1);
        const soft = feather;
        const grad = ctx.createRadialGradient(
          cssW / 2, cssH / 2, Math.max(1, baseR * 0.6),
          cssW / 2, cssH / 2, baseR + soft
        );
        ctx.globalCompositeOperation = "destination-out";
        grad.addColorStop(0.0, "rgba(0,0,0,1)");
        grad.addColorStop(baseR / (baseR + soft), "rgba(0,0,0,1)");
        grad.addColorStop(1.0, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cssW / 2, cssH / 2, baseR + soft, 0, Math.PI * 2);
        ctx.fill();
      }
    };

    raf = requestAnimationFrame(draw);
    return () => {
      cancelAnimationFrame(raf);
      window.removeEventListener("resize", resize);
    };
  }, [darkness, feather, radiusPct]);

  return (
    <canvas
      ref={ref}
      style={{
        position: "fixed",
        inset: 0,
        pointerEvents: "none",
        zIndex: 2000,
      }}
    />
  );
}
</file>

<file path="src/components/ui/Flashlight.tsx">
import { useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";

type Props = {
  intensity?: number;
  distance?: number;
  angle?: number;     // radians
  penumbra?: number;  // 0..1
  decay?: number;     // physically-correct falloff
};

export default function Flashlight({
  intensity = 60,
  distance = 35,
  angle = 0.7,
  penumbra = 0.18,
  decay = 1.5,
}: Props) {
  const { camera } = useThree();
  const light = useRef<THREE.SpotLight>(null);
  const target = useRef<THREE.Object3D>(new THREE.Object3D());

  // Keep the "base" brightness to restore between flicker windows
  const baseIntensity = useRef(intensity);

  // Internal flicker state
  const flicker = useRef({
    inWindow: false,
    nextWindowStart: 0, // when the next 3‚Äì4s window begins
    windowEnd: 0,       // when the current window ends
    nextToggle: 0,      // when to toggle on/off again
    isOn: true,
  });

  const rand = (min: number, max: number) => Math.random() * (max - min) + min;

  useFrame((state) => {
    const now = state.clock.getElapsedTime();

    // --- Schedule next flicker window if none scheduled yet
    if (!flicker.current.inWindow && flicker.current.nextWindowStart === 0) {
      flicker.current.nextWindowStart = now + rand(30, 60); // 30‚Äì60s
    }

    // --- Enter a flicker window?
    if (!flicker.current.inWindow && now >= flicker.current.nextWindowStart) {
      flicker.current.inWindow = true;
      flicker.current.windowEnd = now + rand(5, 6); // 3‚Äì4s window
      flicker.current.nextToggle = now;             // start flickering immediately
    }

    // --- Exit a flicker window?
    if (flicker.current.inWindow && now >= flicker.current.windowEnd) {
      flicker.current.inWindow = false;
      flicker.current.isOn = true; // restore steady light
      flicker.current.nextWindowStart = now + rand(7, 15); // 7‚Äì15s until next window
    }

    // --- Inside the window: toggle rapidly with random cadence
    if (flicker.current.inWindow && now >= flicker.current.nextToggle) {
      // ~60% chance to be OFF on a given toggle, ~40% ON
      flicker.current.isOn = Math.random() > 0.6 ? true : false;

      // Mostly very short intervals, sometimes a slightly longer blackout
      const longBlackout = Math.random() < 0.12; // 12% chance
      flicker.current.nextToggle =
        now + (longBlackout ? rand(0.18, 0.45) : rand(0.04, 0.16));
    }

    // --- Keep the light glued to the camera and looking ahead
    if (light.current) {
      light.current.position.copy(camera.position);

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      target.current.position.copy(camera.position).add(forward.multiplyScalar(5));
      light.current.target.position.copy(target.current.position);
      light.current.target.updateMatrixWorld();

      // Compute current intensity
      let currentIntensity = baseIntensity.current;

      if (flicker.current.inWindow) {
        if (!flicker.current.isOn) {
          currentIntensity = 0; // totally off during OFF moments
        } else {
          // Slight brightness wobble even when "on" to feel electrical
          currentIntensity = baseIntensity.current * (0.75 + Math.random() * 0.35);
        }
      }

      light.current.intensity = currentIntensity;
      light.current.visible = currentIntensity > 0.01; // vanish cone when basically off
    }
  });

  return (
    <>
      <spotLight
        ref={light}
        castShadow
        intensity={intensity}
        distance={distance}
        angle={angle}
        penumbra={penumbra}
        decay={decay}
      />
      <primitive object={target.current} />
    </>
  );
}
</file>

<file path="src/components/ui/GrainVignetteOverlay.tsx">
import React, { useEffect, useRef } from "react";

type Props = {
  /** 0‚Äì1: how strong the grain looks */
  intensity?: number;
  /** frames per second for grain animation (lower = grittier & cheaper) */
  fps?: number;
  /** subtle dark tint over the scene */
  tint?: string;
  /** 0‚Äì1: how strong the vignette is (closer to 1 = stronger) */
  vignette?: number;
  /** stacking order below your HUD (your HUD uses 3000/5000) */
  zIndex?: number;
};

export default function GrainVignetteOverlay({
  intensity = 0.12,
  fps = 24,
  tint = "rgba(18, 14, 14, 0.22)",
  vignette = 0.65,
  zIndex = 1500,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const noiseRef = useRef<HTMLCanvasElement>(document.createElement("canvas"));
  const raf = useRef<number>();

  useEffect(() => {
    const canvas = canvasRef.current!;
    const ctx = canvas.getContext("2d")!;
    const noiseCanvas = noiseRef.current;
    const nctx = noiseCanvas.getContext("2d")!;
    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resize();
    window.addEventListener("resize", resize);

    // small tile we update every frame and repeat across the screen
    noiseCanvas.width = 128;
    noiseCanvas.height = 128;

    const drawNoiseTile = () => {
      const id = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);
      const d = id.data;
      for (let i = 0; i < d.length; i += 4) {
        const v = Math.random() * 255;
        d[i] = d[i + 1] = d[i + 2] = v; // monochrome
        d[i + 3] = 255;
      }
      nctx.putImageData(id, 0, 0);
    };

    let last = 0;
    const step = 1000 / Math.max(1, fps);

    const loop = (t: number) => {
      if (t - last >= step) {
        last = t;
        drawNoiseTile();
        const pattern = ctx.createPattern(noiseCanvas, "repeat")!;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = intensity;
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
      }
      raf.current = requestAnimationFrame(loop);
    };
    raf.current = requestAnimationFrame(loop);

    return () => {
      window.removeEventListener("resize", resize);
      if (raf.current) cancelAnimationFrame(raf.current);
    };
  }, [fps, intensity]);

  // three layers: tint (dark mood), grain, vignette edges
  return (
    <>
      {/* subtle tint for a darker, moodier base */}
      <div
        style={{
          position: "fixed",
          inset: 0,
          background: tint,
          pointerEvents: "none",
          zIndex: zIndex - 1,
        }}
      />
      {/* animated film grain */}
      <canvas
        ref={canvasRef}
        style={{
          position: "fixed",
          inset: 0,
          width: "100vw",
          height: "100vh",
          pointerEvents: "none",
          zIndex,
          // multiply keeps highlights, deepens shadows = gritty
          mixBlendMode: "multiply",
        }}
      />
      {/* vignette */}
      <div
        style={{
          position: "fixed",
          inset: 0,
          pointerEvents: "none",
          zIndex: zIndex + 1,
          background: `radial-gradient(ellipse at 50% 50%, rgba(0,0,0,0) ${Math.round(
            (1 - vignette) * 100
          )}%, rgba(0,0,0,0.7) 100%)`,
        }}
      />
    </>
  );
}
</file>

<file path="src/components/ui/HUD.tsx">
import React, { useEffect, useState } from "react";

import useAppStore from "../../zustand/store";

/**
 * Old HUD UI (unchanged look) but reads from the store instead of props.
 * - showGun      ‚Üê s.showGun
 * - ammoInMag    ‚Üê s.ammoInMag || s.currentAmmo || s.ammo || s.gunAmmo || s.gameStats?.*
 * - ammoReserve  ‚Üê s.ammoReserve || s.reserveAmmo || s.gunReserve || s.gameStats?.*
 *
 * No logic changes ‚Äî pure UI.
 */
export const HUD: React.FC = () => {
  // --- Weapon awareness for the ammo UI ---
  // Prefer a store field if you already keep activeWeapon there.
  const storeWeapon = useAppStore(
    (s: any) => s.activeWeapon ?? s.weapon ?? null
  );

  // Fallback path: listen for a broadcast from App (see step 2).
  const [hudWeapon, setHudWeapon] = useState<"pistol" | "shotgun">("pistol");

  useEffect(() => {
    const onWpn = (e: Event) => {
      const ce = e as CustomEvent<{ weapon: "pistol" | "shotgun" }>;
      if (ce?.detail?.weapon) setHudWeapon(ce.detail.weapon);
    };
    window.addEventListener("hud:weapon", onWpn as EventListener);
    return () =>
      window.removeEventListener("hud:weapon", onWpn as EventListener);
  }, []);

  // Final weapon value used by HUD (store wins if present)
  const weapon: "pistol" | "shotgun" = (storeWeapon as any) ?? hudWeapon;

  // Pull values from the store with resilient fallbacks (names differ between builds)
  const showGun = useAppStore((s: any) => !!s.showGun);

  const ammoInMag = useAppStore(
    (s: any) =>
      (s.ammoInMag ??
        s.currentAmmo ??
        s.ammo ??
        s.gunAmmo ??
        s.gameStats?.ammoInMag ??
        s.gameStats?.currentAmmo ??
        s.gameStats?.ammo ??
        0) | 0
  );

  const ammoReserve = useAppStore(
    (s: any) =>
      (s.ammoReserve ??
        s.reserveAmmo ??
        s.gunReserve ??
        s.gameStats?.ammoReserve ??
        s.gameStats?.reserveAmmo ??
        0) | 0
  );

  // Live ammo pushed from Gun.tsx (non-persistent)
  const [hudMag, setHudMag] = useState<number | null>(null);
  const [hudReserve, setHudReserve] = useState<number | null>(null);

  useEffect(() => {
    const onAmmo = (e: Event) => {
      const ce = e as CustomEvent<{ mag: number; reserve: number }>;
      if (!ce?.detail) return;
      setHudMag(ce.detail.mag);
      setHudReserve(ce.detail.reserve);
    };
    window.addEventListener("hud:ammo", onAmmo as EventListener);
    return () =>
      window.removeEventListener("hud:ammo", onAmmo as EventListener);
  }, []);

  const pad3 = (n: number) => String(Math.max(0, n | 0)).padStart(3, "0");

  // prefer live HUD numbers from Gun; fall back to store values
  const bigAmmo = pad3(showGun ? hudMag ?? ammoInMag : 0);
  const reserveAmmo = pad3(showGun ? hudReserve ?? ammoReserve : 0);

  return (
    <div
      style={{
        width: 260,
        top: 20,
        right: 20,
        height: 92,
        borderRadius: 4,
        overflow: "hidden",
        border: "1px solid #5c6770",
        boxShadow: "0 2px 6px rgba(0,0,0,0.35)",
        fontFamily: "'Share Tech Mono', monospace",
        userSelect: "none",
        background: "linear-gradient(180deg, #AEB4BD 0%, #A7ACB5 100%)",
        position: "fixed",
        zIndex: 1200,
        pointerEvents: "none",
      }}
    >
      {/* Web font */}
      <link
        href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap"
        rel="stylesheet"
      />

      {/* TOP STRIP */}
      <div
        style={{
          background: "#2a3944",
          height: 32,
          width: "100%",
          position: "absolute",
          top: 0,
          left: 0,
        }}
      />

      {/* HEALTH BAR (visual only, kept from old HUD) */}
      <div
        style={{
          position: "absolute",
          top: 8,
          left: 12,
          right: 12,
          height: 16,
          display: "flex",
          alignItems: "center",
          gap: 8,
        }}
      >
        {/* Plus icon */}
        <div
          style={{
            width: 18,
            height: 18,
            display: "grid",
            placeItems: "center",
          }}
        >
          <div style={{ position: "relative", width: 14, height: 14 }}>
            <div
              style={{
                position: "absolute",
                left: 6,
                top: 0,
                width: 2,
                height: 14,
                background: "#ffffff",
              }}
            />
            <div
              style={{
                position: "absolute",
                left: 0,
                top: 6,
                width: 14,
                height: 2,
                background: "#ffffff",
              }}
            />
          </div>
        </div>

        {/* Track */}
        <div
          style={{
            flex: 1,
            height: 16,
            background: "#0d0d0d",
            borderRadius: 2,
            position: "relative",
            overflow: "hidden",
          }}
        >
          {/* Orange dots + gray gap */}
          <div
            style={{
              position: "absolute",
              left: 6,
              top: 3,
              display: "flex",
              alignItems: "center",
              gap: 2,
              zIndex: 2,
            }}
          >
            {[0, 1, 2].map((i) => (
              <div
                key={i}
                style={{
                  width: 6,
                  height: 6,
                  background: "#F47B00",
                }}
              />
            ))}
            <div
              style={{
                width: 6,
                height: 6,
                background: "#6f7b85",
              }}
            />
          </div>

          {/* Fill (kept as-is from old UI) */}
          <div
            style={{
              position: "absolute",
              left: 0,
              top: 0,
              bottom: 0,
              width: "68%",
              background: "#F47B00",
            }}
          />
        </div>
      </div>

      {/* LOWER STRIP */}
      <div
        style={{
          position: "absolute",
          left: 0,
          right: 0,
          bottom: 0,
          height: 60,
          display: "grid",
          gridTemplateColumns: "56px 84px 1fr",
          alignItems: "center",
        }}
      >
        {/* Left tab: thumb until gun is equipped */}
        <div
          style={{
            height: "100%",
            background: "#303b45",
            borderRight: "1px solid #1e272f",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          {showGun ? (
            <div style={{ display: "flex", gap: 4, alignItems: "center" }}>
              {[0, 1, 2].map((i) => (
                <div
                  key={i}
                  style={{
                    width: 8,
                    height: 26,
                    background: "#ffffff",
                    borderRadius: 2,
                  }}
                />
              ))}
            </div>
          ) : (
            <img
              src="/thumb.png"
              alt="thumb"
              style={{
                width: 128,
                height: 64,
                objectFit: "contain",
                pointerEvents: "none",
                userSelect: "none",
              }}
              draggable={false}
            />
          )}
        </div>

        {/* Center tab: gun icon only after pickup */}

        <div
          style={{
            height: "100%",
            borderRight: "1px solid #5c6770",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            paddingLeft: 4,
          }}
        >
          {showGun && (
            <img
              // NOTE: ibb.co links are often page URLs. If it doesn't render,
              // open it and copy the *direct* image URL (hosted on i.ibb.co with .png/.jpg),
              // or drop a file into /public/ui/shotgun.png and use "/ui/shotgun.png".
              src={
                weapon === "shotgun" ? "./shot.png" : "/pistol.png"
              }
              alt={weapon === "shotgun" ? "shotgun" : "pistol"}
              style={{
                width: 128,
                height: 64,
                objectFit: "contain",
                // Keep the pistol blacked-out like before; show the shotgun image as-is
                filter: weapon === "shotgun" ? undefined : "brightness(0)",
                pointerEvents: "none",
                userSelect: "none",
              }}
              draggable={false}
            />
          )}
        </div>

        {/* Ammo count */}
        <div
          style={{
            height: "100%",
            display: "flex",
            alignItems: "center",
            paddingLeft: 10,
            position: "relative",
          }}
        >
          <span
            style={{
              fontSize: 34,
              lineHeight: 1,
              color: "#0a0a0a",
              letterSpacing: 1,
              minWidth: 60,
              display: "inline-block",
              textAlign: "left",
            }}
          >
            {bigAmmo}
          </span>
          <span
            style={{
              position: "absolute",
              right: 10,
              bottom: 8,
              fontSize: 18,
              color: "#80868e",
            }}
          >
            {reserveAmmo}
          </span>
        </div>
      </div>
    </div>
  );
};

export default HUD;
</file>

<file path="src/components/ui/Instructions.tsx">
// import React from "react";

// export function Instructions(): JSX.Element {
//   return (
//     <div
//       style={{
//         position: "absolute",
//         top: "20px",
//         left: "20px",
//         color: "white",
//         fontFamily: "Arial, sans-serif",
//         fontSize: "14px",
//         background: "rgba(0, 0, 0, 0.7)",
//         padding: "15px",
//         borderRadius: "8px",
//         zIndex: 1000,
//         maxWidth: "300px",
//       }}
//     >
//       <div style={{ marginBottom: "10px", fontWeight: "bold" }}>üéÆ Controls</div>
//       <div>‚Ä¢ Click to lock mouse cursor</div>
//       <div>‚Ä¢ WASD or Arrow Keys to move</div>
//       <div>‚Ä¢ Mouse to look around</div>
//       <div>‚Ä¢ Left Click to shoot</div>
//       <div>‚Ä¢ ESC to unlock cursor</div>
//       <div style={{ marginTop: "10px", fontSize: "12px", opacity: "0.8" }}>
//         üéØ Hunt enemies in the 20 rooms!
//         <br />
//         üî¥ Red alerts show enemy locations
//         <br />‚ö° New enemy spawns 5-6s after kill
//       </div>
//     </div>
//   );
// }
</file>

<file path="src/components/ui/LightProximity.tsx">
// LightProximity.tsx
import { useThree, useFrame } from "@react-three/fiber";
import * as THREE from "three";
import React, { useRef } from "react";

export default function LightProximity({
  reach = 18,     // world units at which darkness is back to max
  minA = 0.05,    // alpha when standing under a light (almost no darkness)
  maxA = 0.96,    // alpha when far from all lights (full darkness)
}: { reach?: number; minA?: number; maxA?: number }) {
  const { scene, camera } = useThree();
  const tmp = useRef(new THREE.Vector3());

  useFrame(() => {
    let bestProx = 0; // 0 = far, 1 = right under a light

    scene.traverse((obj) => {
      const isPoint = (obj as any).isPointLight;
      const isSpot  = (obj as any).isSpotLight;
      const isRect  = (obj as any).isRectAreaLight;
      if (!isPoint && !isSpot && !isRect) return;

      obj.getWorldPosition(tmp.current);

      // distance to the camera
      const d = camera.position.distanceTo(tmp.current);

      // prefer the light‚Äôs own "distance" if provided
      let r = reach;
      const lightDist = (obj as any).distance;
      if (typeof lightDist === "number" && lightDist > 0) {
        r = Math.max(2, Math.min(40, lightDist)); // clamp a bit
      }

      // proximity: 1 near, 0 far
      const prox = 1 - THREE.MathUtils.smoothstep(d, 0, r);
      if (prox > bestProx) bestProx = prox;
    });

    // map proximity -> overlay alpha
    const a = THREE.MathUtils.lerp(maxA, minA, bestProx);
    (window as any).__DARK_ALPHA = THREE.MathUtils.clamp(a, 0, 1);
  });

  return null;
}
</file>

<file path="src/components/ui/MainMenu.tsx">
import React, { useEffect, useMemo, useRef, useState } from "react";

import useAppStore, { GamePhase } from "../../zustand/store";
import { useStarknetConnect } from "../../dojo/hooks/useStarknetConnect";
import { useGameData } from "../../dojo/hooks/useGameData";
import { useInitializePlayer } from "../../dojo/hooks/useInitializePlayer";
import { useStartGame } from "../../dojo/hooks/useStartGame";
import { TutorialVideo } from "./TutorialVideo";

type Move = "up" | "down" | "left" | "right";

const BGM_SRC = "/audio/mainmenu.mp3";

export function MainMenu(): JSX.Element {
    // BGM refs/state
  const bgmRef = useRef<HTMLAudioElement | null>(null);
  const [bgmReady, setBgmReady] = useState(false);
  const [bgmPlaying, setBgmPlaying] = useState(false);

  // Prepare and aggressively autoplay on page load
  useEffect(() => {
    const a = new Audio(BGM_SRC);
    a.loop = true;
    a.preload = "auto";
    a.volume = 0.6;
    a.crossOrigin = "anonymous";
    bgmRef.current = a;

    const onCanPlay = () => setBgmReady(true);
    a.addEventListener("canplaythrough", onCanPlay);

    let unlocked = false;

    const clearUnlockers = () => {
      window.removeEventListener("pointerdown", unlock);
      window.removeEventListener("keydown", unlock);
      window.removeEventListener("touchstart", unlock);
      document.removeEventListener("visibilitychange", onVis);
    };

    const markPlaying = () => {
      if (!unlocked) {
        unlocked = true;
        setBgmPlaying(true);
        clearUnlockers();
      }
    };

    const tryAutoplay = async () => {
      if (!bgmRef.current) return;
      try {
        // Chrome allows muted autoplay; unmute after starting.
        a.muted = true;
        await a.play();
        markPlaying();
        // Unmute shortly after stable start
        setTimeout(() => {
          if (bgmRef.current) bgmRef.current.muted = false;
        }, 150);
      } catch {
        // Autoplay blocked: wait for first user gesture
      }
    };

    const unlock = () => {
      if (!bgmRef.current || unlocked) return;
      // Start with muted= false here; the gesture should permit audio
      bgmRef.current.muted = false;
      bgmRef.current.play().then(markPlaying).catch(() => void 0);
    };

    const onVis = () => {
      if (document.visibilityState === "visible" && !unlocked) {
        tryAutoplay();
      }
    };

    // Attempt immediately if visible; otherwise on first visibility
    if (document.visibilityState === "visible") {
      void tryAutoplay();
    } else {
      document.addEventListener("visibilitychange", onVis);
    }

    // Fallback unlockers if autoplay is blocked
    window.addEventListener("pointerdown", unlock, { once: true });
    window.addEventListener("keydown", unlock, { once: true });
    window.addEventListener("touchstart", unlock, { once: true });

    return () => {
      clearUnlockers();
      a.removeEventListener("canplaythrough", onCanPlay);
      a.pause();
      // @ts-ignore
      bgmRef.current = null;
    };
  }, []);

  // Start on first meaningful click to satisfy autoplay policies
  const ensureBgm = async (): Promise<void> => {
    if (!bgmRef.current || bgmPlaying === true) return;
    try {
      // Some browsers require play() to be directly in a user gesture call chain
      await bgmRef.current.play();
      setBgmPlaying(true);
    } catch {}
  };

  // Fade out BGM and stop
  const stopBgmWithFade = (ms: number = 700): void => {
    const a = bgmRef.current;
    if (!a) return;
    const startVol = a.volume;
    const steps = 14;
    const step = Math.max(1, Math.floor(ms / steps));
    let i = 0;
    const id = setInterval(() => {
      i++;
      const v = Math.max(0, startVol * (1 - i / steps));
      a.volume = v;
      if (i >= steps) {
        clearInterval(id);
        a.pause();
        a.currentTime = 0;
        a.volume = startVol;
        setBgmPlaying(false);
      }
    }, step);
  };

  const { status, address, handleConnect, isConnecting } = useStarknetConnect();
  const { playerStats, isLoading: playerLoading, refetch } = useGameData();
  const {
    initializePlayer,
    isLoading: initializing,
    canInitialize,
  } = useInitializePlayer();
  const { startGame, isLoading: startingGame, canStartGame } = useStartGame();
  const {
    setConnectionStatus,
    setLoading,
    gamePhase,
    player,
    startGame: startGameUI,
  } = useAppStore();

  const isConnected = status === "connected";
  const hasPlayerStats = playerStats !== null;
  const isLoading =
    isConnecting || playerLoading || initializing || startingGame;

  const images = useMemo(
    () => [
      "/bk1.png",
      "/bk2.png",
      "/bk3.png",
      "/bk4.png",
      "/bk5.png",
      "/bk6.png",
    ],
    []
  );
  const [bg, setBg] = useState(0);
  const [dir, setDir] = useState<Move>("up");
  const [showTutorial, setShowTutorial] = useState(false);
    const [hovered, setHovered] = useState<number | null>(null);


  useEffect(() => {
    setConnectionStatus(
      status === "connected"
        ? "connected"
        : isConnecting
        ? "connecting"
        : "disconnected"
    );
  }, [status, isConnecting, setConnectionStatus]);

  useEffect(() => setLoading(isLoading), [isLoading, setLoading]);

  // tiny ambient background swapper
  useEffect(() => {
    const t = setInterval(() => {
      setBg((b) => (b + 1) % images.length);
      setDir((d) => (d === "up" ? "down" : "up"));
    }, 5000);
    return () => clearInterval(t);
  }, [images.length]);

  const canEnterGame = isConnected && hasPlayerStats && !startingGame;
  const gameAlreadyActive =
    gamePhase === GamePhase.ACTIVE || (player as any)?.game_active;

  const handleWalletConnect = async (): Promise<void> => {
    await ensureBgm();
    await handleConnect();
    setTimeout(() => refetch(), 1500);
  };


  const handlePlayerInit = async (): Promise<void> => {
    await ensureBgm();
    const res = await initializePlayer();
    if (res?.success) setTimeout(() => refetch(), 2000);
  };


  const handleStartOrEnterGame = async (): Promise<void> => {
    // Stop menu music before entering the rooms
    stopBgmWithFade(700);

    if (!gameAlreadyActive && canStartGame) {
      try {
        await startGame();
      } catch {}
    }
    startGameUI();
  };

    

  return (
    <div
      style={{
        position: "fixed",
        inset: 0,
        backgroundImage: `url(${images[bg]})`,
        backgroundSize: "cover",
               backgroundPosition: "right center",

      }}
    >
 
          <div
        style={{
          position: "relative",
          height: "100%",
          display: "flex",
          alignItems: "stretch",
          justifyContent: "flex-start",
        }}
      >
        {/* left dark fade panel only (no full overlay) */}
        <div
          style={{
            position: "absolute",
            inset: 0,
            background:
              "linear-gradient(90deg, rgba(0,0,0,0.72) 0%, rgba(0,0,0,0.75) 18%, rgba(0,0,0,0.55) 32%, rgba(0,0,0,0.0) 55%)",
            pointerEvents: "none",
          }}
        />

        {/* left menu column */}
        <div
          style={{
            position: "relative",
            zIndex: 1,
            width: 920,
            padding: "396px 260px",
            display: "flex",
            flexDirection: "column",
            gap: 18,
            color: "white",
            userSelect: "none",
          }}
        >
          

          <div style={{ display: "flex", flexDirection: "column", gap: 16 }}>
            {/* NEW GAME ‚Äî always clickable */}
            <button
              onClick={handleWalletConnect}
              style={{
                all: "unset",
                cursor: "pointer",
                fontSize: 18,
                letterSpacing: 1,
                padding: "2px 0",
              }}
            >
              <span
                style={{
                  background: "#FFFFFF",
                  color: "#000000",
                  borderRadius: 8,
                  padding: "8px 14px",
                  boxShadow: "0 2px 0 rgba(0,0,0,0.35)",
                }}
              >
                NEW GAME
              </span>
            </button>

            {/* CREATE CHARACTER ‚Äî greyed until wallet connected + canInitialize */}
            <button
              onClick={handlePlayerInit}
              disabled={!isConnected || !canInitialize || initializing}
              style={{
                all: "unset",
                cursor:
                  isConnected && canInitialize && !initializing
                    ? "pointer"
                    : "not-allowed",
                fontSize: 18,
                letterSpacing: 1,
                padding: "2px 0",
                color:
                  isConnected && canInitialize && !initializing
                    ? "#FFFFFF"
                    : "rgba(255,255,255,0.45)",
              }}
            >
              CREATE CHARACTER
            </button>

            {/* ENTER THE ROOMS ‚Äî greyed until flow complete */}
            <button
              onClick={handleStartOrEnterGame}
              disabled={!isConnected || !hasPlayerStats || startingGame}
              style={{
                all: "unset",
                cursor:
                  isConnected && hasPlayerStats && !startingGame
                    ? "pointer"
                    : "not-allowed",
                fontSize: 18,
                letterSpacing: 1,
                padding: "2px 0",
                color:
                  isConnected && hasPlayerStats && !startingGame
                    ? "#FFFFFF"
                    : "rgba(255,255,255,0.45)",
              }}
            >
              ENTER THE ROOMS
            </button>

                  {/* TUTORIAL ‚Äî also counts as a user gesture to start BGM */}
            <button
              onClick={() => { void ensureBgm(); }}
              style={{
                all: "unset",
                cursor: "pointer",
                fontSize: 18,
                letterSpacing: 1,
                padding: "2px 0",
                color: "#FFFFFF",
              }}
            >
              TUTORIAL
            </button>


            {/* EXIT GAME */}
            <button
              onClick={() => { void ensureBgm(); /* your exit flow here */ }}
              style={{
                all: "unset",
                cursor: "pointer",
                fontSize: 18,
                letterSpacing: 1,
                padding: "2px 0",
                color: "#FFFFFF",
              }}
            >
              EXIT GAME
            </button>

          </div>
        </div>
      </div>

      {showTutorial && (
        <TutorialVideo
          onEnded={() => {
            setShowTutorial(false);
            // Now reveal the game UI
            startGameUI();
          }}
        />
      )}
    </div>
  );
}

export default MainMenu;
</file>

<file path="src/components/ui/PlayerHUD.tsx">
import React, { useMemo } from "react";
import useAppStore from "../../zustand/store";

/**
 * Exact ‚ÄúBlockroomsCard‚Äù UI, wired to the same data the old HUD used.
 * Pure UI only ‚Äî no gameplay logic changed.
 */
export const PlayerHUD: React.FC = () => {
  // same selectors as the old HUD
  const {
    player,
    gameStats,
    gamePhase,               // kept to mirror old HUD signature (unused visually)
    getActionsRemaining,
    position: playerPosition,
    currentRoom,
    connectionStatus,
  } = useAppStore();

  // keep the same early return as old HUD
  if (!player) return null;

  const actionsLeft = getActionsRemaining();
  const pad = (n: number) => Math.round(n || 0);

  // shortened id, identical to old HUD logic
  const playerShortId = useMemo(
    () => `${player.player_id.slice(0, 6)}...${player.player_id.slice(-4)}`,
    [player.player_id]
  );

  // avatar/feed image (UI only, won‚Äôt break pointer lock)
  const avatarSrc =
    (player as any)?.avatarUrl ??
    "./feed.png";

  // colors
  const C = {
    bgShell: "#0b1216",
    border: "#293941",
    text: "#d0e5ee",
    dim: "#9eb3bb",
    headerBg: "#0d1519",
    ribbonBg: "#162129",
    gold: "#E1CF48",
    ok: "#90EE90",
    warn: "#ffaa00",
    bad: "#ff6666",
    panelBg: "#070a0c",
    label: "#ccc",
    gridGreen: "#7DF17C",
  };

  const healthColor =
    gameStats.currentHealth > gameStats.maxHealth * 0.5
      ? C.ok
      : gameStats.currentHealth > gameStats.maxHealth * 0.25
      ? C.warn
      : C.bad;

  // match the old HUD‚Äôs ‚Äúcurrent room‚Äù behavior; fall back to player.current_room
  const currentRoomId =
    (currentRoom as any)?.room_id?.toString?.() ??
    (player as any)?.current_room?.toString?.() ??
    "-";

  return (
    <div
      style={{
        position: "fixed",
        top: 20,
        left: 20,
        zIndex: 1200,
        fontFamily: "'Joystix', monospace",
        color: C.text,
        pointerEvents: "none",
        transform: "scale(0.7)",
        transformOrigin: "top left",
      }}
    >
      <link href="https://fonts.cdnfonts.com/css/joystix" rel="stylesheet" />

      {/* Card shell */}
      <div
        style={{
          width: 300,
          background: C.bgShell,
          border: `3px solid ${C.border}`,
          boxShadow: "0 0 0 4px #222 inset",
          pointerEvents: "none",
        }}
      >
        {/* Header bar */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "10px 12px",
            borderBottom: `3px solid ${C.border}`,
            background: C.headerBg,
            letterSpacing: 2,
            pointerEvents: "none",
          }}
        >
          <div style={{ fontSize: 18 }}>BLOCKROOMS</div>

          {/* tiny battery/signal cluster */}
          <div
            style={{
              display: "flex",
              alignItems: "center",
              gap: 8,
              color: C.dim,
              fontSize: 7,
            }}
          >
            <span style={{ textTransform: "uppercase" }}>
              {connectionStatus === "connected" ? "" : ""}
            </span>
            <div
              style={{
                width: 36,
                height: 14,
                border: `2px solid ${C.dim}`,
                position: "relative",
                display: "flex",
                gap: 2,
                padding: 2,
              }}
            >
              <div style={{ flex: 1, background: C.dim }} />
              <div style={{ flex: 1, background: C.dim }} />
              <div
                style={{
                  flex: 1,
                  background:
                    connectionStatus === "connected" ? C.dim : "transparent",
                }}
              />
              {/* stub */}
              <div
                style={{
                  position: "absolute",
                  right: -6,
                  top: 3,
                  width: 4,
                  height: 6,
                  background: C.dim,
                }}
              />
            </div>
          </div>
        </div>

        {/* CONNECT ribbon */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "8px 12px",
            background: C.ribbonBg,
            borderBottom: `3px solid ${C.border}`,
            fontSize: 16,
            letterSpacing: 2,
            color: connectionStatus === "connected" ? C.ok : C.warn,
          }}
        >
          <div>IDENTITY</div>
          <div
            style={{
              width: 22,
              height: 18,
              border: `3px solid ${C.dim}`,
              borderRadius: 4,
              position: "relative",
            }}
          >
            <div
              style={{
                position: "absolute",
                right: 4,
                bottom: -6,
                width: 8,
                height: 6,
                borderLeft: `3px solid ${C.dim}`,
                borderBottom: `3px solid ${C.dim}`,
                transform: "skewX(-20deg)",
              }}
            />
          </div>
        </div>

        {/* --- FACE / FEED IMAGE --- */}
        <div
          style={{
            border: `3px solid ${C.border}`,
            background: "#0e1418",
            aspectRatio: "1 / 1",
            position: "relative",
            overflow: "hidden",
            marginBottom: 10,
            pointerEvents: "none",
          }}
        >
          <img
            src={avatarSrc}
            alt="Feed"
            style={{
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter:
                "grayscale(100%) contrast(140%) brightness(95%) sepia(22%) hue-rotate(160deg) saturate(120%)",
              imageRendering: "pixelated" as any,
              pointerEvents: "none",
              userSelect: "none",
            }}
            draggable={false}
          />
        </div>

        {/* Body ‚Äî stacked panes (no clicks to preserve pointer lock) */}
        <div style={{ padding: 10, borderBottom: `3px solid ${C.border}` }}>
          {/* --- PLAYER STATUS --- */}
          <div
            style={{
              border: `3px solid ${C.border}`,
              background: "#0e1418",
              padding: 10,
              marginBottom: 10,
            }}
          >
            <div
              style={{
                fontSize: 14,
                letterSpacing: 2,
                marginBottom: 8,
                color: C.gold,
              }}
            >
              PLAYER STATUS
            </div>

            {/* ID */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>ID: </span>
              <span style={{ color: C.ok }}>{playerShortId}</span>
            </div>

            {/* Health */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Health: </span>
              <span style={{ color: healthColor }}>
                {gameStats.currentHealth}/{gameStats.maxHealth}
              </span>
              <div
                style={{
                  width: 120,
                  height: 8,
                  backgroundColor: "rgba(255,255,255,0.15)",
                  borderRadius: 4,
                  marginTop: 3,
                  overflow: "hidden",
                }}
              >
                <div
                  style={{
                    width: `${
                      (gameStats.currentHealth /
                        Math.max(1, gameStats.maxHealth)) *
                      100
                    }%`,
                    height: "100%",
                    backgroundColor: healthColor,
                    transition: "width 0.25s ease",
                  }}
                />
              </div>
            </div>

            {/* Shards */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Shards: </span>
              <span style={{ color: C.ok }}>{gameStats.currentShards}</span>
            </div>

            {/* Numbered shards */}
            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Special Shards: </span>
              <span style={{ color: C.gold }}>
                {player.has_shard_one ? "‚ë†" : "‚óã"}{" "}
                {player.has_shard_two ? "‚ë°" : "‚óã"}{" "}
                {player.has_shard_three ? "‚ë¢" : "‚óã"}
              </span>
              {gameStats.hasAllNumberedShards && (
                <span style={{ color: C.ok, marginLeft: 6 }}>‚úì COMPLETE</span>
              )}
            </div>

            {/* Key */}
            <div style={{ marginBottom: 0 }}>
              <span style={{ color: C.label }}>Key: </span>
              <span style={{ color: gameStats.hasKey ? C.ok : C.bad }}>
                {gameStats.hasKey ? "YES" : "NO"}
              </span>
            </div>
          </div>

          {/* --- GAME PROGRESS --- */}
          <div
            style={{
              border: `3px solid ${C.border}`,
              background: "#0e1418",
              padding: 10,
              marginBottom: 10,
            }}
          >
            <div
              style={{
                fontSize: 14,
                letterSpacing: 2,
                marginBottom: 8,
                color: C.gold,
              }}
            >
              GAME PROGRESS
            </div>

            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Rooms Cleared: </span>
              <span style={{ color: C.ok }}>{gameStats.roomsCleared}</span>
            </div>

            <div style={{ marginBottom: 6 }}>
              <span style={{ color: C.label }}>Current Room: </span>
              <span style={{ color: C.ok }}>{currentRoomId}</span>
            </div>

            <div>
              <span style={{ color: C.label }}>Actions Left: </span>
              <span style={{ color: C.ok }}>{actionsLeft}</span>
            </div>
          </div>

          {/* --- GRID POSITION --- */}
          <div
            style={{
              border: `3px solid ${C.border}`,
              background: "#0e1418",
              padding: 10,
            }}
          >
            <div
              style={{
                fontSize: 14,
                letterSpacing: 2,
                marginBottom: 8,
                color: C.gold,
              }}
            >
              Grid Position:
            </div>

            <div style={{ marginBottom: 4 }}>
              <span style={{ color: C.gridGreen }}>X:</span>{" "}
              <span style={{ color: C.text }}>{pad(playerPosition.x)}</span>
            </div>
            <div style={{ marginBottom: 4 }}>
              <span style={{ color: C.gridGreen }}>Y:</span>{" "}
              <span style={{ color: C.text }}>{pad(playerPosition.z)}</span>
            </div>
          </div>
        </div>

        {/* Footer strip (tiny) */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: 8,
            padding: "8px 10px",
            color: C.text,
            borderTop: `3px solid ${C.border}`,
            background: C.headerBg,
            letterSpacing: 2,
            fontSize: 11,
          }}
        >
          <span
            style={{
              width: 0,
              height: 0,
              borderLeft: "6px solid transparent",
              borderRight: "6px solid transparent",
              borderBottom: `10px solid ${C.text}`,
              transform: "translateY(2px)",
            }}
          />
          <span>PROPERTY OF KEPLER22BEE GAMING STUDIO</span>
          <span
            style={{
              width: 0,
              height: 0,
              borderLeft: "6px solid transparent",
              borderRight: "6px solid transparent",
              borderBottom: `10px solid ${C.text}`,
              transform: "translateY(2px)",
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default PlayerHUD;
</file>

<file path="src/components/ui/TransactionPopup.tsx">
import React from "react";

interface TransactionPopupProps {
  isVisible: boolean;
  isLoading: boolean;
  error: string | null;
  onClose: () => void;
}

export const TransactionPopup: React.FC<TransactionPopupProps> = ({
  isVisible,
  isLoading,
  error,
  onClose,
}) => {
  if (!isVisible) return null;

  return (
    <div
      style={{
        position: "fixed",
        top: 20,                 // top-right as per new UI
        right: 20,
        zIndex: 3000,
        backgroundColor: "rgba(0, 0, 0, 0.9)",
        border: "2px solid #444",
        borderRadius: 8,
        padding: 20,
        color: "white",
        fontFamily: "monospace",
        minWidth: 300,
        textAlign: "center",
      }}
    >
      {isLoading && (
        <>
          <div style={{ marginBottom: 10, color: "#E1CF48" }}>
            üîÑ Processing Movement Transaction.
          </div>
          <div style={{ fontSize: 12, color: "#ccc" }}>
            Updating blockchain position
          </div>
        </>
      )}

      {error && (
        <>
          <div style={{ marginBottom: 10, color: "#ff6666" }}>
            ‚ùå Transaction Failed
          </div>
          <div style={{ fontSize: 12, color: "#ccc", marginBottom: 15 }}>
            {error}
          </div>
          <div style={{ fontSize: 12, color: "#ffaa00" }}>
            Position reverted to last verified location
          </div>
          <button
            onClick={onClose}
            style={{
              marginTop: 15,
              backgroundColor: "#444",
              color: "white",
              border: "none",
              padding: "8px 16px",
              borderRadius: 4,
              cursor: "pointer",
            }}
          >
            Close
          </button>
        </>
      )}
    </div>
  );
};
</file>

<file path="src/components/ui/TutorialVideo.tsx">
import React, { useEffect, useRef } from "react";

type Props = {
  onEnded: () => void;
  onError?: (err?: unknown) => void;
};

export function TutorialVideo({ onEnded, onError }: Props) {
  const ref = useRef<HTMLVideoElement | null>(null);

  useEffect(() => {
    const v = ref.current;
    if (!v) return;
    const tryPlay = async () => {
      try {
        await v.play();
      } catch {
        // ignore; user already clicked the "Enter Game" button so this should work
      }
    };
    const t = setTimeout(tryPlay, 0);
    return () => clearTimeout(t);
  }, []);

  return (
    <div
      style={{
        position: "fixed",
        inset: 0,
        background: "black",
        zIndex: 9999,
        display: "grid",
        placeItems: "center",
      }}
    >
      <video
        ref={ref}
        src="/tutorial.mp4"
        autoPlay
        playsInline
        style={{ width: "100%", height: "100%", objectFit: "cover" }}
        onEnded={onEnded}
        onError={() => onError?.()}
      />
    </div>
  );
}
</file>

<file path="src/components/ui/WarningPopup.tsx">
import React, { useEffect } from 'react';

interface WarningPopupProps {
  isVisible: boolean;
  onClose: () => void;
}

export const WarningPopup: React.FC<WarningPopupProps> = ({
  isVisible,
  onClose
}) => {
  useEffect(() => {
    if (isVisible) {
      const timer = setTimeout(() => {
        onClose();
      }, 3000); // Auto-close after 3 seconds

      return () => clearTimeout(timer);
    }
  }, [isVisible, onClose]);

  if (!isVisible) return null;

  return (
    <div style={{
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      zIndex: 3000,
      backgroundColor: 'rgba(139, 0, 0, 0.95)',
      border: '2px solid #ff6666',
      borderRadius: '8px',
      padding: '20px',
      color: 'white',
      fontFamily: 'monospace',
      minWidth: '300px',
      textAlign: 'center',
      animation: 'pulse 1s infinite'
    }}>
      <div style={{ marginBottom: '10px', color: '#ff6666', fontSize: '24px' }}>
        ‚ö†Ô∏è WARNING ‚ö†Ô∏è
      </div>
      <div style={{ fontSize: '16px', fontWeight: 'bold' }}>
        BEWARE OF ENEMY!!
      </div>
      <div style={{ fontSize: '12px', color: '#ffcccc', marginTop: '10px' }}>
        This message will close automatically...
      </div>
      
      <style>{`
        @keyframes pulse {
          0% { opacity: 1; }
          50% { opacity: 0.7; }
          100% { opacity: 1; }
        }
      `}</style>
    </div>
  );
};
</file>

<file path="src/config/cartridgeConnector.tsx">
import { Connector } from "@starknet-react/core";
import { ControllerConnector } from "@cartridge/connector";
import { ControllerOptions } from "@cartridge/controller";
import { constants } from "starknet";
import { manifest } from "./manifest";

const { VITE_PUBLIC_DEPLOY_TYPE } = import.meta.env;

console.log("VITE_PUBLIC_DEPLOY_TYPE", VITE_PUBLIC_DEPLOY_TYPE);

const getRpcUrl = () => {
  switch (VITE_PUBLIC_DEPLOY_TYPE) {
    case "localhost":
        return "http://localhost:5050"; // Katana localhost default port
    case "mainnet":
        return "https://api.cartridge.gg/x/starknet/mainnet";
    case "sepolia":
        return "https://api.cartridge.gg/x/starknet/sepolia";
    default:
        return "https://api.cartridge.gg/x/starknet/sepolia";
  }
};

const getDefaultChainId = () => {
  switch (VITE_PUBLIC_DEPLOY_TYPE) {
    case "localhost":
        return "0x4b4154414e41"; // KATANA in ASCII
    case "mainnet":
        return constants.StarknetChainId.SN_MAIN;
    case "sepolia":
        return constants.StarknetChainId.SN_SEPOLIA;
    default:
        return constants.StarknetChainId.SN_SEPOLIA;
  }
};

const getGameContractAddress = () => {
  return manifest.contracts[0].address;

};

const CONTRACT_ADDRESS_GAME = getGameContractAddress();
console.log("Using game contract address:", CONTRACT_ADDRESS_GAME);

const policies = {
  contracts: {
    [CONTRACT_ADDRESS_GAME]: {
      methods: [
        { name: "initialize_player", entrypoint: "initialize_player" },
        { name: "respawn_player", entrypoint: "respawn_player" },
        { name: "start_game", entrypoint: "start_game" },
        { name: "end_game", entrypoint: "end_game" },
        { name: "move_player", entrypoint: "move_player" },
        { name: "attack_entity", entrypoint: "attack_entity" },
        { name: "enter_door", entrypoint: "enter_door" },
        { name: "exit_door", entrypoint: "exit_door" },
        { name: "collect_shard", entrypoint: "collect_shard" },
        { name: "get_entities_in_room", entrypoint: "get_entities_in_room" },
        { name: "get_game_status", entrypoint: "get_game_status" },
        { name: "get_nearby_doors", entrypoint: "get_nearby_doors" },
        { name: "get_player_state", entrypoint: "get_player_state" },
        { name: "get_room_state", entrypoint: "get_room_state" },
        { name: "get_shards_in_room", entrypoint: "get_shards_in_room" },
      ],
    },
  },
}

const options: ControllerOptions = {
  chains: [{ rpcUrl: getRpcUrl() }],
  defaultChainId: getDefaultChainId(),
  policies,
  namespace: "blockrooms",
  slot: "blockrooms",
};

const cartridgeConnector = new ControllerConnector(
  options,
) as never as Connector;

export default cartridgeConnector;
</file>

<file path="src/config/manifest_sepolia.json">
{
  "world": {
    "class_hash": "0x13d92333361bb7049c1232c0a5404e2c19082ededc3a73d75cb33fa952adec7",
    "address": "0x6eec5002d554dae100cdc846a7dfee48bab680f78b7463658da7ed241e2f2a9",
    "seed": "blockrooms11",
    "name": "blockrooms",
    "entrypoints": [
      "uuid",
      "set_metadata",
      "register_namespace",
      "register_event",
      "register_model",
      "register_contract",
      "register_library",
      "init_contract",
      "upgrade_event",
      "upgrade_model",
      "upgrade_contract",
      "emit_event",
      "emit_events",
      "set_entity",
      "set_entities",
      "delete_entity",
      "delete_entities",
      "grant_owner",
      "revoke_owner",
      "grant_writer",
      "revoke_writer",
      "upgrade"
    ],
    "abi": [
      {
        "type": "impl",
        "name": "World",
        "interface_name": "dojo::world::iworld::IWorld"
      },
      {
        "type": "struct",
        "name": "core::byte_array::ByteArray",
        "members": [
          {
            "name": "data",
            "type": "core::array::Array::<core::bytes_31::bytes31>"
          },
          {
            "name": "pending_word",
            "type": "core::felt252"
          },
          {
            "name": "pending_word_len",
            "type": "core::integer::u32"
          }
        ]
      },
      {
        "type": "enum",
        "name": "dojo::world::resource::Resource",
        "variants": [
          {
            "name": "Model",
            "type": "(core::starknet::contract_address::ContractAddress, core::felt252)"
          },
          {
            "name": "Event",
            "type": "(core::starknet::contract_address::ContractAddress, core::felt252)"
          },
          {
            "name": "Contract",
            "type": "(core::starknet::contract_address::ContractAddress, core::felt252)"
          },
          {
            "name": "Namespace",
            "type": "core::byte_array::ByteArray"
          },
          {
            "name": "World",
            "type": "()"
          },
          {
            "name": "Unregistered",
            "type": "()"
          },
          {
            "name": "Library",
            "type": "(core::starknet::class_hash::ClassHash, core::felt252)"
          }
        ]
      },
      {
        "type": "struct",
        "name": "dojo::model::metadata::ResourceMetadata",
        "members": [
          {
            "name": "resource_id",
            "type": "core::felt252"
          },
          {
            "name": "metadata_uri",
            "type": "core::byte_array::ByteArray"
          },
          {
            "name": "metadata_hash",
            "type": "core::felt252"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<core::felt252>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<core::felt252>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<core::array::Span::<core::felt252>>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<core::array::Span::<core::felt252>>"
          }
        ]
      },
      {
        "type": "enum",
        "name": "dojo::model::definition::ModelIndex",
        "variants": [
          {
            "name": "Keys",
            "type": "core::array::Span::<core::felt252>"
          },
          {
            "name": "Id",
            "type": "core::felt252"
          },
          {
            "name": "MemberId",
            "type": "(core::felt252, core::felt252)"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<core::integer::u8>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<core::integer::u8>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "dojo::meta::layout::FieldLayout",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252"
          },
          {
            "name": "layout",
            "type": "dojo::meta::layout::Layout"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<dojo::meta::layout::FieldLayout>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<dojo::meta::layout::FieldLayout>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<dojo::meta::layout::Layout>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<dojo::meta::layout::Layout>"
          }
        ]
      },
      {
        "type": "enum",
        "name": "dojo::meta::layout::Layout",
        "variants": [
          {
            "name": "Fixed",
            "type": "core::array::Span::<core::integer::u8>"
          },
          {
            "name": "Struct",
            "type": "core::array::Span::<dojo::meta::layout::FieldLayout>"
          },
          {
            "name": "Tuple",
            "type": "core::array::Span::<dojo::meta::layout::Layout>"
          },
          {
            "name": "Array",
            "type": "core::array::Span::<dojo::meta::layout::Layout>"
          },
          {
            "name": "ByteArray",
            "type": "()"
          },
          {
            "name": "Enum",
            "type": "core::array::Span::<dojo::meta::layout::FieldLayout>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<dojo::model::definition::ModelIndex>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<dojo::model::definition::ModelIndex>"
          }
        ]
      },
      {
        "type": "enum",
        "name": "core::bool",
        "variants": [
          {
            "name": "False",
            "type": "()"
          },
          {
            "name": "True",
            "type": "()"
          }
        ]
      },
      {
        "type": "interface",
        "name": "dojo::world::iworld::IWorld",
        "items": [
          {
            "type": "function",
            "name": "resource",
            "inputs": [
              {
                "name": "selector",
                "type": "core::felt252"
              }
            ],
            "outputs": [
              {
                "type": "dojo::world::resource::Resource"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "uuid",
            "inputs": [],
            "outputs": [
              {
                "type": "core::integer::u32"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "metadata",
            "inputs": [
              {
                "name": "resource_selector",
                "type": "core::felt252"
              }
            ],
            "outputs": [
              {
                "type": "dojo::model::metadata::ResourceMetadata"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "set_metadata",
            "inputs": [
              {
                "name": "metadata",
                "type": "dojo::model::metadata::ResourceMetadata"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_namespace",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_event",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_model",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_contract",
            "inputs": [
              {
                "name": "salt",
                "type": "core::felt252"
              },
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [
              {
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_library",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              },
              {
                "name": "name",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "version",
                "type": "core::byte_array::ByteArray"
              }
            ],
            "outputs": [
              {
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "init_contract",
            "inputs": [
              {
                "name": "selector",
                "type": "core::felt252"
              },
              {
                "name": "init_calldata",
                "type": "core::array::Span::<core::felt252>"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "upgrade_event",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "upgrade_model",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "upgrade_contract",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [
              {
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "emit_event",
            "inputs": [
              {
                "name": "event_selector",
                "type": "core::felt252"
              },
              {
                "name": "keys",
                "type": "core::array::Span::<core::felt252>"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::felt252>"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "emit_events",
            "inputs": [
              {
                "name": "event_selector",
                "type": "core::felt252"
              },
              {
                "name": "keys",
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "entity",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "index",
                "type": "dojo::model::definition::ModelIndex"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [
              {
                "type": "core::array::Span::<core::felt252>"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "entities",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "indexes",
                "type": "core::array::Span::<dojo::model::definition::ModelIndex>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [
              {
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "set_entity",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "index",
                "type": "dojo::model::definition::ModelIndex"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::felt252>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "set_entities",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "indexes",
                "type": "core::array::Span::<dojo::model::definition::ModelIndex>"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "delete_entity",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "index",
                "type": "dojo::model::definition::ModelIndex"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "delete_entities",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "indexes",
                "type": "core::array::Span::<dojo::model::definition::ModelIndex>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "is_owner",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "address",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [
              {
                "type": "core::bool"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "grant_owner",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "address",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "revoke_owner",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "address",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "owners_count",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              }
            ],
            "outputs": [
              {
                "type": "core::integer::u64"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "is_writer",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "contract",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [
              {
                "type": "core::bool"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "grant_writer",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "contract",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "revoke_writer",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "contract",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          }
        ]
      },
      {
        "type": "impl",
        "name": "UpgradeableWorld",
        "interface_name": "dojo::world::iworld::IUpgradeableWorld"
      },
      {
        "type": "interface",
        "name": "dojo::world::iworld::IUpgradeableWorld",
        "items": [
          {
            "type": "function",
            "name": "upgrade",
            "inputs": [
              {
                "name": "new_class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          }
        ]
      },
      {
        "type": "constructor",
        "name": "constructor",
        "inputs": [
          {
            "name": "world_class_hash",
            "type": "core::starknet::class_hash::ClassHash"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::WorldSpawned",
        "kind": "struct",
        "members": [
          {
            "name": "creator",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::WorldUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::NamespaceRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "hash",
            "type": "core::felt252",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ModelRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::EventRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ContractRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "salt",
            "type": "core::felt252",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ModelUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "prev_address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::EventUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "prev_address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ContractUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ContractInitialized",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "init_calldata",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::LibraryRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::EventEmitted",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "system_address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "key"
          },
          {
            "name": "keys",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::MetadataUpdate",
        "kind": "struct",
        "members": [
          {
            "name": "resource",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "uri",
            "type": "core::byte_array::ByteArray",
            "kind": "data"
          },
          {
            "name": "hash",
            "type": "core::felt252",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreSetRecord",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "keys",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreUpdateRecord",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreUpdateMember",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "member_selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreDelRecord",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::WriterUpdated",
        "kind": "struct",
        "members": [
          {
            "name": "resource",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "contract",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "key"
          },
          {
            "name": "value",
            "type": "core::bool",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::OwnerUpdated",
        "kind": "struct",
        "members": [
          {
            "name": "resource",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "contract",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "key"
          },
          {
            "name": "value",
            "type": "core::bool",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::Event",
        "kind": "enum",
        "variants": [
          {
            "name": "WorldSpawned",
            "type": "dojo::world::world_contract::world::WorldSpawned",
            "kind": "nested"
          },
          {
            "name": "WorldUpgraded",
            "type": "dojo::world::world_contract::world::WorldUpgraded",
            "kind": "nested"
          },
          {
            "name": "NamespaceRegistered",
            "type": "dojo::world::world_contract::world::NamespaceRegistered",
            "kind": "nested"
          },
          {
            "name": "ModelRegistered",
            "type": "dojo::world::world_contract::world::ModelRegistered",
            "kind": "nested"
          },
          {
            "name": "EventRegistered",
            "type": "dojo::world::world_contract::world::EventRegistered",
            "kind": "nested"
          },
          {
            "name": "ContractRegistered",
            "type": "dojo::world::world_contract::world::ContractRegistered",
            "kind": "nested"
          },
          {
            "name": "ModelUpgraded",
            "type": "dojo::world::world_contract::world::ModelUpgraded",
            "kind": "nested"
          },
          {
            "name": "EventUpgraded",
            "type": "dojo::world::world_contract::world::EventUpgraded",
            "kind": "nested"
          },
          {
            "name": "ContractUpgraded",
            "type": "dojo::world::world_contract::world::ContractUpgraded",
            "kind": "nested"
          },
          {
            "name": "ContractInitialized",
            "type": "dojo::world::world_contract::world::ContractInitialized",
            "kind": "nested"
          },
          {
            "name": "LibraryRegistered",
            "type": "dojo::world::world_contract::world::LibraryRegistered",
            "kind": "nested"
          },
          {
            "name": "EventEmitted",
            "type": "dojo::world::world_contract::world::EventEmitted",
            "kind": "nested"
          },
          {
            "name": "MetadataUpdate",
            "type": "dojo::world::world_contract::world::MetadataUpdate",
            "kind": "nested"
          },
          {
            "name": "StoreSetRecord",
            "type": "dojo::world::world_contract::world::StoreSetRecord",
            "kind": "nested"
          },
          {
            "name": "StoreUpdateRecord",
            "type": "dojo::world::world_contract::world::StoreUpdateRecord",
            "kind": "nested"
          },
          {
            "name": "StoreUpdateMember",
            "type": "dojo::world::world_contract::world::StoreUpdateMember",
            "kind": "nested"
          },
          {
            "name": "StoreDelRecord",
            "type": "dojo::world::world_contract::world::StoreDelRecord",
            "kind": "nested"
          },
          {
            "name": "WriterUpdated",
            "type": "dojo::world::world_contract::world::WriterUpdated",
            "kind": "nested"
          },
          {
            "name": "OwnerUpdated",
            "type": "dojo::world::world_contract::world::OwnerUpdated",
            "kind": "nested"
          }
        ]
      }
    ]
  },
  "contracts": [
    {
      "address": "0x20ccd706285e4b09d0a95c612e3e2d45f5d0e6684df48c93e68c4a4a7231ccf",
      "class_hash": "0x2cd77a8fcebd44d4ae58a78d607c90d144ea63500d93d11e8eecf3bc8d01277",
      "abi": [
        {
          "type": "impl",
          "name": "actions__ContractImpl",
          "interface_name": "dojo::contract::interface::IContract"
        },
        {
          "type": "interface",
          "name": "dojo::contract::interface::IContract",
          "items": []
        },
        {
          "type": "impl",
          "name": "actions__DeployedContractImpl",
          "interface_name": "dojo::meta::interface::IDeployedResource"
        },
        {
          "type": "struct",
          "name": "core::byte_array::ByteArray",
          "members": [
            {
              "name": "data",
              "type": "core::array::Array::<core::bytes_31::bytes31>"
            },
            {
              "name": "pending_word",
              "type": "core::felt252"
            },
            {
              "name": "pending_word_len",
              "type": "core::integer::u32"
            }
          ]
        },
        {
          "type": "interface",
          "name": "dojo::meta::interface::IDeployedResource",
          "items": [
            {
              "type": "function",
              "name": "dojo_name",
              "inputs": [],
              "outputs": [
                {
                  "type": "core::byte_array::ByteArray"
                }
              ],
              "state_mutability": "view"
            }
          ]
        },
        {
          "type": "impl",
          "name": "BlockRoomsImpl",
          "interface_name": "blockrooms::systems::actions::IBlockRooms"
        },
        {
          "type": "struct",
          "name": "blockrooms::models::Position",
          "members": [
            {
              "name": "x",
              "type": "core::integer::u32"
            },
            {
              "name": "y",
              "type": "core::integer::u32"
            }
          ]
        },
        {
          "type": "enum",
          "name": "core::bool",
          "variants": [
            {
              "name": "False",
              "type": "()"
            },
            {
              "name": "True",
              "type": "()"
            }
          ]
        },
        {
          "type": "struct",
          "name": "blockrooms::models::Player",
          "members": [
            {
              "name": "player_id",
              "type": "core::starknet::contract_address::ContractAddress"
            },
            {
              "name": "position",
              "type": "blockrooms::models::Position"
            },
            {
              "name": "current_room",
              "type": "core::integer::u32"
            },
            {
              "name": "health",
              "type": "core::integer::u32"
            },
            {
              "name": "max_health",
              "type": "core::integer::u32"
            },
            {
              "name": "shards",
              "type": "core::integer::u32"
            },
            {
              "name": "game_active",
              "type": "core::bool"
            },
            {
              "name": "is_alive",
              "type": "core::bool"
            },
            {
              "name": "current_session_id",
              "type": "core::felt252"
            },
            {
              "name": "rooms_cleared",
              "type": "core::integer::u32"
            },
            {
              "name": "has_shard_one",
              "type": "core::bool"
            },
            {
              "name": "has_shard_two",
              "type": "core::bool"
            },
            {
              "name": "has_shard_three",
              "type": "core::bool"
            },
            {
              "name": "special_ability_cooldown",
              "type": "core::integer::u32"
            },
            {
              "name": "has_key",
              "type": "core::bool"
            }
          ]
        },
        {
          "type": "struct",
          "name": "blockrooms::models::Room",
          "members": [
            {
              "name": "room_id",
              "type": "core::integer::u32"
            },
            {
              "name": "initialized",
              "type": "core::bool"
            },
            {
              "name": "cleared",
              "type": "core::bool"
            },
            {
              "name": "entity_count",
              "type": "core::integer::u32"
            },
            {
              "name": "active_entities",
              "type": "core::integer::u32"
            },
            {
              "name": "has_treasure",
              "type": "core::bool"
            },
            {
              "name": "treasure_collected",
              "type": "core::bool"
            }
          ]
        },
        {
          "type": "enum",
          "name": "blockrooms::models::EntityType",
          "variants": [
            {
              "name": "Male",
              "type": "()"
            },
            {
              "name": "Female",
              "type": "()"
            }
          ]
        },
        {
          "type": "enum",
          "name": "blockrooms::models::NumberedShard",
          "variants": [
            {
              "name": "One",
              "type": "()"
            },
            {
              "name": "Two",
              "type": "()"
            },
            {
              "name": "Three",
              "type": "()"
            }
          ]
        },
        {
          "type": "enum",
          "name": "core::option::Option::<blockrooms::models::NumberedShard>",
          "variants": [
            {
              "name": "Some",
              "type": "blockrooms::models::NumberedShard"
            },
            {
              "name": "None",
              "type": "()"
            }
          ]
        },
        {
          "type": "struct",
          "name": "blockrooms::models::Entity",
          "members": [
            {
              "name": "entity_id",
              "type": "core::felt252"
            },
            {
              "name": "entity_type",
              "type": "blockrooms::models::EntityType"
            },
            {
              "name": "room_id",
              "type": "core::integer::u32"
            },
            {
              "name": "health",
              "type": "core::integer::u32"
            },
            {
              "name": "max_health",
              "type": "core::integer::u32"
            },
            {
              "name": "is_alive",
              "type": "core::bool"
            },
            {
              "name": "damage_per_turn",
              "type": "core::integer::u32"
            },
            {
              "name": "drops_numbered_shard",
              "type": "core::option::Option::<blockrooms::models::NumberedShard>"
            }
          ]
        },
        {
          "type": "enum",
          "name": "blockrooms::models::GameResult",
          "variants": [
            {
              "name": "InProgress",
              "type": "()"
            },
            {
              "name": "Victory",
              "type": "()"
            },
            {
              "name": "Defeat",
              "type": "()"
            }
          ]
        },
        {
          "type": "interface",
          "name": "blockrooms::systems::actions::IBlockRooms",
          "items": [
            {
              "type": "function",
              "name": "initialize_player",
              "inputs": [],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "start_game",
              "inputs": [],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "respawn_player",
              "inputs": [],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "move_player",
              "inputs": [
                {
                  "name": "x_delta",
                  "type": "core::integer::u32"
                },
                {
                  "name": "y_delta",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "attack_entity",
              "inputs": [
                {
                  "name": "entity_id",
                  "type": "core::felt252"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "collect_shard",
              "inputs": [
                {
                  "name": "shard_id",
                  "type": "core::felt252"
                },
                {
                  "name": "room_id",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "exit_door",
              "inputs": [
                {
                  "name": "door_id",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "enter_door",
              "inputs": [
                {
                  "name": "door_id",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "get_shards_in_room",
              "inputs": [
                {
                  "name": "room_id",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [
                {
                  "type": "core::array::Array::<core::felt252>"
                }
              ],
              "state_mutability": "view"
            },
            {
              "type": "function",
              "name": "get_player_state",
              "inputs": [],
              "outputs": [
                {
                  "type": "blockrooms::models::Player"
                }
              ],
              "state_mutability": "view"
            },
            {
              "type": "function",
              "name": "get_room_state",
              "inputs": [
                {
                  "name": "room_id",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [
                {
                  "type": "blockrooms::models::Room"
                }
              ],
              "state_mutability": "view"
            },
            {
              "type": "function",
              "name": "get_entities_in_room",
              "inputs": [
                {
                  "name": "room_id",
                  "type": "core::integer::u32"
                }
              ],
              "outputs": [
                {
                  "type": "core::array::Array::<blockrooms::models::Entity>"
                }
              ],
              "state_mutability": "view"
            },
            {
              "type": "function",
              "name": "get_nearby_doors",
              "inputs": [],
              "outputs": [
                {
                  "type": "core::array::Array::<core::integer::u32>"
                }
              ],
              "state_mutability": "view"
            },
            {
              "type": "function",
              "name": "get_game_status",
              "inputs": [],
              "outputs": [
                {
                  "type": "blockrooms::models::GameResult"
                }
              ],
              "state_mutability": "view"
            },
            {
              "type": "function",
              "name": "end_game",
              "inputs": [],
              "outputs": [],
              "state_mutability": "external"
            }
          ]
        },
        {
          "type": "function",
          "name": "dojo_init",
          "inputs": [],
          "outputs": [],
          "state_mutability": "view"
        },
        {
          "type": "impl",
          "name": "WorldProviderImpl",
          "interface_name": "dojo::contract::components::world_provider::IWorldProvider"
        },
        {
          "type": "struct",
          "name": "dojo::world::iworld::IWorldDispatcher",
          "members": [
            {
              "name": "contract_address",
              "type": "core::starknet::contract_address::ContractAddress"
            }
          ]
        },
        {
          "type": "interface",
          "name": "dojo::contract::components::world_provider::IWorldProvider",
          "items": [
            {
              "type": "function",
              "name": "world_dispatcher",
              "inputs": [],
              "outputs": [
                {
                  "type": "dojo::world::iworld::IWorldDispatcher"
                }
              ],
              "state_mutability": "view"
            }
          ]
        },
        {
          "type": "impl",
          "name": "UpgradeableImpl",
          "interface_name": "dojo::contract::components::upgradeable::IUpgradeable"
        },
        {
          "type": "interface",
          "name": "dojo::contract::components::upgradeable::IUpgradeable",
          "items": [
            {
              "type": "function",
              "name": "upgrade",
              "inputs": [
                {
                  "name": "new_class_hash",
                  "type": "core::starknet::class_hash::ClassHash"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            }
          ]
        },
        {
          "type": "constructor",
          "name": "constructor",
          "inputs": []
        },
        {
          "type": "event",
          "name": "dojo::contract::components::upgradeable::upgradeable_cpt::Upgraded",
          "kind": "struct",
          "members": [
            {
              "name": "class_hash",
              "type": "core::starknet::class_hash::ClassHash",
              "kind": "data"
            }
          ]
        },
        {
          "type": "event",
          "name": "dojo::contract::components::upgradeable::upgradeable_cpt::Event",
          "kind": "enum",
          "variants": [
            {
              "name": "Upgraded",
              "type": "dojo::contract::components::upgradeable::upgradeable_cpt::Upgraded",
              "kind": "nested"
            }
          ]
        },
        {
          "type": "event",
          "name": "dojo::contract::components::world_provider::world_provider_cpt::Event",
          "kind": "enum",
          "variants": []
        },
        {
          "type": "event",
          "name": "blockrooms::systems::actions::actions::Event",
          "kind": "enum",
          "variants": [
            {
              "name": "UpgradeableEvent",
              "type": "dojo::contract::components::upgradeable::upgradeable_cpt::Event",
              "kind": "nested"
            },
            {
              "name": "WorldProviderEvent",
              "type": "dojo::contract::components::world_provider::world_provider_cpt::Event",
              "kind": "nested"
            }
          ]
        }
      ],
      "init_calldata": [],
      "tag": "blockrooms-actions",
      "selector": "0x61254bd76919f4f416c926da2ab20235c225738733258982d08286671d18de1",
      "systems": [
        "initialize_player",
        "start_game",
        "respawn_player",
        "move_player",
        "attack_entity",
        "collect_shard",
        "exit_door",
        "enter_door",
        "end_game",
        "upgrade"
      ]
    }
  ],
  "libraries": [],
  "models": [
    {
      "members": [],
      "class_hash": "0x6ae66a7f0a9aad72e4afbd38c463e9e4c64f8a16615785ddd1f15ba84b866b7",
      "tag": "blockrooms-Entity",
      "selector": "0x1272011998f556eb52985a9e53590089ff39f59ec203e9026f8e2c998d08691"
    },
    {
      "members": [],
      "class_hash": "0x50cadc1fe85cc324c403f5f2de251fc6bfc3d31c6434b04112307b638573138",
      "tag": "blockrooms-EntityState",
      "selector": "0x35eb370e08f9a1e314ec6c5f5cf25dee4a8046fe65f195e02cdde3ab438495d"
    },
    {
      "members": [],
      "class_hash": "0xb65ad880a7d8804b922dcbc21eadac100eb6703f7d4952fe733f591263d55f",
      "tag": "blockrooms-GameConfig",
      "selector": "0x3a0c8dae2a8414f9434133a848d474f69cf1dd365d6f4df0cd969b113b0c6b5"
    },
    {
      "members": [],
      "class_hash": "0x3e0622e14f9e8cf0981bb0436924e6d1cc673a1bf385177bb4285bc3c7f379b",
      "tag": "blockrooms-GameSession",
      "selector": "0x657010e660774d38be04975c9e93606a4f70d3507cf9bb4dcef2861949da77e"
    },
    {
      "members": [],
      "class_hash": "0x51fa804c36a2e9dcbccb961bb624e467bd4463305386d87963c7d00a687f0a7",
      "tag": "blockrooms-Player",
      "selector": "0x3fedb36ca2699d734a292ba7770731415743f643b9c0448fd079c3a5dd8c3c6"
    },
    {
      "members": [],
      "class_hash": "0x890403d9efe04525bd5e3aceb959ea505bd9a34822d14e38432c56cceaaa44",
      "tag": "blockrooms-PlayerStats",
      "selector": "0x3e548c8a1f1ea80e0965dd36a4e0c5a401b2f4cd139e157370688fbb69eb720"
    },
    {
      "members": [],
      "class_hash": "0x2268006477cfcd7887003dfa92c930364406e99f2f2ad0a1726c7d7fab3c684",
      "tag": "blockrooms-Room",
      "selector": "0x763ccee7f5f04191c81cd2620007c11dbb55615d667ec6bb4dd1359cbba94b8"
    },
    {
      "members": [],
      "class_hash": "0x2b38574121bb40eb272b654c9ee970dfdd6a686b0d595bd8cb11f6f04851109",
      "tag": "blockrooms-ShardLocation",
      "selector": "0x51ed4cbf3157867a141ce8056487baf81cc75a4d8326af164df593cce4abacf"
    }
  ],
  "events": [
    {
      "members": [],
      "class_hash": "0xc841971b2aaf9e0e89d1d119f119298d89ba80953e8a9dcfd568dcf8406063",
      "tag": "blockrooms-EntityAttacked",
      "selector": "0x742afe9292d91137a144a1fed14450beed797b547abcf97a06ab1a3d0442491"
    },
    {
      "members": [],
      "class_hash": "0x136969df143f12343dcfe9658a8c4561fd0e620b138bc09d8999e005261d3",
      "tag": "blockrooms-GameCompleted",
      "selector": "0x2555f977bb26694b673a2edda760c9651bbf45c9389efdc30f05cf1083e7676"
    },
    {
      "members": [],
      "class_hash": "0x305bd2a9270fcddad35ae60cd8a4f6d45fe34141cd6e8687a51370b03b9917e",
      "tag": "blockrooms-GameStarted",
      "selector": "0x5e3eb2cdf0e7aad02e3f9008701313437620462fa2130622d62550f0faa9206"
    },
    {
      "members": [],
      "class_hash": "0x21c935e389549c2d91cdf29b98576c79e980c929e7d38bf4e27a6821b40c661",
      "tag": "blockrooms-NumberedShardCollected",
      "selector": "0x21368136dd54582d027c33b9c84bfce1c7760eafbf341d5fb4938549cab5ad2"
    },
    {
      "members": [],
      "class_hash": "0x24d33b0c18a42bcde913162c6e5269df9c64e95fcba985cdc584a64e07c6fde",
      "tag": "blockrooms-PlayerDeath",
      "selector": "0x24bd0fd50c1d9c41f00ab48c442d681b701e11d3d5124ecf35391aafa0e3e2e"
    },
    {
      "members": [],
      "class_hash": "0x13438e509231cb6c546cf0856b5fcadff0c36ebedc48b47e28de9066820e944",
      "tag": "blockrooms-PlayerMoved",
      "selector": "0x2090b879e1f3d74c056d028331a541ef77dc2d5424d4fb8805d8f09b19f6124"
    },
    {
      "members": [],
      "class_hash": "0x35a5e7df06bab0c6ea233ced7eab97cac6fae7a3ce1c9d9bc906f70a07fc97e",
      "tag": "blockrooms-RoomCleared",
      "selector": "0x4512355f3651aa56536863983b3af8f0fe32944aabc03d2ae584120efc703d8"
    },
    {
      "members": [],
      "class_hash": "0x109066c0866def7f739fd4100fb5af622207715e16848f4126c558f9c368882",
      "tag": "blockrooms-RoomEntered",
      "selector": "0x2a1cb1ef9f06019a51394ff2f4c0e77e4d11402a77f8523ac1626527c442973"
    },
    {
      "members": [],
      "class_hash": "0x769479055dd16ef5b895f0d66d1d6ad67e221a6ab63ce7e42689ddfae02795a",
      "tag": "blockrooms-RoomExited",
      "selector": "0x36c698b4dc0a545e854b2ca5e742dffc3afc248ec58ab00f07c46743dd05d67"
    },
    {
      "members": [],
      "class_hash": "0x289092d5d32a6a2465fd0a6a88b70316710538479ff5045cefd56350dcbb4c2",
      "tag": "blockrooms-ShardCollected",
      "selector": "0x1c27f382101c529ac4d15d527a3e653c70877d80bd813fc3092719bfccbe970"
    },
    {
      "members": [],
      "class_hash": "0x4fa757613dc21ae6158f4dc6182f93aa12a5679214c28fc922cce121c47287e",
      "tag": "blockrooms-VictoryAchieved",
      "selector": "0x112183cc3cfea4faa5c62e53d75f6ea6c9d28c50d225d9e35b88fd394b1a2e7"
    }
  ],
  "external_contracts": []
}
</file>

<file path="src/config/manifest.ts">
import sepolia from "./manifest_sepolia.json"; // sepolia manifest
import mainnet from "./manifest_sepolia.json"; // change for the right mainnet manifest
import slot from "./manifest_sepolia.json"; // change for the right slot manifest

// Define valid deploy types
type DeployType = keyof typeof manifests;

// Create the manifests object
const manifests = {

  mainnet,
  sepolia,
  slot,
};

// Get deployment type from environment with fallback
const deployType = import.meta.env.VITE_PUBLIC_DEPLOY_TYPE as string;

// Export the appropriate manifest with a fallback
export const manifest = deployType in manifests
  ? manifests[deployType as DeployType]
  : sepolia;

export type Manifest = typeof manifest;
</file>

<file path="src/context/game-context.tsx">
import type React from "react"

import { createContext, useContext, useReducer, type ReactNode } from "react"

interface GameState {
  connected: boolean
  level: number
  experience: number
  maxExp: number
  health: number
  coins: number
  address: string | null
  isLoading: boolean
  txStatus: {
    message: string
    type: "pending" | "success" | "error" | null
  }
  achievement: string | null
}

type GameAction =
  | { type: "CONNECT_WALLET_START" }
  | { type: "CONNECT_WALLET_SUCCESS"; address: string }
  | { type: "TRAIN_PLAYER" }
  | { type: "MINE_COINS" }
  | { type: "REST_PLAYER" }
  | { type: "SET_TX_STATUS"; message: string; txType: "pending" | "success" | "error" }
  | { type: "CLEAR_TX_STATUS" }
  | { type: "SHOW_ACHIEVEMENT"; achievement: string }
  | { type: "CLEAR_ACHIEVEMENT" }

const initialState: GameState = {
  connected: false,
  level: 1,
  experience: 0,
  maxExp: 100,
  health: 100,
  coins: 0,
  address: null,
  isLoading: false,
  txStatus: { message: "", type: null },
  achievement: null,
}

function gameReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case "CONNECT_WALLET_START":
      return { ...state, isLoading: true }

    case "CONNECT_WALLET_SUCCESS":
      return {
        ...state,
        connected: true,
        address: action.address,
        isLoading: false,
      }

    case "TRAIN_PLAYER":
      const newExp = state.experience + 10
      const levelUp = newExp >= state.maxExp
      return {
        ...state,
        experience: levelUp ? 0 : newExp,
        level: levelUp ? state.level + 1 : state.level,
        maxExp: levelUp ? state.maxExp + 50 : state.maxExp,
        achievement: levelUp ? `Level ${state.level + 1} Reached!` : state.achievement,
      }

    case "MINE_COINS":
      const newCoins = state.coins + 5
      return {
        ...state,
        coins: newCoins,
        health: Math.max(0, state.health - 5),
        achievement: newCoins >= 50 && state.coins < 50 ? "Wealthy Miner!" : state.achievement,
      }

    case "REST_PLAYER":
      return {
        ...state,
        health: Math.min(100, state.health + 20),
      }

    case "SET_TX_STATUS":
      return {
        ...state,
        txStatus: { message: action.message, type: action.txType },
      }

    case "CLEAR_TX_STATUS":
      return {
        ...state,
        txStatus: { message: "", type: null },
      }

    case "SHOW_ACHIEVEMENT":
      return {
        ...state,
        achievement: action.achievement,
      }

    case "CLEAR_ACHIEVEMENT":
      return {
        ...state,
        achievement: null,
      }

    default:
      return state
  }
}

const GameContext = createContext<{
  state: GameState
  dispatch: React.Dispatch<GameAction>
} | null>(null)

export function GameProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(gameReducer, initialState)

  return <GameContext.Provider value={{ state, dispatch }}>{children}</GameContext.Provider>
}

export function useGame() {
  const context = useContext(GameContext)
  if (!context) {
    throw new Error("useGame must be used within a GameProvider")
  }
  return context
}
</file>

<file path="src/dojo/contracts.gen.ts">
import { DojoProvider, DojoCall } from "@dojoengine/core";
import { Account, AccountInterface, BigNumberish, CairoOption, CairoCustomEnum, ByteArray } from "starknet";
import * as models from "./models.gen";

export function setupWorld(provider: DojoProvider) {

	const build_actions_attackEntity_calldata = (entityId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "attack_entity",
			calldata: [entityId],
		};
	};

	const actions_attackEntity = async (snAccount: Account | AccountInterface, entityId: BigNumberish) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_attackEntity_calldata(entityId),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_collectShard_calldata = (shardId: BigNumberish, roomId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "collect_shard",
			calldata: [shardId, roomId],
		};
	};

	const actions_collectShard = async (snAccount: Account | AccountInterface, shardId: BigNumberish, roomId: BigNumberish) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_collectShard_calldata(shardId, roomId),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_endGame_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "end_game",
			calldata: [],
		};
	};

	const actions_endGame = async (snAccount: Account | AccountInterface) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_endGame_calldata(),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_enterDoor_calldata = (doorId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "enter_door",
			calldata: [doorId],
		};
	};

	const actions_enterDoor = async (snAccount: Account | AccountInterface, doorId: BigNumberish) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_enterDoor_calldata(doorId),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_exitDoor_calldata = (doorId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "exit_door",
			calldata: [doorId],
		};
	};

	const actions_exitDoor = async (snAccount: Account | AccountInterface, doorId: BigNumberish) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_exitDoor_calldata(doorId),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_getEntitiesInRoom_calldata = (roomId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "get_entities_in_room",
			calldata: [roomId],
		};
	};

	const actions_getEntitiesInRoom = async (roomId: BigNumberish) => {
		try {
			return await provider.call("blockrooms", build_actions_getEntitiesInRoom_calldata(roomId));
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_getGameStatus_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "get_game_status",
			calldata: [],
		};
	};

	const actions_getGameStatus = async () => {
		try {
			return await provider.call("blockrooms", build_actions_getGameStatus_calldata());
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_getNearbyDoors_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "get_nearby_doors",
			calldata: [],
		};
	};

	const actions_getNearbyDoors = async () => {
		try {
			return await provider.call("blockrooms", build_actions_getNearbyDoors_calldata());
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_getPlayerState_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "get_player_state",
			calldata: [],
		};
	};

	const actions_getPlayerState = async () => {
		try {
			return await provider.call("blockrooms", build_actions_getPlayerState_calldata());
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_getRoomState_calldata = (roomId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "get_room_state",
			calldata: [roomId],
		};
	};

	const actions_getRoomState = async (roomId: BigNumberish) => {
		try {
			return await provider.call("blockrooms", build_actions_getRoomState_calldata(roomId));
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_getShardsInRoom_calldata = (roomId: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "get_shards_in_room",
			calldata: [roomId],
		};
	};

	const actions_getShardsInRoom = async (roomId: BigNumberish) => {
		try {
			return await provider.call("blockrooms", build_actions_getShardsInRoom_calldata(roomId));
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_initializePlayer_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "initialize_player",
			calldata: [],
		};
	};

	const actions_initializePlayer = async (snAccount: Account | AccountInterface) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_initializePlayer_calldata(),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_movePlayer_calldata = (xDelta: BigNumberish, yDelta: BigNumberish): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "move_player",
			calldata: [xDelta, yDelta],
		};
	};

	const actions_movePlayer = async (snAccount: Account | AccountInterface, xDelta: BigNumberish, yDelta: BigNumberish) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_movePlayer_calldata(xDelta, yDelta),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_respawnPlayer_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "respawn_player",
			calldata: [],
		};
	};

	const actions_respawnPlayer = async (snAccount: Account | AccountInterface) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_respawnPlayer_calldata(),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};

	const build_actions_startGame_calldata = (): DojoCall => {
		return {
			contractName: "actions",
			entrypoint: "start_game",
			calldata: [],
		};
	};

	const actions_startGame = async (snAccount: Account | AccountInterface) => {
		try {
			return await provider.execute(
				snAccount,
				build_actions_startGame_calldata(),
				"blockrooms",
			);
		} catch (error) {
			console.error(error);
			throw error;
		}
	};



	return {
		actions: {
			attackEntity: actions_attackEntity,
			buildAttackEntityCalldata: build_actions_attackEntity_calldata,
			collectShard: actions_collectShard,
			buildCollectShardCalldata: build_actions_collectShard_calldata,
			endGame: actions_endGame,
			buildEndGameCalldata: build_actions_endGame_calldata,
			enterDoor: actions_enterDoor,
			buildEnterDoorCalldata: build_actions_enterDoor_calldata,
			exitDoor: actions_exitDoor,
			buildExitDoorCalldata: build_actions_exitDoor_calldata,
			getEntitiesInRoom: actions_getEntitiesInRoom,
			buildGetEntitiesInRoomCalldata: build_actions_getEntitiesInRoom_calldata,
			getGameStatus: actions_getGameStatus,
			buildGetGameStatusCalldata: build_actions_getGameStatus_calldata,
			getNearbyDoors: actions_getNearbyDoors,
			buildGetNearbyDoorsCalldata: build_actions_getNearbyDoors_calldata,
			getPlayerState: actions_getPlayerState,
			buildGetPlayerStateCalldata: build_actions_getPlayerState_calldata,
			getRoomState: actions_getRoomState,
			buildGetRoomStateCalldata: build_actions_getRoomState_calldata,
			getShardsInRoom: actions_getShardsInRoom,
			buildGetShardsInRoomCalldata: build_actions_getShardsInRoom_calldata,
			initializePlayer: actions_initializePlayer,
			buildInitializePlayerCalldata: build_actions_initializePlayer_calldata,
			movePlayer: actions_movePlayer,
			buildMovePlayerCalldata: build_actions_movePlayer_calldata,
			respawnPlayer: actions_respawnPlayer,
			buildRespawnPlayerCalldata: build_actions_respawnPlayer_calldata,
			startGame: actions_startGame,
			buildStartGameCalldata: build_actions_startGame_calldata,
		},
	};
}
</file>

<file path="src/dojo/dojoConfig.ts">
import { createDojoConfig } from "@dojoengine/core";

import { manifest } from "../config/manifest";

const {
    VITE_PUBLIC_NODE_URL,
    VITE_PUBLIC_TORII,
    VITE_PUBLIC_MASTER_ADDRESS,
    VITE_PUBLIC_MASTER_PRIVATE_KEY,
  } = import.meta.env;

export const dojoConfig = createDojoConfig({
    manifest,
    masterAddress: VITE_PUBLIC_MASTER_ADDRESS || '',
    masterPrivateKey: VITE_PUBLIC_MASTER_PRIVATE_KEY || '',
    rpcUrl: VITE_PUBLIC_NODE_URL || '',
    toriiUrl: VITE_PUBLIC_TORII || '',
});
</file>

<file path="src/dojo/hooks/fetchNearbyDoors.tsx">
import { useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface GetNearbyDoorsState {
  isLoading: boolean;
  error: string | null;
  doors: any[] | null;
}

interface GetNearbyDoorsResult {
  success: boolean;
  doors?: any[];
  error?: string;
}

export const useGetNearbyDoors = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();
  
  const { 
    setError,
    setActionInProgress,
    setLoading,
    setNearbyDoors,
    actionInProgress,
    gamePhase,
    player,
    canTakeActions
  } = useAppStore();

  const [state, setState] = useState<GetNearbyDoorsState>({
    isLoading: false,
    error: null,
    doors: null
  });

  const getNearbyDoors = useCallback(async (): Promise<GetNearbyDoorsResult> => {
    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already loading doors" };
    }

    // Validate connection
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player can take actions
    if (!canTakeActions) {
      const error = "Cannot check doors at this time";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player exists and game is active
    if (!player || gamePhase !== GamePhase.ACTIVE) {
      const error = "Game is not active";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player is alive
    if (!player.is_alive) {
      const error = "Player is not alive";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);

    try {
      console.log(`üö™ Getting nearby doors...`);
      
      const result = await client.actions.getNearbyDoors();
      console.log("üö™ result", result);
      if (!result) {
        throw new Error("No result received from getNearbyDoors");
      }

      // Parse the result - adjust based on actual return format
      const doors = Array.isArray(result) ? result : result.doors || [];

      setState(prev => ({ ...prev, doors, isLoading: false }));
      setNearbyDoors(doors); // Update Zustand store
      
      console.log("‚úÖ Nearby doors retrieved successfully!", doors);
      
      setActionInProgress(false);
      setLoading(false);
      
      return { 
        success: true, 
        doors 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to get nearby doors";
      
      console.error("‚ùå Get nearby doors failed:", error);
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [
    state.isLoading,
    actionInProgress,
    status,
    account,
    client,
    refetchPlayer,
    setError,
    setActionInProgress,
    setLoading,
    player,
    gamePhase,
    canTakeActions
  ]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, doors: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    doors: state.doors,
    isConnected: status === "connected",
    canCheckDoors: canTakeActions,
    actionInProgress,
    getNearbyDoors,
    reset,
    hasNearbyDoors: (state.doors && state.doors.length > 0) || false,
  };

};
</file>

<file path="src/dojo/hooks/useAttackEntity.tsx">
import { useState, useCallback, useRef, useEffect } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface AttackEntityState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface AttackEntityResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useAttackEntity = () => {
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { client } = useDojoSDK();
  const { refetch: refetchGameData } = useGameData();
  

  const { 
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    canAttack,
    getEntitiesInCurrentRoom,
    getEntityById
  } = useAppStore();

  const [state, setState] = useState<AttackEntityState>({
    isLoading: false,
    error: null,
    txHash: null
  });
  const mountedRef = useRef(true);

  useEffect(() => {
    return () => {
      mountedRef.current = false;
    };
  }, []);
  const attackEntity = useCallback(async (entityId: string): Promise<AttackEntityResult> => {
 
    console.log("Step 1");
    
    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already performing action" };
    }
    console.log("Step 2");
    // Validate connection
    console.log("status", status);
  console.log("account", account);
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }
    console.log("Step 3");
    // Check if player can attack
    if (!canAttack()) {
      const error = "Cannot attack at this time";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }
    console.log("Step 4");
    // Check if player exists and game is active
    if (!player || gamePhase !== GamePhase.ACTIVE) {
      const error = "Game is not active";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Validate entity exists and is in current room
    const entity = getEntityById(entityId);
    if (!entity) {
      const error = "Entity not found";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    if (!entity.is_alive) {
      const error = "Entity is already dead";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    const entitiesInRoom = getEntitiesInCurrentRoom();
    const isEntityInRoom = entitiesInRoom.some(e => e.entity_id.toString() === entityId);
    if (!isEntityInRoom) {
      const error = "Entity is not in current room";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }
    
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);

    try {
      console.log(`‚öîÔ∏è Attacking entity ${entityId}...`);
    
      const tx = await client.actions.attackEntity(
        account as Account,
        entityId
      );      
      
      if (!tx?.transaction_hash) {
        throw new Error("No transaction hash received");
      }

      setState(prev => ({ ...prev, txHash: tx.transaction_hash }));
      setLastTransaction(tx.transaction_hash);

      // Wait for transaction processing
      console.log("‚è≥ Processing attack...");
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Refetch game data to update entity states and player stats
      console.log("üîÑ Refetching game data...");
      await refetchGameData();
      
      console.log("‚úÖ Attack completed successfully!");
      
      setState(prev => ({ ...prev, isLoading: false }));
      setActionInProgress(false);
      setLoading(false);
      
      return { 
        success: true, 
        transactionHash: tx.transaction_hash 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to attack entity";
      
      console.error("‚ùå Attack failed:", error);
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [ 
    actionInProgress,
    status,
    account,
    client,
    refetchGameData,
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    player,
    gamePhase,
    canAttack,
    getEntitiesInCurrentRoom,
    getEntityById
  ]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canAttackEntity: canAttack(),
    actionInProgress,
    entitiesInCurrentRoom: getEntitiesInCurrentRoom(),
    attackEntity,
    reset
  };
};
</file>

<file path="src/dojo/hooks/useCollectShard.tsx">
import { useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";
import * as models from "../../dojo/models.gen";

interface CollectShardState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface CollectShardResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useCollectShard = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();
  
  const { 
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    currentRoom,
    getShardsInCurrentRoom
  } = useAppStore();

  const [state, setState] = useState<CollectShardState>({
    isLoading: false,
    error: null,
    txHash: null
  });

  const collectShard = useCallback(async (shardId: string): Promise<CollectShardResult> => {
    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already collecting" };
    }

    // Validate connection
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player exists and game is active
    if (!player || gamePhase !== GamePhase.ACTIVE) {
      const error = "Game is not active";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player is alive
    if (!player.is_alive) {
      const error = "Player is not alive";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if current room exists
    if (!currentRoom) {
      const error = "No current room found";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Validate shard exists in current room and is not collected
    const shardsInRoom = getShardsInCurrentRoom();
    const shard = shardsInRoom.find(s => s.shard_id.toString() === shardId);
    
    if (!shard) {
      const error = "Shard not found in current room";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    if (shard.collected) {
      const error = "Shard has already been collected";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);

    try {
      console.log(`üíé Collecting shard ${shardId} in room ${currentRoom.room_id}...`);
      
      const tx = await client.actions.collectShard(
        account as Account, 
        shard.shard_id, 
        currentRoom.room_id
      );
      
      if (!tx?.transaction_hash) {
        throw new Error("No transaction hash received");
      }

      setState(prev => ({ ...prev, txHash: tx.transaction_hash }));
      setLastTransaction(tx.transaction_hash);

      // Wait for transaction processing
      console.log("‚è≥ Processing shard collection...");
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Refetch player data
      console.log("üîÑ Refetching player data...");
      await refetchPlayer();
      
      console.log("‚úÖ Shard collected successfully!");
      
      setState(prev => ({ ...prev, isLoading: false }));
      setActionInProgress(false);
      setLoading(false);
      
      return { 
        success: true, 
        transactionHash: tx.transaction_hash 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to collect shard";
      
      console.error("‚ùå Shard collection failed:", error);
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [
    state.isLoading,
    actionInProgress,
    status,
    account,
    client,
    refetchPlayer,
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    player,
    gamePhase,
    currentRoom,
    getShardsInCurrentRoom
  ]);

  const canCollectShard = useCallback((shardId: string): boolean => {
    if (!player || !currentRoom || gamePhase !== GamePhase.ACTIVE || !player.is_alive) {
      return false;
    }

    const shardsInRoom = getShardsInCurrentRoom();
    const shard = shardsInRoom.find(s => s.shard_id.toString() === shardId);
    
    return shard !== undefined && !shard.collected && !actionInProgress;
  }, [player, currentRoom, gamePhase, getShardsInCurrentRoom, actionInProgress]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canCollectShard,
    actionInProgress,
    collectShard,
    reset,
    availableShards: getShardsInCurrentRoom()
  };
};
</file>

<file path="src/dojo/hooks/useDoor.tsx">
import { useState, useCallback, useRef, useEffect } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface OpenDoorState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface OpenDoorResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useOpenDoor = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();

  const {
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    currentRoom,
    canMove,
  } = useAppStore();

  const [state, setState] = useState<OpenDoorState>({
    isLoading: false,
    error: null,
    txHash: null,
  });

  const mountedRef = useRef(true);

  useEffect(() => {
    return () => {
      mountedRef.current = false;
    };
  }, []);

  const executeAction = useCallback(
    async (
      actionType: "enter" | "exit",
      doorId: string
    ): Promise<OpenDoorResult> => {
      if (state.isLoading || actionInProgress) {
        return {
          success: false,
          error: `Already ${
            actionType === "enter" ? "entering" : "exiting"
          } door`,
        };
      }
      console.log("status", status);
      console.log("account", account);
      // Validate connection
      if (status !== "connected" || !account) {
        const error = "Wallet not connected. Please connect your wallet first.";
        setState((prev) => ({ ...prev, error }));
        setError(error);
        return { success: false, error };
      }

      // Check if player exists and game is active
      if (!player || gamePhase !== GamePhase.ACTIVE) {
        const error = "Game is not active";
        setState((prev) => ({ ...prev, error }));
        setError(error);
        return { success: false, error };
      }

      if (!player.is_alive) {
        const error = "Player is not alive";
        setState((prev) => ({ ...prev, error }));
        setError(error);
        return { success: false, error };
      }

      // Action-specific validations
      if (actionType === "enter") {
        if (currentRoom !== null) {
          const error = "Already in a room";
          setState((prev) => ({ ...prev, error }));
          setError(error);
          return { success: false, error };
        }
      } else if (actionType === "exit") {
        if (!currentRoom?.cleared) {
          const error = "Cannot exit - room not cleared";
          setState((prev) => ({ ...prev, error }));
          setError(error);
          return { success: false, error };
        }
      }

      setState((prev) => ({ ...prev, isLoading: true, error: null }));
      setActionInProgress(true);
      setLoading(true);
      setError(null);

      try {
        console.log(
          `üö™ ${
            actionType === "enter" ? "Entering" : "Exiting"
          } door ${doorId}...`
        );

        const tx =
          actionType === "enter"
            ? await client.actions.enterDoor(account as Account, doorId)
            : await client.actions.exitDoor(account as Account, doorId);

        if (!tx?.transaction_hash) {
          throw new Error("No transaction hash received");
        }

        setState((prev) => ({ ...prev, txHash: tx.transaction_hash }));
        setLastTransaction(tx.transaction_hash);

        // Wait for transaction processing
        console.log(`‚è≥ Processing door ${actionType}...`);
        await new Promise((resolve) => setTimeout(resolve, 2000));

        // Refetch player data
        console.log("üîÑ Refetching player data...");
        await refetchPlayer();

        console.log(`‚úÖ Door ${actionType} successful! ${tx.transaction_hash}`);

        setState((prev) => ({ ...prev, isLoading: false }));
        setActionInProgress(false);
        setLoading(false);

        return {
          success: true,
          transactionHash: tx.transaction_hash,
        };
      } catch (error) {
        const errorMessage =
          error instanceof Error
            ? error.message
            : `Failed to ${actionType} door`;

        console.error(`‚ùå Door ${actionType} failed:`, error);

        setState((prev) => ({
          ...prev,
          error: errorMessage,
          isLoading: false,
        }));
        setError(errorMessage);
        setActionInProgress(false);
        setLoading(false);

        return { success: false, error: errorMessage };
      }
    },
    [
      state.isLoading,
      actionInProgress,
      status,
      account,
      client,
      refetchPlayer,
      setError,
      setActionInProgress,
      setLastTransaction,
      setLoading,
      player,
      gamePhase,
      currentRoom,
    ]
  );

  const enterDoor = useCallback(
    (doorId: string) => {
      return executeAction("enter", doorId);
    },
    [executeAction]
  );

  const exitDoor = useCallback(
    (doorId: string) => {
      return executeAction("exit", doorId);
    },
    [executeAction]
  );

  const canEnterDoor = useCallback((): boolean => {
    return (
      player?.is_alive === true &&
      gamePhase === GamePhase.ACTIVE &&
      currentRoom === null &&
      !actionInProgress &&
      !state.isLoading
    );
  }, [
    player?.is_alive,
    gamePhase,
    currentRoom,
    actionInProgress,
    state.isLoading,
  ]);

  const canExitDoor = useCallback((): boolean => {
    return (
      player?.is_alive === true &&
      gamePhase === GamePhase.ACTIVE &&
      currentRoom?.cleared === true &&
      !actionInProgress &&
      !state.isLoading
    );
  }, [
    player?.is_alive,
    gamePhase,
    currentRoom?.cleared,
    actionInProgress,
    state.isLoading,
  ]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canEnterDoor: canEnterDoor(),
    canExitDoor: canExitDoor(),
    actionInProgress,
    enterDoor,
    exitDoor,
    reset,
  };
};
</file>

<file path="src/dojo/hooks/useEndGame.tsx">
import { useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface EndGameState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface EndGameResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useEndGame = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();
  
  const { 
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    gameSession,
    endGame: updateGamePhase,
    setGamePhase
  } = useAppStore();

  const [state, setState] = useState<EndGameState>({
    isLoading: false,
    error: null,
    txHash: null
  });

  const endGame = useCallback(async (): Promise<EndGameResult> => {
    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already ending game" };
    }

    // Validate connection
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player exists
    if (!player) {
      const error = "Player not found";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if game is in valid state to end
    if (gamePhase === GamePhase.UNINITIALIZED) {
      const error = "Game has not been initialized";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    if (gamePhase === GamePhase.COMPLETED || gamePhase === GamePhase.GAME_OVER) {
      const error = "Game has already ended";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player has an active game session
    if (!player.game_active) {
      const error = "No active game to end";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if game session exists
    if (!gameSession) {
      const error = "Game session not found";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if session is already complete
    if (gameSession.session_complete) {
      const error = "Game session is already complete";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);

    try {
      console.log("üèÅ Ending game...");
      
      const tx = await client.actions.endGame(account as Account);
      
      if (!tx?.transaction_hash) {
        throw new Error("No transaction hash received");
      }

      setState(prev => ({ ...prev, txHash: tx.transaction_hash }));
      setLastTransaction(tx.transaction_hash);

      // Wait for transaction processing
      console.log("‚è≥ Processing game end...");
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Update local game phase immediately
      console.log("üéÆ Updating game phase to completed...");
      setGamePhase(GamePhase.COMPLETED);
      updateGamePhase();
      
      // Refetch player data to get final state
      console.log("üîÑ Refetching final game data...");
      await refetchPlayer();
      
      console.log("‚úÖ Game ended successfully!");
      
      setState(prev => ({ ...prev, isLoading: false }));
      setActionInProgress(false);
      setLoading(false);
      
      return { 
        success: true, 
        transactionHash: tx.transaction_hash 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to end game";
      
      console.error("‚ùå Game end failed:", error);
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [
    state.isLoading,
    actionInProgress,
    status,
    account,
    client,
    refetchPlayer,
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    player,
    gamePhase,
    gameSession,
    updateGamePhase,
    setGamePhase
  ]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  const canEndGame = useCallback(() => {
    return (
      status === "connected" &&
      player &&
      player.game_active &&
      gameSession &&
      !gameSession.session_complete &&
      (gamePhase === GamePhase.ACTIVE || gamePhase === GamePhase.INITIALIZED) &&
      !actionInProgress
    );
  }, [status, player, gameSession, gamePhase, actionInProgress]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canEndGame: canEndGame(),
    actionInProgress,
    endGame,
    reset
  };
};
</file>

<file path="src/dojo/hooks/useGameData.tsx">
import { useEffect, useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { addAddressPadding } from "starknet";
import { dojoConfig } from "../dojoConfig";

import * as models from "../models.gen";
import useAppStore, { GamePhase } from '../../zustand/store';

interface UseGameDataReturn {
  player: models.Player | null;
  playerStats: models.PlayerStats | null;
  gameSession: models.GameSession | null;
  gameConfig: models.GameConfig | null;
  currentRoom: models.Room | null;
  entities: models.Entity[];
  shardLocations: models.ShardLocation[];
  isLoading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
  gamePhase: GamePhase;
  gameStats: {
    currentHealth: number;
    maxHealth: number;
    currentShards: number;
    roomsCleared: number;
    hasAllNumberedShards: boolean;
    hasKey: boolean;
    isAlive: boolean;
    gameActive: boolean;
    specialAbilityCooldown: number;
  };
  canMove: boolean;
  canAttack: boolean;
  isPlayerInitialized: boolean;
}

const TORII_URL = dojoConfig.toriiUrl + "/graphql";

const PLAYER_QUERY = `
  query GetPlayerData($playerAddress: ContractAddress!) {
    blockroomsPlayerModels(where: {player_id: $playerAddress}) {
      edges {
        node {
          player_id
          position {
            x
            y 
          }
          current_room
          health
          max_health
          shards
          game_active
          is_alive
          current_session_id
          rooms_cleared 
          has_shard_one
          has_shard_two
          has_shard_three  
          special_ability_cooldown
          has_key
        }
      }
    }
    blockroomsPlayerStatsModels(where: {player_id: $playerAddress}) {
      edges {
        node {
          player_id
          games_played
          games_won
          total_shards_collected
          total_entities_defeated
          total_playtime
          best_completion_time
          highest_room_reached
          total_damage_dealt
          total_damage_taken
          doors_opened 
          total_actions_taken
          numbered_shards_collected
        }
      }
    }
    blockroomsGameSessionModels(where: {player_id: $playerAddress}) {
      edges {
        node {
          session_id
          player_id
          start_time
          end_time
          rooms_cleared
          total_shards_collected
          numbered_shards_collected
          entities_defeated
          total_damage_dealt
          total_damage_taken
          doors_opened
          deaths
          session_complete 
          total_actions
          victory_achieved
        }
      }
    }
    blockroomsGameConfigModels {
      edges {
        node {
          config_id
          grid_size
          starting_health
          starting_shards
          base_damage 
          entity_spawn_rate
          shard_drop_rate
          male_entity_damage
          female_entity_damage
          door_detection_range
        }
      }
    }
    blockroomsRoomModels {
      edges {
        node {
          room_id
          initialized
          cleared
          entity_count
          active_entities
          has_treasure
          treasure_collected 
        }
      }
    }
    blockroomsEntityModels {
      edges {
        node {
          entity_id
          room_id
          entity_type 
          health
          max_health
          is_alive
          damage_per_turn
          drops_numbered_shard {
            option
          } 
        }
      }
    }
    blockroomsShardLocationModels {
      edges {
        node {
          shard_id 
          room_id
          numbered_shard {
            option
          }
          collected
        }
      }
    }
  }
`;

// Utility functions
const parseNumber = (value: any): number => {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') {
    return value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
  }
  return 0;
};

const parsePosition = (pos: any): models.Position => ({
  x: parseNumber(pos?.x || 0),
  y: parseNumber(pos?.y || 0),
});

const parseCairoOption = (option: any) => {
  if (!option || !option.option) return null;
  return option.option;
};

const parseCairoEnum = (enumValue: any) => {
  if (!enumValue) return null;
  return enumValue;
};

const fetchPlayerData = async (playerAddress: string) => {
  const response = await fetch(TORII_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ 
      query: PLAYER_QUERY,
      variables: { playerAddress }
    }),
  });

  if (!response.ok) {
    throw new Error(`GraphQL request failed: ${response.status}`);
  }

  const result = await response.json();
  
  if (result.errors) {
    throw new Error(`GraphQL errors: ${result.errors.map((e: any) => e.message).join(', ')}`);
  }

  const data = result.data;
  if (!data) return null;

  console.log("GraphQL data:", data);

  // Parse all the data
  const playerNode = data.blockroomsPlayerModels?.edges?.[0]?.node;
  const playerStatsNode = data.blockroomsPlayerStatsModels?.edges?.[0]?.node;
  const gameSessionNode = data.blockroomsGameSessionModels?.edges?.[0]?.node;
  const gameConfigNode = data.blockroomsGameConfigModels?.edges?.[0]?.node;

  const roomNodes = data.blockroomsRoomModels?.edges?.map((e: any) => e.node) || [];
  const entityNodes = data.blockroomsEntityModels?.edges?.map((e: any) => e.node) || [];
  const shardNodes = data.blockroomsShardLocationModels?.edges?.map((e: any) => e.node) || [];
  console.log("entityNodes", entityNodes);
  return {
    player: playerNode ? {
      player_id: playerNode.player_id,
      position: parsePosition(playerNode.position),
      current_room: parseNumber(playerNode.current_room),
      health: parseNumber(playerNode.health),
      max_health: parseNumber(playerNode.max_health),
      shards: parseNumber(playerNode.shards),
      game_active: Boolean(playerNode.game_active),
      is_alive: Boolean(playerNode.is_alive),
      current_session_id: parseNumber(playerNode.current_session_id),
      rooms_cleared: parseNumber(playerNode.rooms_cleared),
      has_shard_one: Boolean(playerNode.has_shard_one),
      has_shard_two: Boolean(playerNode.has_shard_two),
      has_shard_three: Boolean(playerNode.has_shard_three),
      special_ability_cooldown: parseNumber(playerNode.special_ability_cooldown),
      has_key: Boolean(playerNode.has_key),
    } as models.Player : null,

    playerStats: playerStatsNode ? {
      player_id: playerStatsNode.player_id,
      games_played: parseNumber(playerStatsNode.games_played),
      games_won: parseNumber(playerStatsNode.games_won),
      total_shards_collected: parseNumber(playerStatsNode.total_shards_collected),
      total_entities_defeated: parseNumber(playerStatsNode.total_entities_defeated),
      total_playtime: parseNumber(playerStatsNode.total_playtime),
      best_completion_time: parseNumber(playerStatsNode.best_completion_time),
      highest_room_reached: parseNumber(playerStatsNode.highest_room_reached),
      total_damage_dealt: parseNumber(playerStatsNode.total_damage_dealt),
      total_damage_taken: parseNumber(playerStatsNode.total_damage_taken),
      doors_opened: parseNumber(playerStatsNode.doors_opened),
      total_actions_taken: parseNumber(playerStatsNode.total_actions_taken),
      numbered_shards_collected: parseNumber(playerStatsNode.numbered_shards_collected),
    } as models.PlayerStats : null,

    gameSession: gameSessionNode ? {
      session_id: parseNumber(gameSessionNode.session_id),
      player_id: gameSessionNode.player_id,
      start_time: parseNumber(gameSessionNode.start_time),
      end_time: parseNumber(gameSessionNode.end_time),
      rooms_cleared: parseNumber(gameSessionNode.rooms_cleared),
      total_shards_collected: parseNumber(gameSessionNode.total_shards_collected),
      numbered_shards_collected: parseNumber(gameSessionNode.numbered_shards_collected),
      entities_defeated: parseNumber(gameSessionNode.entities_defeated),
      total_damage_dealt: parseNumber(gameSessionNode.total_damage_dealt),
      total_damage_taken: parseNumber(gameSessionNode.total_damage_taken),
      doors_opened: parseNumber(gameSessionNode.doors_opened),
      deaths: parseNumber(gameSessionNode.deaths),
      session_complete: Boolean(gameSessionNode.session_complete),
      total_actions: parseNumber(gameSessionNode.total_actions),
      victory_achieved: Boolean(gameSessionNode.victory_achieved),
    } as models.GameSession : null,

    gameConfig: gameConfigNode ? {
      config_id: parseNumber(gameConfigNode.config_id),
      grid_size: parseNumber(gameConfigNode.grid_size),
      starting_health: parseNumber(gameConfigNode.starting_health),
      starting_shards: parseNumber(gameConfigNode.starting_shards),
      base_damage: parseNumber(gameConfigNode.base_damage),
      entity_spawn_rate: parseNumber(gameConfigNode.entity_spawn_rate),
      shard_drop_rate: parseNumber(gameConfigNode.shard_drop_rate),
      male_entity_damage: parseNumber(gameConfigNode.male_entity_damage),
      female_entity_damage: parseNumber(gameConfigNode.female_entity_damage),
      door_detection_range: parseNumber(gameConfigNode.door_detection_range),
    } as models.GameConfig : null,

    rooms: roomNodes.map((node: any) => ({
      room_id: parseNumber(node.room_id),
      initialized: Boolean(node.initialized),
      cleared: Boolean(node.cleared),
      entity_count: parseNumber(node.entity_count),
      active_entities: parseNumber(node.active_entities),
      has_treasure: Boolean(node.has_treasure),
      treasure_collected: Boolean(node.treasure_collected),
    } as models.Room)),
    
    entities: entityNodes.map((node: any) => ({
      entity_id: parseNumber(node.entity_id),
      entity_type: parseCairoEnum(node.entity_type),
      room_id: parseNumber(node.room_id),
      health: parseNumber(node.health),
      max_health: parseNumber(node.max_health),
      is_alive: Boolean(node.is_alive),
      damage_per_turn: parseNumber(node.damage_per_turn),
      drops_numbered_shard: parseCairoOption(node.drops_numbered_shard),
    } as models.Entity)),
    
    shardLocations: shardNodes.map((node: any) => ({
      shard_id: parseNumber(node.shard_id),
      room_id: parseNumber(node.room_id),
      numbered_shard: parseCairoOption(node.numbered_shard),
      collected: Boolean(node.collected),
    } as models.ShardLocation)),
  };
};

export const useGameData = (): UseGameDataReturn => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { account } = useAccount();
  
  // Store state and actions
  const {
    player,
    playerStats,
    gameSession,
    gameConfig,
    currentRoom,
    gamePhase,
    isPlayerInitialized,
    gameStats,
    setPlayer,
    setPlayerStats,
    setGameSession,
    setGameConfig,
    setCurrentRoom,
    setRooms,
    setEntities,
    setShardLocations,
    setLoading,
    setError: setStoreError,
    canMove,
    canAttack,
    resetGame,
    getEntitiesInCurrentRoom,
    getShardsInCurrentRoom,
  } = useAppStore();

  const userAddress = account ? addAddressPadding(account.address).toLowerCase() : '';

  const refetch = useCallback(async () => {
    if (!userAddress) {
      setIsLoading(false);
      setLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setLoading(true);
      setError(null);
      setStoreError(null);

      const data = await fetchPlayerData(userAddress);
       
      if (data) {
        // Update store with fetched data
        setPlayer(data.player);
        console.log("data.playerStats", data.playerStats);
        setPlayerStats(data.playerStats);
        setGameSession(data.gameSession);
        setGameConfig(data.gameConfig);
        
        // Set world state
        setRooms(data.rooms);
        console.log("data.entities", data.entities);
        setEntities(data.entities);
        setShardLocations(data.shardLocations);

        // Find and set current room based on player's current_room field
        if (data.player) {
          const currentRoomId = data.player.current_room.toString();
          const playerRoom = data.rooms.find((room: models.Room) => 
            room.room_id.toString() === currentRoomId
          );
          setCurrentRoom(playerRoom || null);
        }
      } else {
        // No player data found - reset to initial state
        console.log("No player data found - reset to initial state");
        setPlayer(null);
        setPlayerStats(null);
        setGameSession(null);
        setGameConfig(null);
        setCurrentRoom(null);
        setRooms([]);
        setEntities([]);
        setShardLocations([]);
      }

    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Failed to fetch player data';
      setError(errorMsg);
      setStoreError(errorMsg);
      console.error("Error fetching player data:", err);
    } finally {
      setIsLoading(false);
      setLoading(false);
    }
  }, [
    userAddress, 
    setPlayer, 
    setPlayerStats, 
    setGameSession, 
    setGameConfig,
    setCurrentRoom,
    setRooms,
    setEntities,
    setShardLocations,
    setLoading, 
    setStoreError
  ]);

  // Fetch data when address changes
  useEffect(() => {
    if (userAddress) {
      refetch();
    } else {
      setIsLoading(false);
      setLoading(false);
    }
  }, [userAddress, refetch]);

  // Reset when account disconnects
  useEffect(() => {
    if (!account) {
      resetGame();
      setError(null);
      setIsLoading(false);
    }
  }, [account, resetGame]);

  return {
    player,
    playerStats,
    gameSession,
    gameConfig,
    currentRoom,
    entities: getEntitiesInCurrentRoom(),
    shardLocations: getShardsInCurrentRoom(),
    isLoading,
    error,
    refetch,
    gamePhase,
    gameStats,
    canMove: canMove(),
    canAttack: canAttack(),
    isPlayerInitialized,
  };
};
</file>

<file path="src/dojo/hooks/useInitializePlayer.tsx">
import { useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface InitializeState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface InitializeResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useInitializePlayer = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();
  
  const { 
    setError,
    setGamePhase,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    isPlayerInitialized
  } = useAppStore();

  const [state, setState] = useState<InitializeState>({
    isLoading: false,
    error: null,
    txHash: null
  });

  const initializePlayer = useCallback(async (): Promise<InitializeResult> => {
    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already initializing" };
    }

    // Validate connection
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player is already initialized
    if (isPlayerInitialized || (player && gamePhase !== GamePhase.UNINITIALIZED)) {
      const error = "Player is already initialized";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);
    

    try {
      console.log("üéÆ Initializing player...");
      
      const tx = await client.actions.initializePlayer(account as Account);
      
      if (!tx?.transaction_hash) {
        throw new Error("No transaction hash received");
      }

      setState(prev => ({ ...prev, txHash: tx.transaction_hash }));
      setLastTransaction(tx.transaction_hash);

      // Wait for transaction processing
      console.log("‚è≥ Processing transaction...");
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Refetch player data
      console.log("üîÑ Refetching player data...");
      await refetchPlayer();
      
      console.log("‚úÖ Player initialized successfully!");
      
      setState(prev => ({ ...prev, isLoading: false }));
      setActionInProgress(false);
      setLoading(false);
      setGamePhase(GamePhase.INITIALIZED);
      
      return { 
        success: true, 
        transactionHash: tx.transaction_hash 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to initialize player";
      
      console.error("‚ùå Initialization failed:", error);
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setGamePhase(GamePhase.UNINITIALIZED);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [
    state.isLoading,
    actionInProgress,
    status,
    account,
    client,
    refetchPlayer,
    setError,
    setGamePhase,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    player,
    gamePhase,
    isPlayerInitialized
  ]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canInitialize: status === "connected" && !isPlayerInitialized && gamePhase === GamePhase.UNINITIALIZED && !actionInProgress,
    actionInProgress,
    initializePlayer,
    reset
  };
};
</file>

<file path="src/dojo/hooks/useMovePlayer.tsx">
import { useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface MovePlayerState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface MovePlayerResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useMovePlayer = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();
  
  const { 
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    canMove
  } = useAppStore();

  const [state, setState] = useState<MovePlayerState>({
    isLoading: false,
    error: null,
    txHash: null
  });

  const movePlayer = useCallback(async (xDelta: number, yDelta: number): Promise<MovePlayerResult> => {
    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already moving" };
    }

    // Validate connection
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player can move
    if (!canMove()) {
      const error = "Cannot move at this time";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player exists and game is active
    if (!player || gamePhase !== GamePhase.ACTIVE) {
      const error = "Game is not active";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }
    
    if (![0, 1, 2].includes(xDelta) || ![0, 1, 2].includes(yDelta)) {
      const error = "Invalid movement. Delta must be 0, 1, or 2.";
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);

    try {
      console.log(`üö∂ Moving player (${typeof xDelta},${xDelta}, ${typeof yDelta},${yDelta})...`);
    
      const tx = await client.actions.movePlayer(
        account as Account,
        xDelta,
        yDelta
      );      
      if (!tx?.transaction_hash) {
        throw new Error("No transaction hash received");
      }

      setState(prev => ({ ...prev, txHash: tx.transaction_hash }));
      setLastTransaction(tx.transaction_hash);

      // Wait for transaction processing
      console.log("‚è≥ Processing movement...");
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Refetch player data
      console.log("üîÑ Refetching player data...");
      await refetchPlayer();
      
      console.log("‚úÖ Player moved successfully!");
      
      setState(prev => ({ ...prev, isLoading: false }));
      setActionInProgress(false);
      setLoading(false);
      
      return { 
        success: true, 
        transactionHash: tx.transaction_hash 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to move player";
      
      console.error("‚ùå Movement failed:", error);
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [
    state.isLoading,
    actionInProgress,
    status,
    account,
    client,
    refetchPlayer,
    setError,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    player,
    gamePhase,
    canMove
  ]);

 

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canMovePlayer: canMove(),
    actionInProgress,
    movePlayer,
    reset
  };
};
</file>

<file path="src/dojo/hooks/usePlayerMovement.tsx">
import { useEffect, useRef, useCallback, useState } from 'react';
import { Vector3 } from 'three';
import useAppStore, { GamePhase } from "../../zustand/store";
import { useMovePlayer } from './useMovePlayer';

interface UsePlayerMovementReturn {
  showTransactionPopup: boolean;
  transactionError: string | null;
  isProcessingTransaction: boolean;
  closeTransactionPopup: () => void;
}

export const usePlayerMovement = (): UsePlayerMovementReturn => {
  const { position, updatePosition } = useAppStore();
  const { movePlayer, isLoading, error } = useMovePlayer();
  
  
  const lastVerifiedPosition = useRef<{ x: number; z: number }>({ x: 400, z: 400 });
  const isProcessingBoundary = useRef<boolean>(false);
  
  
  const [showTransactionPopup, setShowTransactionPopup] = useState(false);
  const [transactionError, setTransactionError] = useState<string | null>(null);

  
  const GENESIS_X = 400;
  const GENESIS_Z = 400;
  const GRID_SIZE = 20;

  
  const getGridCell = useCallback((coord: number, genesis: number): number => {
    return Math.floor((coord - genesis) / GRID_SIZE);
  }, []);

  
  // const getGridBoundary = useCallback((gridCell: number, genesis: number): number => {
  //   return genesis + (gridCell * GRID_SIZE);
  // }, []);

  // Convert delta to 0-2 range for contract
  const convertDeltaToContractFormat = useCallback((delta: number): number => {
    if (delta < 0) return 0;  // -1 becomes 0
    if (delta > 0) return 2;  // +1 becomes 2
    return 1;                 // 0 stays 1
  }, []);

  
  const checkBoundaryCrossing = useCallback((
    currentPos: { x: number; z: number },
    lastPos: { x: number; z: number }
  ): { crossed: boolean; deltaX: number; deltaY: number; contractDeltaX: number; contractDeltaY: number } => {
    const currentGridX = getGridCell(currentPos.x, GENESIS_X);
    const currentGridZ = getGridCell(currentPos.z, GENESIS_Z);
    const lastGridX = getGridCell(lastPos.x, GENESIS_X);
    const lastGridZ = getGridCell(lastPos.z, GENESIS_Z);

    const crossedX = currentGridX !== lastGridX;
    const crossedZ = currentGridZ !== lastGridZ;

    if (crossedX || crossedZ) {
      
      const deltaX = currentGridX - lastGridX;
      const deltaY = currentGridZ - lastGridZ; 
      
      // Convert to contract format (0-2)
      const contractDeltaX = convertDeltaToContractFormat(deltaX);
      const contractDeltaY = convertDeltaToContractFormat(deltaY);
      
      return { 
        crossed: true, 
        deltaX, 
        deltaY,
        contractDeltaX,
        contractDeltaY
      };
    }

    return { 
      crossed: false, 
      deltaX: 0, 
      deltaY: 0,
      contractDeltaX: 1,
      contractDeltaY: 1
    };
  }, [getGridCell, convertDeltaToContractFormat]);

  
  const handleTransactionSuccess = useCallback((newGridPos: { x: number; z: number }) => {
    lastVerifiedPosition.current = newGridPos;
    setShowTransactionPopup(false);
    setTransactionError(null);
    isProcessingBoundary.current = false;
    console.log('‚úÖ Boundary crossing verified onchain:', newGridPos);
  }, []);

  
  const handleTransactionFailure = useCallback((error: string) => {
    console.log('‚ùå Boundary crossing failed, reverting position');
    
    
    // const revertPosition = {
    //   x: lastVerifiedPosition.current.x,
    //   y: 1.5, 
    //   z: lastVerifiedPosition.current.z
    // };
    
    // updatePosition(revertPosition);
    setTransactionError(error);
    isProcessingBoundary.current = false;
    
    
    setTimeout(() => {
      setShowTransactionPopup(false);
      setTransactionError(null);
    }, 300);
  }, [updatePosition]);

  
  const processBoundaryCrossing = useCallback(async (contractDeltaX: number, contractDeltaY: number, originalDeltaX: number, originalDeltaY: number) => {
    if (isProcessingBoundary.current) return;
    
    isProcessingBoundary.current = true;
    setShowTransactionPopup(true);
    setTransactionError(null);

    try {
      console.log(`üö∂ Processing boundary crossing: original deltaX=${originalDeltaX}, deltaY=${originalDeltaY}`);
      console.log(`üì° Sending to contract: contractDeltaX=${contractDeltaX}, contractDeltaY=${contractDeltaY}`);
      
      const result = await movePlayer(contractDeltaX, contractDeltaY);
      
      if (result.success) {
        
        const newVerifiedPos = {
          x: lastVerifiedPosition.current.x + (originalDeltaX * GRID_SIZE),
          z: lastVerifiedPosition.current.z + (originalDeltaY * GRID_SIZE)
        };
        handleTransactionSuccess(newVerifiedPos);
      } else {
        handleTransactionFailure(result.error || 'Transaction failed');
      }
    } catch (error) {
      handleTransactionFailure(error instanceof Error ? error.message : 'Unknown error');
    }
  }, [movePlayer, handleTransactionSuccess, handleTransactionFailure]);

  
  useEffect(() => {
    if (isProcessingBoundary.current) return;

    const currentPos = { x: position.x, z: position.z };
    const { crossed, deltaX, deltaY, contractDeltaX, contractDeltaY } = checkBoundaryCrossing(currentPos, lastVerifiedPosition.current);

    if (crossed) {
      console.log('üéØ Boundary crossed detected!', { 
        from: lastVerifiedPosition.current, 
        to: currentPos, 
        originalDelta: { deltaX, deltaY },
        contractDelta: { contractDeltaX, contractDeltaY }
      });
      processBoundaryCrossing(contractDeltaX, contractDeltaY, deltaX, deltaY);
    }
  }, [position.x, position.z, checkBoundaryCrossing, processBoundaryCrossing]);

  
  const closeTransactionPopup = useCallback(() => {
    setShowTransactionPopup(false);
    setTransactionError(null);
  }, []);

  return {
    showTransactionPopup,
    transactionError,
    isProcessingTransaction: isLoading,
    closeTransactionPopup
  };
};
</file>

<file path="src/dojo/hooks/useStarknetConnect.tsx">
// hooks/useStarknetConnect.ts
import { useConnect, useAccount, useDisconnect } from "@starknet-react/core";
import { useState, useCallback } from "react";

export function useStarknetConnect() {
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();
  const { status, address } = useAccount();
  const [hasTriedConnect, setHasTriedConnect] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);

  const handleConnect = useCallback(async () => {
 
    
    const connector = connectors[0]; // Cartridge connector
    if (!connector) {
      console.error("No connector found");
      return;
    }
    
    try {
      setIsConnecting(true);
      setHasTriedConnect(true);
      
      await connect({ connector });
  
    } catch (error) {
      console.error("‚ùå Connection failed:", error);
    } finally {
      setIsConnecting(false);
    }
  }, [connect, connectors]);

  const handleDisconnect = useCallback(async () => {
    try {
       
      await disconnect();
      setHasTriedConnect(false); 
    } catch (error) {
      console.error("‚ùå Disconnection failed:", error);
    }
  }, [disconnect]);
 

  return { 
    status, 
    address,
    isConnecting,
    hasTriedConnect, 
    handleConnect,
    handleDisconnect,
    setHasTriedConnect 
  };
}
</file>

<file path="src/dojo/hooks/useStartGame.tsx">
import { useState, useCallback } from "react";
import { useAccount } from "@starknet-react/core";
import { Account } from "starknet";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useStarknetConnect } from "./useStarknetConnect";
import useAppStore, { GamePhase } from "../../zustand/store";
import { useGameData } from "./useGameData";

interface StartGameState {
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
}

interface StartGameResult {
  success: boolean;
  transactionHash?: string;
  error?: string;
}

export const useStartGame = () => {
  const { client } = useDojoSDK();
  const { account } = useAccount();
  const { status } = useStarknetConnect();
  const { refetch: refetchPlayer } = useGameData();
  
  const { 
    setError,
    setGamePhase,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    actionInProgress,
    gamePhase,
    player,
    isPlayerInitialized
  } = useAppStore();

  const [state, setState] = useState<StartGameState>({
    isLoading: false,
    error: null,
    txHash: null
  });

  // Check if we can start the game
  const canStartGame = status === "connected" && 
                       isPlayerInitialized && 
                       !player?.game_active && 
                       gamePhase !== GamePhase.ACTIVE && 
                       !actionInProgress;

  const startGame = useCallback(async (): Promise<StartGameResult> => {
    console.log("üéÆ Starting game process...");
    console.log("State check:", {
      isLoading: state.isLoading,
      actionInProgress,
      status,
      account: !!account,
      isPlayerInitialized,
      gamePhase,
      playerGameActive: player?.game_active
    });

    if (state.isLoading || actionInProgress) {
      return { success: false, error: "Already starting game" };
    }

    // Validate connection
    if (status !== "connected" || !account) {
      const error = "Wallet not connected. Please connect your wallet first.";
      console.error("‚ùå Connection validation failed:", error);
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if player is initialized
    if (!isPlayerInitialized) {
      const error = "Player must be initialized first";
      console.error("‚ùå Player validation failed:", error);
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    // Check if game is already active
    if (gamePhase === GamePhase.ACTIVE || player?.game_active) {
      const error = "Game is already active";
      console.error("‚ùå Game state validation failed:", error);
      setState(prev => ({ ...prev, error }));
      setError(error);
      return { success: false, error };
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));
    setActionInProgress(true);
    setLoading(true);
    setError(null);

    try {
      console.log("üöÄ Executing start game transaction...");
      
      // Make sure account is properly serializable
      const accountToUse = account as Account;
      console.log("Account address:", accountToUse.address);
      
      const tx = await client.actions.startGame(accountToUse);
      
      console.log("üìù Transaction response:", tx);
      
      if (!tx?.transaction_hash) {
        throw new Error("No transaction hash received from start game");
      }

      setState(prev => ({ ...prev, txHash: tx.transaction_hash }));
      setLastTransaction(tx.transaction_hash);

      // Wait for transaction processing
      console.log("‚è≥ Waiting for transaction to process...");
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      console.log("‚úÖ Game started successfully!");
      
      setState(prev => ({ ...prev, isLoading: false }));
      setActionInProgress(false);
      setLoading(false);
      setGamePhase(GamePhase.ACTIVE);
      
      // Refetch player data after successful start
      console.log("üîÑ Refetching player data...");
      setTimeout(async () => {
        try {
          await refetchPlayer();
          console.log("‚úÖ Player data refreshed");
        } catch (refetchError) {
          console.warn("‚ö†Ô∏è Failed to refetch player data:", refetchError);
        }
      }, 1000);
      
      return { 
        success: true, 
        transactionHash: tx.transaction_hash 
      };

    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Failed to start game";
      
      console.error("‚ùå Game start failed:", error);
      console.error("Error details:", {
        name: error instanceof Error ? error.name : 'Unknown',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      
      setState(prev => ({ ...prev, error: errorMessage, isLoading: false }));
      setError(errorMessage);
      setActionInProgress(false);
      setLoading(false);
      
      return { success: false, error: errorMessage };
    }
  }, [
    state.isLoading,
    actionInProgress,
    status,
    account,
    client,
    refetchPlayer,
    setError,
    setGamePhase,
    setActionInProgress,
    setLastTransaction,
    setLoading,
    player,
    gamePhase,
    isPlayerInitialized
  ]);

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, txHash: null });
    setError(null);
    setActionInProgress(false);
    setLoading(false);
  }, [setError, setActionInProgress, setLoading]);

  return {
    isLoading: state.isLoading,
    error: state.error,
    txHash: state.txHash,
    isConnected: status === "connected",
    canStartGame,
    actionInProgress,
    startGame,
    reset
  };
};
</file>

<file path="src/dojo/models.gen.ts">
import type { SchemaType as ISchemaType } from "@dojoengine/sdk";

import { CairoCustomEnum, CairoOption, CairoOptionVariant, BigNumberish } from 'starknet';

// Type definition for `blockrooms::models::Entity` struct
export interface Entity {
	entity_id: BigNumberish;
	entity_type: EntityTypeEnum;
	room_id: BigNumberish;
	health: BigNumberish;
	max_health: BigNumberish;
	is_alive: boolean;
	damage_per_turn: BigNumberish;
	drops_numbered_shard: CairoOption<NumberedShardEnum>;
}

// Type definition for `blockrooms::models::EntityState` struct
export interface EntityState {
	entity_id: BigNumberish;
	alert_level: AlertLevelEnum;
	last_action_block: BigNumberish;
}

// Type definition for `blockrooms::models::EntityStateValue` struct
export interface EntityStateValue {
	alert_level: AlertLevelEnum;
	last_action_block: BigNumberish;
}

// Type definition for `blockrooms::models::EntityValue` struct
export interface EntityValue {
	entity_type: EntityTypeEnum;
	room_id: BigNumberish;
	health: BigNumberish;
	max_health: BigNumberish;
	is_alive: boolean;
	damage_per_turn: BigNumberish;
	drops_numbered_shard: CairoOption<NumberedShardEnum>;
}

// Type definition for `blockrooms::models::GameConfig` struct
export interface GameConfig {
	config_id: BigNumberish;
	grid_size: BigNumberish;
	starting_health: BigNumberish;
	starting_shards: BigNumberish;
	base_damage: BigNumberish;
	entity_spawn_rate: BigNumberish;
	shard_drop_rate: BigNumberish;
	male_entity_damage: BigNumberish;
	female_entity_damage: BigNumberish;
	door_detection_range: BigNumberish;
}

// Type definition for `blockrooms::models::GameConfigValue` struct
export interface GameConfigValue {
	grid_size: BigNumberish;
	starting_health: BigNumberish;
	starting_shards: BigNumberish;
	base_damage: BigNumberish;
	entity_spawn_rate: BigNumberish;
	shard_drop_rate: BigNumberish;
	male_entity_damage: BigNumberish;
	female_entity_damage: BigNumberish;
	door_detection_range: BigNumberish;
}

// Type definition for `blockrooms::models::GameSession` struct
export interface GameSession {
	session_id: BigNumberish;
	player_id: string;
	start_time: BigNumberish;
	end_time: BigNumberish;
	rooms_cleared: BigNumberish;
	total_shards_collected: BigNumberish;
	numbered_shards_collected: BigNumberish;
	entities_defeated: BigNumberish;
	total_damage_dealt: BigNumberish;
	total_damage_taken: BigNumberish;
	doors_opened: BigNumberish;
	deaths: BigNumberish;
	session_complete: boolean;
	total_actions: BigNumberish;
	victory_achieved: boolean;
}

// Type definition for `blockrooms::models::GameSessionValue` struct
export interface GameSessionValue {
	player_id: string;
	start_time: BigNumberish;
	end_time: BigNumberish;
	rooms_cleared: BigNumberish;
	total_shards_collected: BigNumberish;
	numbered_shards_collected: BigNumberish;
	entities_defeated: BigNumberish;
	total_damage_dealt: BigNumberish;
	total_damage_taken: BigNumberish;
	doors_opened: BigNumberish;
	deaths: BigNumberish;
	session_complete: boolean;
	total_actions: BigNumberish;
	victory_achieved: boolean;
}

// Type definition for `blockrooms::models::Player` struct
export interface Player {
	player_id: string;
	position: Position;
	current_room: BigNumberish;
	health: BigNumberish;
	max_health: BigNumberish;
	shards: BigNumberish;
	game_active: boolean;
	is_alive: boolean;
	current_session_id: BigNumberish;
	rooms_cleared: BigNumberish;
	has_shard_one: boolean;
	has_shard_two: boolean;
	has_shard_three: boolean;
	special_ability_cooldown: BigNumberish;
	has_key: boolean;
}

// Type definition for `blockrooms::models::PlayerStats` struct
export interface PlayerStats {
	player_id: string;
	games_played: BigNumberish;
	games_won: BigNumberish;
	total_shards_collected: BigNumberish;
	total_entities_defeated: BigNumberish;
	total_playtime: BigNumberish;
	best_completion_time: BigNumberish;
	highest_room_reached: BigNumberish;
	total_damage_dealt: BigNumberish;
	total_damage_taken: BigNumberish;
	doors_opened: BigNumberish;
	total_actions_taken: BigNumberish;
	numbered_shards_collected: BigNumberish;
}

// Type definition for `blockrooms::models::PlayerStatsValue` struct
export interface PlayerStatsValue {
	games_played: BigNumberish;
	games_won: BigNumberish;
	total_shards_collected: BigNumberish;
	total_entities_defeated: BigNumberish;
	total_playtime: BigNumberish;
	best_completion_time: BigNumberish;
	highest_room_reached: BigNumberish;
	total_damage_dealt: BigNumberish;
	total_damage_taken: BigNumberish;
	doors_opened: BigNumberish;
	total_actions_taken: BigNumberish;
	numbered_shards_collected: BigNumberish;
}

// Type definition for `blockrooms::models::PlayerValue` struct
export interface PlayerValue {
	position: Position;
	current_room: BigNumberish;
	health: BigNumberish;
	max_health: BigNumberish;
	shards: BigNumberish;
	game_active: boolean;
	is_alive: boolean;
	current_session_id: BigNumberish;
	rooms_cleared: BigNumberish;
	has_shard_one: boolean;
	has_shard_two: boolean;
	has_shard_three: boolean;
	special_ability_cooldown: BigNumberish;
	has_key: boolean;
}

// Type definition for `blockrooms::models::Position` struct
export interface Position {
	x: BigNumberish;
	y: BigNumberish;
}

// Type definition for `blockrooms::models::Room` struct
export interface Room {
	room_id: BigNumberish;
	initialized: boolean;
	cleared: boolean;
	entity_count: BigNumberish;
	active_entities: BigNumberish;
	has_treasure: boolean;
	treasure_collected: boolean;
}

// Type definition for `blockrooms::models::RoomValue` struct
export interface RoomValue {
	initialized: boolean;
	cleared: boolean;
	entity_count: BigNumberish;
	active_entities: BigNumberish;
	has_treasure: boolean;
	treasure_collected: boolean;
}

// Type definition for `blockrooms::models::ShardLocation` struct
export interface ShardLocation {
	shard_id: BigNumberish;
	room_id: BigNumberish;
	numbered_shard: CairoOption<NumberedShardEnum>;
	collected: boolean;
}

// Type definition for `blockrooms::models::ShardLocationValue` struct
export interface ShardLocationValue {
	room_id: BigNumberish;
	numbered_shard: CairoOption<NumberedShardEnum>;
	collected: boolean;
}

// Type definition for `blockrooms::systems::actions::actions::GameCompleted` struct
export interface GameCompleted {
	player_id: string;
	session_id: BigNumberish;
	rooms_cleared: BigNumberish;
	result: GameResultEnum;
}

// Type definition for `blockrooms::systems::actions::actions::GameCompletedValue` struct
export interface GameCompletedValue {
	session_id: BigNumberish;
	rooms_cleared: BigNumberish;
	result: GameResultEnum;
}

// Type definition for `blockrooms::systems::actions::actions::GameStarted` struct
export interface GameStarted {
	player_id: string;
	session_id: BigNumberish;
	start_time: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::GameStartedValue` struct
export interface GameStartedValue {
	session_id: BigNumberish;
	start_time: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::NumberedShardCollected` struct
export interface NumberedShardCollected {
	player_id: string;
	shard_type: NumberedShardEnum;
	room_id: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::NumberedShardCollectedValue` struct
export interface NumberedShardCollectedValue {
	shard_type: NumberedShardEnum;
	room_id: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::PlayerDeath` struct
export interface PlayerDeath {
	player_id: string;
	room_id: BigNumberish;
	cause: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::PlayerDeathValue` struct
export interface PlayerDeathValue {
	room_id: BigNumberish;
	cause: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::RoomCleared` struct
export interface RoomCleared {
	player_id: string;
	room_id: BigNumberish;
	entities_defeated: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::RoomClearedValue` struct
export interface RoomClearedValue {
	room_id: BigNumberish;
	entities_defeated: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::RoomEntered` struct
export interface RoomEntered {
	player_id: string;
	room_id: BigNumberish;
	door_id: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::RoomEnteredValue` struct
export interface RoomEnteredValue {
	room_id: BigNumberish;
	door_id: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::RoomExited` struct
export interface RoomExited {
	player_id: string;
	room_id: BigNumberish;
	door_id: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::RoomExitedValue` struct
export interface RoomExitedValue {
	room_id: BigNumberish;
	door_id: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::VictoryAchieved` struct
export interface VictoryAchieved {
	player_id: string;
	session_id: BigNumberish;
	completion_time: BigNumberish;
}

// Type definition for `blockrooms::systems::actions::actions::VictoryAchievedValue` struct
export interface VictoryAchievedValue {
	session_id: BigNumberish;
	completion_time: BigNumberish;
}

// Type definition for `blockrooms::models::AlertLevel` enum
export const alertLevel = [
	'Idle',
	'Alerted',
	'Combat',
] as const;
export type AlertLevel = { [key in typeof alertLevel[number]]: string };
export type AlertLevelEnum = CairoCustomEnum;

// Type definition for `blockrooms::models::EntityType` enum
export const entityType = [
	'Male',
	'Female',
] as const;
export type EntityType = { [key in typeof entityType[number]]: string };
export type EntityTypeEnum = CairoCustomEnum;

// Type definition for `blockrooms::models::NumberedShard` enum
export const numberedShard = [
	'One',
	'Two',
	'Three',
] as const;
export type NumberedShard = { [key in typeof numberedShard[number]]: string };
export type NumberedShardEnum = CairoCustomEnum;

// Type definition for `blockrooms::models::GameResult` enum
export const gameResult = [
	'InProgress',
	'Victory',
	'Defeat',
] as const;
export type GameResult = { [key in typeof gameResult[number]]: string };
export type GameResultEnum = CairoCustomEnum;

export interface SchemaType extends ISchemaType {
	blockrooms: {
		Entity: Entity,
		EntityState: EntityState,
		EntityStateValue: EntityStateValue,
		EntityValue: EntityValue,
		GameConfig: GameConfig,
		GameConfigValue: GameConfigValue,
		GameSession: GameSession,
		GameSessionValue: GameSessionValue,
		Player: Player,
		PlayerStats: PlayerStats,
		PlayerStatsValue: PlayerStatsValue,
		PlayerValue: PlayerValue,
		Position: Position,
		Room: Room,
		RoomValue: RoomValue,
		ShardLocation: ShardLocation,
		ShardLocationValue: ShardLocationValue,
		GameCompleted: GameCompleted,
		GameCompletedValue: GameCompletedValue,
		GameStarted: GameStarted,
		GameStartedValue: GameStartedValue,
		NumberedShardCollected: NumberedShardCollected,
		NumberedShardCollectedValue: NumberedShardCollectedValue,
		PlayerDeath: PlayerDeath,
		PlayerDeathValue: PlayerDeathValue,
		RoomCleared: RoomCleared,
		RoomClearedValue: RoomClearedValue,
		RoomEntered: RoomEntered,
		RoomEnteredValue: RoomEnteredValue,
		RoomExited: RoomExited,
		RoomExitedValue: RoomExitedValue,
		VictoryAchieved: VictoryAchieved,
		VictoryAchievedValue: VictoryAchievedValue,
	},
}
export const schema: SchemaType = {
	blockrooms: {
		Entity: {
			entity_id: 0,
		entity_type: new CairoCustomEnum({ 
					Male: "",
				Female: undefined, }),
			room_id: 0,
			health: 0,
			max_health: 0,
			is_alive: false,
			damage_per_turn: 0,
		drops_numbered_shard: new CairoOption(CairoOptionVariant.None),
		},
		EntityState: {
			entity_id: 0,
		alert_level: new CairoCustomEnum({ 
					Idle: "",
				Alerted: undefined,
				Combat: undefined, }),
			last_action_block: 0,
		},
		EntityStateValue: {
		alert_level: new CairoCustomEnum({ 
					Idle: "",
				Alerted: undefined,
				Combat: undefined, }),
			last_action_block: 0,
		},
		EntityValue: {
		entity_type: new CairoCustomEnum({ 
					Male: "",
				Female: undefined, }),
			room_id: 0,
			health: 0,
			max_health: 0,
			is_alive: false,
			damage_per_turn: 0,
		drops_numbered_shard: new CairoOption(CairoOptionVariant.None),
		},
		GameConfig: {
			config_id: 0,
			grid_size: 0,
			starting_health: 0,
			starting_shards: 0,
			base_damage: 0,
			entity_spawn_rate: 0,
			shard_drop_rate: 0,
			male_entity_damage: 0,
			female_entity_damage: 0,
			door_detection_range: 0,
		},
		GameConfigValue: {
			grid_size: 0,
			starting_health: 0,
			starting_shards: 0,
			base_damage: 0,
			entity_spawn_rate: 0,
			shard_drop_rate: 0,
			male_entity_damage: 0,
			female_entity_damage: 0,
			door_detection_range: 0,
		},
		GameSession: {
			session_id: 0,
			player_id: "",
			start_time: 0,
			end_time: 0,
			rooms_cleared: 0,
			total_shards_collected: 0,
			numbered_shards_collected: 0,
			entities_defeated: 0,
			total_damage_dealt: 0,
			total_damage_taken: 0,
			doors_opened: 0,
			deaths: 0,
			session_complete: false,
			total_actions: 0,
			victory_achieved: false,
		},
		GameSessionValue: {
			player_id: "",
			start_time: 0,
			end_time: 0,
			rooms_cleared: 0,
			total_shards_collected: 0,
			numbered_shards_collected: 0,
			entities_defeated: 0,
			total_damage_dealt: 0,
			total_damage_taken: 0,
			doors_opened: 0,
			deaths: 0,
			session_complete: false,
			total_actions: 0,
			victory_achieved: false,
		},
		Player: {
			player_id: "",
		position: { x: 0, y: 0, },
			current_room: 0,
			health: 0,
			max_health: 0,
			shards: 0,
			game_active: false,
			is_alive: false,
			current_session_id: 0,
			rooms_cleared: 0,
			has_shard_one: false,
			has_shard_two: false,
			has_shard_three: false,
			special_ability_cooldown: 0,
			has_key: false,
		},
		PlayerStats: {
			player_id: "",
			games_played: 0,
			games_won: 0,
			total_shards_collected: 0,
			total_entities_defeated: 0,
			total_playtime: 0,
			best_completion_time: 0,
			highest_room_reached: 0,
			total_damage_dealt: 0,
			total_damage_taken: 0,
			doors_opened: 0,
			total_actions_taken: 0,
			numbered_shards_collected: 0,
		},
		PlayerStatsValue: {
			games_played: 0,
			games_won: 0,
			total_shards_collected: 0,
			total_entities_defeated: 0,
			total_playtime: 0,
			best_completion_time: 0,
			highest_room_reached: 0,
			total_damage_dealt: 0,
			total_damage_taken: 0,
			doors_opened: 0,
			total_actions_taken: 0,
			numbered_shards_collected: 0,
		},
		PlayerValue: {
		position: { x: 0, y: 0, },
			current_room: 0,
			health: 0,
			max_health: 0,
			shards: 0,
			game_active: false,
			is_alive: false,
			current_session_id: 0,
			rooms_cleared: 0,
			has_shard_one: false,
			has_shard_two: false,
			has_shard_three: false,
			special_ability_cooldown: 0,
			has_key: false,
		},
		Position: {
			x: 0,
			y: 0,
		},
		Room: {
			room_id: 0,
			initialized: false,
			cleared: false,
			entity_count: 0,
			active_entities: 0,
			has_treasure: false,
			treasure_collected: false,
		},
		RoomValue: {
			initialized: false,
			cleared: false,
			entity_count: 0,
			active_entities: 0,
			has_treasure: false,
			treasure_collected: false,
		},
		ShardLocation: {
			shard_id: 0,
			room_id: 0,
		numbered_shard: new CairoOption(CairoOptionVariant.None),
			collected: false,
		},
		ShardLocationValue: {
			room_id: 0,
		numbered_shard: new CairoOption(CairoOptionVariant.None),
			collected: false,
		},
		GameCompleted: {
			player_id: "",
			session_id: 0,
			rooms_cleared: 0,
		result: new CairoCustomEnum({ 
					InProgress: "",
				Victory: undefined,
				Defeat: undefined, }),
		},
		GameCompletedValue: {
			session_id: 0,
			rooms_cleared: 0,
		result: new CairoCustomEnum({ 
					InProgress: "",
				Victory: undefined,
				Defeat: undefined, }),
		},
		GameStarted: {
			player_id: "",
			session_id: 0,
			start_time: 0,
		},
		GameStartedValue: {
			session_id: 0,
			start_time: 0,
		},
		NumberedShardCollected: {
			player_id: "",
		shard_type: new CairoCustomEnum({ 
					One: "",
				Two: undefined,
				Three: undefined, }),
			room_id: 0,
		},
		NumberedShardCollectedValue: {
		shard_type: new CairoCustomEnum({ 
					One: "",
				Two: undefined,
				Three: undefined, }),
			room_id: 0,
		},
		PlayerDeath: {
			player_id: "",
			room_id: 0,
			cause: 0,
		},
		PlayerDeathValue: {
			room_id: 0,
			cause: 0,
		},
		RoomCleared: {
			player_id: "",
			room_id: 0,
			entities_defeated: 0,
		},
		RoomClearedValue: {
			room_id: 0,
			entities_defeated: 0,
		},
		RoomEntered: {
			player_id: "",
			room_id: 0,
			door_id: 0,
		},
		RoomEnteredValue: {
			room_id: 0,
			door_id: 0,
		},
		RoomExited: {
			player_id: "",
			room_id: 0,
			door_id: 0,
		},
		RoomExitedValue: {
			room_id: 0,
			door_id: 0,
		},
		VictoryAchieved: {
			player_id: "",
			session_id: 0,
			completion_time: 0,
		},
		VictoryAchievedValue: {
			session_id: 0,
			completion_time: 0,
		},
	},
};
export enum ModelsMapping {
	AlertLevel = 'blockrooms-AlertLevel',
	Entity = 'blockrooms-Entity',
	EntityState = 'blockrooms-EntityState',
	EntityStateValue = 'blockrooms-EntityStateValue',
	EntityType = 'blockrooms-EntityType',
	EntityValue = 'blockrooms-EntityValue',
	GameConfig = 'blockrooms-GameConfig',
	GameConfigValue = 'blockrooms-GameConfigValue',
	GameSession = 'blockrooms-GameSession',
	GameSessionValue = 'blockrooms-GameSessionValue',
	NumberedShard = 'blockrooms-NumberedShard',
	Player = 'blockrooms-Player',
	PlayerStats = 'blockrooms-PlayerStats',
	PlayerStatsValue = 'blockrooms-PlayerStatsValue',
	PlayerValue = 'blockrooms-PlayerValue',
	Position = 'blockrooms-Position',
	Room = 'blockrooms-Room',
	RoomValue = 'blockrooms-RoomValue',
	ShardLocation = 'blockrooms-ShardLocation',
	ShardLocationValue = 'blockrooms-ShardLocationValue',
	GameResult = 'blockrooms-GameResult',
	GameCompleted = 'blockrooms-GameCompleted',
	GameCompletedValue = 'blockrooms-GameCompletedValue',
	GameStarted = 'blockrooms-GameStarted',
	GameStartedValue = 'blockrooms-GameStartedValue',
	NumberedShardCollected = 'blockrooms-NumberedShardCollected',
	NumberedShardCollectedValue = 'blockrooms-NumberedShardCollectedValue',
	PlayerDeath = 'blockrooms-PlayerDeath',
	PlayerDeathValue = 'blockrooms-PlayerDeathValue',
	RoomCleared = 'blockrooms-RoomCleared',
	RoomClearedValue = 'blockrooms-RoomClearedValue',
	RoomEntered = 'blockrooms-RoomEntered',
	RoomEnteredValue = 'blockrooms-RoomEnteredValue',
	RoomExited = 'blockrooms-RoomExited',
	RoomExitedValue = 'blockrooms-RoomExitedValue',
	VictoryAchieved = 'blockrooms-VictoryAchieved',
	VictoryAchievedValue = 'blockrooms-VictoryAchievedValue',
}
</file>

<file path="src/dojo/starknet-provider.tsx">
import type { PropsWithChildren } from "react";
import { sepolia, mainnet } from "@starknet-react/chains";
import {
    jsonRpcProvider,
    StarknetConfig,
    starkscan,
} from "@starknet-react/core";
import cartridgeConnector from "../config/cartridgeConnector";

export default function StarknetProvider({ children }: PropsWithChildren) {
    const { VITE_PUBLIC_DEPLOY_TYPE } = import.meta.env;

    // Get RPC URL based on environment
    const getRpcUrl = () => {
        switch (VITE_PUBLIC_DEPLOY_TYPE) {
            case "mainnet":
                return "https://api.cartridge.gg/x/starknet/mainnet";
            case "sepolia":
                return "https://api.cartridge.gg/x/starknet/sepolia";
            default:
                return "https://api.cartridge.gg/x/starknet/sepolia"; 
        }
    };

    // Create provider with the correct RPC URL
    const provider = jsonRpcProvider({
        rpc: () => ({ nodeUrl: getRpcUrl() }),
    });

    // Determine which chain to use
    const chains = VITE_PUBLIC_DEPLOY_TYPE === "mainnet" 
        ? [mainnet] 
        : [sepolia];

    return (
        <StarknetConfig
            autoConnect
            chains={chains}
            connectors={[cartridgeConnector]}
            explorer={starkscan}
            provider={provider}
        >
            {children}
        </StarknetConfig>
    );
}
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/main.tsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";

// Dojo & Starknet
import { init } from "@dojoengine/sdk";
import { DojoSdkProvider } from "@dojoengine/sdk/react";
import { dojoConfig } from "./dojo/dojoConfig";
import type { SchemaType } from "./dojo/models.gen";
import { setupWorld } from "./dojo/contracts.gen";
import StarknetProvider from "./dojo/starknet-provider";

// App Entry
import App from "./app/App";
import "./index.css";

// Init Dojo with error handling
async function main() {
  try {
    console.log("üöÄ Initializing Dojo SDK...");

    const sdk = await init<SchemaType>({
      client: {
        toriiUrl: dojoConfig.toriiUrl,
        worldAddress: dojoConfig.manifest.world.address,
      },
      domain: {
        name: "DojoGameStarter",
        version: "1.0",
        chainId: "KATANA",
        revision: "1",
      },
    });

    console.log("‚úÖ Dojo SDK initialized successfully");

    const rootElement = document.getElementById("root");
    if (!rootElement) throw new Error("Root element not found");

    createRoot(rootElement).render(
      <StrictMode>
        <DojoSdkProvider
          sdk={sdk}
          dojoConfig={dojoConfig}
          clientFn={setupWorld}
        >
          <StarknetProvider>
            <App />
          </StarknetProvider>
        </DojoSdkProvider>
      </StrictMode>
    );
  } catch (error) {
    console.error("‚ùå Failed to initialize Dojo:", error);

    // Fallback: render without Dojo if it fails
    const rootElement = document.getElementById("root");
    if (rootElement) {
      createRoot(rootElement).render(
        <StrictMode>
          <div className="min-h-screen bg-red-900 flex items-center justify-center">
            <div className="text-white text-center p-8">
              <h1 className="text-2xl font-bold mb-4">
                ‚ö†Ô∏è Dojo Initialization Error
              </h1>
              <p className="mb-4">Failed to connect to Dojo SDK</p>
              <details className="text-left">
                <summary className="cursor-pointer mb-2">
                  Error Details:
                </summary>
                <pre className="text-xs bg-black p-4 rounded overflow-auto">
                  {error instanceof Error ? error.message : String(error)}
                </pre>
              </details>
              <p className="text-sm mt-4 opacity-70">
                Check your Dojo configuration and network connection
              </p>
            </div>
          </div>
        </StrictMode>
      );
    }
  }
}

main();
</file>

<file path="src/models/Bloccc.tsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { Table } from './Table'; 
import {Car1} from './Car1';

import { useEffect, useMemo } from "react";
import { useThree, useFrame } from "@react-three/fiber";



type GLTFResult = GLTF & {
  nodes: {
    Plane: THREE.Mesh
    Cube: THREE.Mesh
    Cube001: THREE.Mesh
    Cube003: THREE.Mesh
    Cube004: THREE.Mesh
    Cube005: THREE.Mesh
    Cube006: THREE.Mesh
    Cube007: THREE.Mesh
    Cube008: THREE.Mesh
    Column: THREE.Mesh
    Column_box_bottom: THREE.Mesh
    Column_box_top: THREE.Mesh
    Cube009: THREE.Mesh
    Cube010: THREE.Mesh
    Cube011: THREE.Mesh
    Cube012: THREE.Mesh
    Cube013: THREE.Mesh
    Cube014: THREE.Mesh
    Cube015: THREE.Mesh
    Cube016: THREE.Mesh
    Cube017: THREE.Mesh
    Cube018: THREE.Mesh
    Cube019: THREE.Mesh
    Cube020: THREE.Mesh
    Cube021: THREE.Mesh
    Cube022: THREE.Mesh
    Cube023: THREE.Mesh
    Cube024: THREE.Mesh
    Cube025: THREE.Mesh
    Cube026: THREE.Mesh
    Cube027: THREE.Mesh
    Cube028: THREE.Mesh
    Cube029: THREE.Mesh
    Cube030: THREE.Mesh
    Cube031: THREE.Mesh
    Cube032: THREE.Mesh
    Cube033: THREE.Mesh
    Cube034: THREE.Mesh
    Cube035: THREE.Mesh
    Cube036: THREE.Mesh
    Cube037: THREE.Mesh
    Cube038: THREE.Mesh
    Cube040: THREE.Mesh
    Cube041: THREE.Mesh
    Cube042: THREE.Mesh
    Cube043: THREE.Mesh
    Cube044: THREE.Mesh
    Cube045: THREE.Mesh
    Cube046: THREE.Mesh
    Cube047: THREE.Mesh
    Cube048: THREE.Mesh
    Cube049: THREE.Mesh
    Cube050: THREE.Mesh
    Cube051: THREE.Mesh
    Cube053: THREE.Mesh
    Cube054: THREE.Mesh
    Cube055: THREE.Mesh
    Cube056: THREE.Mesh
    Cube057: THREE.Mesh
    Cube058: THREE.Mesh
    Cube059: THREE.Mesh
    Cube060: THREE.Mesh
    Column001: THREE.Mesh
    Column_box_bottom001: THREE.Mesh
    Column_box_top001: THREE.Mesh
    Cube061: THREE.Mesh
    Cube062: THREE.Mesh
    Cube063: THREE.Mesh
    Cube064: THREE.Mesh
    Cube065: THREE.Mesh
    Cube068: THREE.Mesh
    Cube070: THREE.Mesh
    Cube071: THREE.Mesh
    Cube072: THREE.Mesh
    Cube073: THREE.Mesh
    Cube074: THREE.Mesh
    Cube075: THREE.Mesh
    Cube076: THREE.Mesh
    Cube077: THREE.Mesh
    Cube078: THREE.Mesh
    Plane001: THREE.Mesh
    Cube069: THREE.Mesh
    Cube079: THREE.Mesh
    Cube080: THREE.Mesh
    Cube081: THREE.Mesh
    Cube082: THREE.Mesh
    Cube066: THREE.Mesh
    Cube083: THREE.Mesh
    Cube084: THREE.Mesh
    Cube085: THREE.Mesh
    Cube086: THREE.Mesh
    Cube087: THREE.Mesh
    Cube088: THREE.Mesh
    Cube089: THREE.Mesh
    Cube090: THREE.Mesh
    Cube091: THREE.Mesh
    Cube092: THREE.Mesh
    Cube093: THREE.Mesh
    Cube094: THREE.Mesh
    Cube095: THREE.Mesh
    Cube096: THREE.Mesh
    Cube097: THREE.Mesh
    Cube098: THREE.Mesh
    Cube099: THREE.Mesh
    Cube100: THREE.Mesh
    Cube101: THREE.Mesh
    Cube102: THREE.Mesh
    Cube103: THREE.Mesh
    Cube104: THREE.Mesh
    Cube105: THREE.Mesh
    Cube106: THREE.Mesh
    Cube107: THREE.Mesh
    Cube108: THREE.Mesh
    Cube109: THREE.Mesh
    Cube110: THREE.Mesh
    Cube112: THREE.Mesh
    Cube002: THREE.Mesh
    Cube114: THREE.Mesh
    Cube115: THREE.Mesh
    Cube116: THREE.Mesh
    Cube117: THREE.Mesh
    Cube118: THREE.Mesh
    Cube119: THREE.Mesh
    Cube120: THREE.Mesh
    Cube121: THREE.Mesh
    Cube122: THREE.Mesh
    Cube123: THREE.Mesh
    Cube124: THREE.Mesh
    Cube126: THREE.Mesh
    Cube127: THREE.Mesh
    Cube128: THREE.Mesh
    Cube129: THREE.Mesh
    Cube130: THREE.Mesh
    Cube131: THREE.Mesh
    Cube132: THREE.Mesh
    Cube133: THREE.Mesh
    Cube134: THREE.Mesh
    Cube125: THREE.Mesh
    Cube135: THREE.Mesh
    Cube136: THREE.Mesh
    Cube137: THREE.Mesh
    Cube138: THREE.Mesh
    Cube139: THREE.Mesh
    wall_pillar_thing_Material001_0003: THREE.Mesh
    Cube140: THREE.Mesh
    Cube141: THREE.Mesh
    Cube142: THREE.Mesh
    Cube143: THREE.Mesh
    Cube144: THREE.Mesh
    Cube145: THREE.Mesh
    wall_pillar_Material001_0001: THREE.Mesh
    wall_pillar_Material001_0002: THREE.Mesh
    wall_pillar_Material001_0003: THREE.Mesh
    wall_pillar_Material001_0004: THREE.Mesh
    wall_pillar_Material001_0005: THREE.Mesh
    wall_pillar_Material001_0006: THREE.Mesh
    wall_pillar_Material001_0007: THREE.Mesh
    Cube146: THREE.Mesh
    Cube147: THREE.Mesh
    Cube148: THREE.Mesh
    Cube149: THREE.Mesh
    Cube150: THREE.Mesh
    Cube151: THREE.Mesh
    Cube152: THREE.Mesh
    Cube153: THREE.Mesh
    Cube155: THREE.Mesh
    Cube156: THREE.Mesh
    Cube157: THREE.Mesh
    Cube158: THREE.Mesh
    wall_3_Material001_0002: THREE.Mesh
    wall_3_Material001_0003: THREE.Mesh
    Cube160: THREE.Mesh
    wall_pillar_Material001_0009: THREE.Mesh
    wall_pillar_Material001_0010: THREE.Mesh
    wall_pillar_Material001_0011: THREE.Mesh
    wall_pillar_Material001_0012: THREE.Mesh
    wall_pillar_Material001_0013: THREE.Mesh
    wall_pillar_Material001_0014: THREE.Mesh
    wall_pillar_Material001_0015: THREE.Mesh
    wall_pillar_Material001_0016: THREE.Mesh
    wall_pillar_Material001_0017: THREE.Mesh
    wall_pillar_Material001_0018: THREE.Mesh
    wall_pillar_Material001_0019: THREE.Mesh
    wall_pillar_Material001_0020: THREE.Mesh
    wall_pillar_Material001_0021: THREE.Mesh
    wall_pillar_Material001_0022: THREE.Mesh
    Cube161: THREE.Mesh
    Cube162: THREE.Mesh
    Cube164: THREE.Mesh
    Cube163: THREE.Mesh
    Cube165: THREE.Mesh
    wall_pillar_Material001_0023: THREE.Mesh
    Cube166: THREE.Mesh
    Cube167: THREE.Mesh
    Cube168: THREE.Mesh
    Cube169: THREE.Mesh
    Cube170: THREE.Mesh
    Cube172: THREE.Mesh
    Cube173: THREE.Mesh
    Cube174: THREE.Mesh
    Cube175: THREE.Mesh
    wall_pillar_thing_Material001_0010: THREE.Mesh
    wall_3_Material001_0004: THREE.Mesh
    Cube176: THREE.Mesh
    Cube177: THREE.Mesh
    Cube178: THREE.Mesh
    wall_3_Material001_0005: THREE.Mesh
    Cube179: THREE.Mesh
    Cube180: THREE.Mesh
    Cube181: THREE.Mesh
    Cube182: THREE.Mesh
    Cube183: THREE.Mesh
    Cube184: THREE.Mesh
    Cube185: THREE.Mesh
    Cube186: THREE.Mesh
    Cube187: THREE.Mesh
    Cube188: THREE.Mesh
    Cube189: THREE.Mesh
    Cube191: THREE.Mesh
    Cube192: THREE.Mesh
    Cube193: THREE.Mesh
    Cube195: THREE.Mesh
    Cube196: THREE.Mesh
    Cube197: THREE.Mesh
    Cube199: THREE.Mesh
    Cube200: THREE.Mesh
    Cube202: THREE.Mesh
    Cube203: THREE.Mesh
    Cube204: THREE.Mesh
    Cube205: THREE.Mesh
    Cube206: THREE.Mesh
    Cube207: THREE.Mesh
    Cube208: THREE.Mesh
    Cube211: THREE.Mesh
    Cube212: THREE.Mesh
    Cube213: THREE.Mesh
    Cube214: THREE.Mesh
    Cube215: THREE.Mesh
    Cube216: THREE.Mesh
    Cube217: THREE.Mesh
    Cube218: THREE.Mesh
    Cube219: THREE.Mesh
    Cube220: THREE.Mesh
    Cube221: THREE.Mesh
    Cube222: THREE.Mesh
    Cube223: THREE.Mesh
    Cube224: THREE.Mesh
    Cube225: THREE.Mesh
    Cube226: THREE.Mesh
    Cube227: THREE.Mesh
    wall_pillar_thing_Material001_0012: THREE.Mesh
    wall_pillar_thing_Material001_0013: THREE.Mesh
    wall_pillar_thing_Material001_0014: THREE.Mesh
    wall_pillar_thing_Material001_0015: THREE.Mesh
    wall_pillar_thing_Material001_0016: THREE.Mesh
    wall_pillar_thing_Material001_0017: THREE.Mesh
    wall_pillar_thing_Material001_0018: THREE.Mesh
    wall_pillar_thing_Material001_0019: THREE.Mesh
    wall_pillar_thing_Material001_0020: THREE.Mesh
    wall_pillar_thing_Material001_0021: THREE.Mesh
    wall_pillar_thing_Material001_0023: THREE.Mesh
    Cube228: THREE.Mesh
    Cube229: THREE.Mesh
    Cube230: THREE.Mesh
    Cube231: THREE.Mesh
    wall_pillar_Material001_0024: THREE.Mesh
    wall_pillar_Material001_0025: THREE.Mesh
    wall_pillar_Material001_0026: THREE.Mesh
    wall_pillar_Material001_0027: THREE.Mesh
    wall_pillar_Material001_0028: THREE.Mesh
    wall_pillar_Material001_0029: THREE.Mesh
    wall_pillar_Material001_0030: THREE.Mesh
    wall_pillar_thing_Material001_0022: THREE.Mesh
    wall_pillar_Material001_0031: THREE.Mesh
    wall_pillar_Material001_0032: THREE.Mesh
    wall_pillar_Material001_0033: THREE.Mesh
    wall_pillar_Material001_0034: THREE.Mesh
    Cube232: THREE.Mesh
    Cube233: THREE.Mesh
    Cube234: THREE.Mesh
    Cube235: THREE.Mesh
    wall_pillar_Material001_0035: THREE.Mesh
    wall_pillar_Material001_0036: THREE.Mesh
    Cube236: THREE.Mesh
    Cube238: THREE.Mesh
    Cube239: THREE.Mesh
    Cube240: THREE.Mesh
    Cube241: THREE.Mesh
    Cube242: THREE.Mesh
    Cube243: THREE.Mesh
    Cube244: THREE.Mesh
    Cube245: THREE.Mesh
    Cube246: THREE.Mesh
    Cube247: THREE.Mesh
    wall_pillar_thing_Material001_0024: THREE.Mesh
    Cube248: THREE.Mesh
    Cube249: THREE.Mesh
    Cube250: THREE.Mesh
    Cube251: THREE.Mesh
    Cube252: THREE.Mesh
    Cube253: THREE.Mesh
    Cube254: THREE.Mesh
    Cube255: THREE.Mesh
    Cube256: THREE.Mesh
    Cube257: THREE.Mesh
    Cube258: THREE.Mesh
    Cube259: THREE.Mesh
    Cube260: THREE.Mesh
    Cube261: THREE.Mesh
    Cube262: THREE.Mesh
    Cube263: THREE.Mesh
    Cube264: THREE.Mesh
    Cube265: THREE.Mesh
    Cube266: THREE.Mesh
    Cube267: THREE.Mesh
    Cube268: THREE.Mesh
    Cube269: THREE.Mesh
    Cube270: THREE.Mesh
    Cube271: THREE.Mesh
    Cube272: THREE.Mesh
    Cube273: THREE.Mesh
    Cube274: THREE.Mesh
    Cube275: THREE.Mesh
    wall_pillar_thing_Material001_0025: THREE.Mesh
    Column002: THREE.Mesh
    Column_box_top002: THREE.Mesh
    Column003: THREE.Mesh
    Column_box_top003: THREE.Mesh
    Column004: THREE.Mesh
    Column_box_top004: THREE.Mesh
    Column005: THREE.Mesh
    Column_box_top005: THREE.Mesh
    Column006: THREE.Mesh
    Column_box_top006: THREE.Mesh
    Column007: THREE.Mesh
    Column_box_top007: THREE.Mesh
    Column008: THREE.Mesh
    Column_box_top008: THREE.Mesh
    Column009: THREE.Mesh
    Column_box_top009: THREE.Mesh
    Column010: THREE.Mesh
    Column_box_top010: THREE.Mesh
    Column011: THREE.Mesh
    Column_box_top011: THREE.Mesh
    Column012: THREE.Mesh
    Column_box_top012: THREE.Mesh
    Column013: THREE.Mesh
    Column_box_top013: THREE.Mesh
    Column014: THREE.Mesh
    Column_box_top014: THREE.Mesh
    Column015: THREE.Mesh
    Column_box_top015: THREE.Mesh
    Column016: THREE.Mesh
    Column_box_top016: THREE.Mesh
    Column017: THREE.Mesh
    Column_box_top017: THREE.Mesh
    Column018: THREE.Mesh
    Column_box_top018: THREE.Mesh
    Column019: THREE.Mesh
    Column_box_top019: THREE.Mesh
    Column020: THREE.Mesh
    Column_box_top020: THREE.Mesh
    Column021: THREE.Mesh
    Column_box_top021: THREE.Mesh
    Column022: THREE.Mesh
    Column_box_top022: THREE.Mesh
    Column023: THREE.Mesh
    Column_box_top023: THREE.Mesh
    Column024: THREE.Mesh
    Column_box_top024: THREE.Mesh
    Column025: THREE.Mesh
    Column_box_top025: THREE.Mesh
    Column026: THREE.Mesh
    Column_box_top026: THREE.Mesh
    Column027: THREE.Mesh
    Column_box_top027: THREE.Mesh
    Column028: THREE.Mesh
    Column029: THREE.Mesh
    Column_box_top028: THREE.Mesh
    Column030: THREE.Mesh
    Column_box_top029: THREE.Mesh
    Column031: THREE.Mesh
    Column_box_top030: THREE.Mesh
    Column032: THREE.Mesh
    Column_box_top031: THREE.Mesh
    Column033: THREE.Mesh
    Column_box_top032: THREE.Mesh
    Column034: THREE.Mesh
    Column_box_top033: THREE.Mesh
    Column035: THREE.Mesh
    Column_box_top034: THREE.Mesh
    Column036: THREE.Mesh
    Column_box_top035: THREE.Mesh
    Column037: THREE.Mesh
    Column_box_top036: THREE.Mesh
    Column038: THREE.Mesh
    Column_box_top037: THREE.Mesh
    Column039: THREE.Mesh
    Column_box_top038: THREE.Mesh
    Column040: THREE.Mesh
    Column_box_top039: THREE.Mesh
    Column041: THREE.Mesh
    Column_box_top040: THREE.Mesh
    Column042: THREE.Mesh
    Column_box_top041: THREE.Mesh
    Column043: THREE.Mesh
    Column044: THREE.Mesh
    Column_box_top042: THREE.Mesh
    Column045: THREE.Mesh
    Column_box_top043: THREE.Mesh
    Column046: THREE.Mesh
    Column_box_top044: THREE.Mesh
    Column047: THREE.Mesh
    Column_box_top045: THREE.Mesh
    Column048: THREE.Mesh
    Column049: THREE.Mesh
    Column_box_top046: THREE.Mesh
    Column050: THREE.Mesh
    Column_box_top047: THREE.Mesh
    Column051: THREE.Mesh
    Column_box_top048: THREE.Mesh
    Column052: THREE.Mesh
    Column_box_top049: THREE.Mesh
    Column053: THREE.Mesh
    Column_box_top050: THREE.Mesh
    Column054: THREE.Mesh
    Column_box_top051: THREE.Mesh
    Column055: THREE.Mesh
    Column_box_top052: THREE.Mesh
    Column056: THREE.Mesh
    Column_box_top053: THREE.Mesh
    Column057: THREE.Mesh
    Column_box_top054: THREE.Mesh
    Column058: THREE.Mesh
    Column_box_top055: THREE.Mesh
    Column059: THREE.Mesh
    Column_box_top056: THREE.Mesh
    Column060: THREE.Mesh
    Column_box_top057: THREE.Mesh
    Column061: THREE.Mesh
    Column_box_top058: THREE.Mesh
    Column062: THREE.Mesh
    Column_box_top059: THREE.Mesh
    Column063: THREE.Mesh
    Column064: THREE.Mesh
    Column_box_top060: THREE.Mesh
    Column065: THREE.Mesh
    Column_box_top061: THREE.Mesh
    Column066: THREE.Mesh
    Column_box_top062: THREE.Mesh
    Column067: THREE.Mesh
    Column_box_top063: THREE.Mesh
    Column068: THREE.Mesh
    Column_box_top064: THREE.Mesh
    Column069: THREE.Mesh
    Column_box_top065: THREE.Mesh
    Column070: THREE.Mesh
    Column_box_top066: THREE.Mesh
    Column071: THREE.Mesh
    Column_box_top067: THREE.Mesh
    Column072: THREE.Mesh
    Column_box_top068: THREE.Mesh
    Column073: THREE.Mesh
    Column074: THREE.Mesh
    Column_box_top069: THREE.Mesh
    Column075: THREE.Mesh
    Column_box_top070: THREE.Mesh
    Column076: THREE.Mesh
    Column_box_top071: THREE.Mesh
    Column077: THREE.Mesh
    Column_box_top072: THREE.Mesh
    Column078: THREE.Mesh
    Column079: THREE.Mesh
    Column_box_top073: THREE.Mesh
    Column080: THREE.Mesh
    Column_box_top074: THREE.Mesh
    Column081: THREE.Mesh
    Column_box_top075: THREE.Mesh
    Column082: THREE.Mesh
    Column_box_top076: THREE.Mesh
    Column083: THREE.Mesh
    Column_box_top077: THREE.Mesh
    Column084: THREE.Mesh
    Column_box_top078: THREE.Mesh
    Column085: THREE.Mesh
    Column_box_top079: THREE.Mesh
    Cube276: THREE.Mesh
    Cube277: THREE.Mesh
    Cube278: THREE.Mesh
    Cube279: THREE.Mesh
    Cube280: THREE.Mesh
    Cube282: THREE.Mesh
    Cube283: THREE.Mesh
    Cube284: THREE.Mesh
    Cube285: THREE.Mesh
    Cube286: THREE.Mesh
    Cube287: THREE.Mesh
    wall_pillar_thing_Material001_0026: THREE.Mesh
    Column086: THREE.Mesh
    Column087: THREE.Mesh
    Column088: THREE.Mesh
    Column089: THREE.Mesh
    Column090: THREE.Mesh
    Column091: THREE.Mesh
    Column092: THREE.Mesh
    Column093: THREE.Mesh
    Column094: THREE.Mesh
    Cube288: THREE.Mesh
    Cube289: THREE.Mesh
    Cube290: THREE.Mesh
    Cube291: THREE.Mesh
    Cube292: THREE.Mesh
    Cube293: THREE.Mesh
    Cube294: THREE.Mesh
    Cube295: THREE.Mesh
    Cube296: THREE.Mesh
    Cube297: THREE.Mesh
    Cube298: THREE.Mesh
    Cube299: THREE.Mesh
    Cube300: THREE.Mesh
    Cube301: THREE.Mesh
    Cube302: THREE.Mesh
    Cube303: THREE.Mesh
    Cube304: THREE.Mesh
    Cube305: THREE.Mesh
    Cube306: THREE.Mesh
    Cube307: THREE.Mesh
    Cube308: THREE.Mesh
    Cube309: THREE.Mesh
    Cube310: THREE.Mesh
    Cube311: THREE.Mesh
    Cube312: THREE.Mesh
    Cube314: THREE.Mesh
    Cube315: THREE.Mesh
    Column095: THREE.Mesh
    Column096: THREE.Mesh
    Column097: THREE.Mesh
    Column098: THREE.Mesh
    Column099: THREE.Mesh
    Column100: THREE.Mesh
    Column101: THREE.Mesh
    Cube316: THREE.Mesh
    Cube318: THREE.Mesh
    Cube319: THREE.Mesh
    Cube320: THREE.Mesh
    Column103: THREE.Mesh
    Column104: THREE.Mesh
    Cube322: THREE.Mesh
    Cube323: THREE.Mesh
    Cube324: THREE.Mesh
    Cube325: THREE.Mesh
    Cube326: THREE.Mesh
    Cube327: THREE.Mesh
    Cube329: THREE.Mesh
    Cube330: THREE.Mesh
    Cube331: THREE.Mesh
    Cube332: THREE.Mesh
    Cube334: THREE.Mesh
    Cube336: THREE.Mesh
    Cube337: THREE.Mesh
    Cube338: THREE.Mesh
    Cube339: THREE.Mesh
    Cube340: THREE.Mesh
    Cube341: THREE.Mesh
    Cube342: THREE.Mesh
    Cube343: THREE.Mesh
    Cube344: THREE.Mesh
    Cube345: THREE.Mesh
    Cube346: THREE.Mesh
    Cube347: THREE.Mesh
    Cube348: THREE.Mesh
    Cube349: THREE.Mesh
    Cube350: THREE.Mesh
    Cube351: THREE.Mesh
    Cube335: THREE.Mesh
    Cube352: THREE.Mesh
    Cube353: THREE.Mesh
    Cube354: THREE.Mesh
    Cube355: THREE.Mesh
    Cube356: THREE.Mesh
    Cube357: THREE.Mesh
    Cube358: THREE.Mesh
    Cube359: THREE.Mesh
    Cube360: THREE.Mesh
    Cube201: THREE.Mesh
    Cube361: THREE.Mesh
    Cube362: THREE.Mesh
    Cube363: THREE.Mesh
    wall_pillar_Material001_0037: THREE.Mesh
    wall_pillar_Material001_0038: THREE.Mesh
    wall_pillar_Material001_0039: THREE.Mesh
    wall_pillar_Material001_0040: THREE.Mesh
    wall_pillar_Material001_0041: THREE.Mesh
    wall_pillar_Material001_0042: THREE.Mesh
    wall_pillar_Material001_0043: THREE.Mesh
    wall_pillar_Material001_0044: THREE.Mesh
    wall_pillar_Material001_0045: THREE.Mesh
    wall_pillar_Material001_0046: THREE.Mesh
    wall_thick_3_Material001_0001: THREE.Mesh
    wall_thick_3_Material001_0002: THREE.Mesh
    wall_thick_3_Material001_0003: THREE.Mesh
    wall_pillar_Material001_0047: THREE.Mesh
    Cube364: THREE.Mesh
    Cube111: THREE.Mesh
    Cube365: THREE.Mesh
    Cube366: THREE.Mesh
    Cube367: THREE.Mesh
    Cube368: THREE.Mesh
    Cube369: THREE.Mesh
    Cube372: THREE.Mesh
    Cube373: THREE.Mesh
    Cube374: THREE.Mesh
    Plane003: THREE.Mesh
    Cube375: THREE.Mesh
    Cube067: THREE.Mesh
    Plane004: THREE.Mesh
    Cube376: THREE.Mesh
    Cube377: THREE.Mesh
    Cube378: THREE.Mesh
    Cube379: THREE.Mesh
    Cube380: THREE.Mesh
    Cube381: THREE.Mesh
    Cube382: THREE.Mesh
    Cube384: THREE.Mesh
    Cube385: THREE.Mesh
    Cube383: THREE.Mesh
    Cube386: THREE.Mesh
    Cube387: THREE.Mesh
    Cube388: THREE.Mesh
    Cube389: THREE.Mesh
    Cube390: THREE.Mesh
    Cube391: THREE.Mesh
    Cube392: THREE.Mesh
    Cube393: THREE.Mesh
    Cube394: THREE.Mesh
    Cube395: THREE.Mesh
    Cube396: THREE.Mesh
    Cube397: THREE.Mesh
    Cube398: THREE.Mesh
    Cube399: THREE.Mesh
    Cube400: THREE.Mesh
    Cube401: THREE.Mesh
    Cube402: THREE.Mesh
    Cube403: THREE.Mesh
    Cube406: THREE.Mesh
    Cube407: THREE.Mesh
    Cube408: THREE.Mesh
    Cube409: THREE.Mesh
    Cube405: THREE.Mesh
    Cube410: THREE.Mesh
    Cube411: THREE.Mesh
    Cube412: THREE.Mesh
    Cube413: THREE.Mesh
    Cube414: THREE.Mesh
    Cube415: THREE.Mesh
    Cube416: THREE.Mesh
    Cube417: THREE.Mesh
    Cube418: THREE.Mesh
    Cube419: THREE.Mesh
    Cube420: THREE.Mesh
    Cube421: THREE.Mesh
    Cube422: THREE.Mesh
    Cube423: THREE.Mesh
    Cube424: THREE.Mesh
    Cube425: THREE.Mesh
    Cube426: THREE.Mesh
    Cube427: THREE.Mesh
    Cube428: THREE.Mesh
    Cube429: THREE.Mesh
    Cube430: THREE.Mesh
    Cube431: THREE.Mesh
    Cube432: THREE.Mesh
    Cube433: THREE.Mesh
    Cube434: THREE.Mesh
    Cube435: THREE.Mesh
    Cube439: THREE.Mesh
    Cube440: THREE.Mesh
    Cube441: THREE.Mesh
    Cube442: THREE.Mesh
    Cube443: THREE.Mesh
    Cube445: THREE.Mesh
    Cube444: THREE.Mesh
    Cube446: THREE.Mesh
    Cube447: THREE.Mesh
    Cube448: THREE.Mesh
    Cube449: THREE.Mesh
    Cube450: THREE.Mesh
    Cube451: THREE.Mesh
    Cube452: THREE.Mesh
    Cube453: THREE.Mesh
    Cube457: THREE.Mesh
    Cube458: THREE.Mesh
    Cube459: THREE.Mesh
    Cube460: THREE.Mesh
    Cube461: THREE.Mesh
    Cube462: THREE.Mesh
    Cube463: THREE.Mesh
    Cube464: THREE.Mesh
    Cube465: THREE.Mesh
    Cube466: THREE.Mesh
    Cube467: THREE.Mesh
    Cube468: THREE.Mesh
    Cube472: THREE.Mesh
    Cube473: THREE.Mesh
    Cube474: THREE.Mesh
    Cube477: THREE.Mesh
    Cube479: THREE.Mesh
    Cube480: THREE.Mesh
    Cube481: THREE.Mesh
    Cube482: THREE.Mesh
    Cube483: THREE.Mesh
    Cube484: THREE.Mesh
    Cube485: THREE.Mesh
    Cube486: THREE.Mesh
    Cube487: THREE.Mesh
    Cube488: THREE.Mesh
    Cube489: THREE.Mesh
    Cube490: THREE.Mesh
    Cube491: THREE.Mesh
    Cube492: THREE.Mesh
    Cube493: THREE.Mesh
    Cube494: THREE.Mesh
    Cube495: THREE.Mesh
    Cube496: THREE.Mesh
    Cube497: THREE.Mesh
    Cube498: THREE.Mesh
    Cube499: THREE.Mesh
    Cube500: THREE.Mesh
    Cube501: THREE.Mesh
    Cube502: THREE.Mesh
    Cube503: THREE.Mesh
    Cube504: THREE.Mesh
    Cube505: THREE.Mesh
    Cube506: THREE.Mesh
    Cube507: THREE.Mesh
    Cube508: THREE.Mesh
    Cube509: THREE.Mesh
    Cube510: THREE.Mesh
    Cube511: THREE.Mesh
    Cube512: THREE.Mesh
    Cube513: THREE.Mesh
    Cube514: THREE.Mesh
    Cube515: THREE.Mesh
    Cube516: THREE.Mesh
    Cube517: THREE.Mesh
    Cube518: THREE.Mesh
    Cube519: THREE.Mesh
    Cube520: THREE.Mesh
    Cube521: THREE.Mesh
    Cube522: THREE.Mesh
    Cube523: THREE.Mesh
    Cube524: THREE.Mesh
    Cube525: THREE.Mesh
    Cube526: THREE.Mesh
    Cube527: THREE.Mesh
    Cube528: THREE.Mesh
    Cube529: THREE.Mesh
    Cube530: THREE.Mesh
    Cube531: THREE.Mesh
    Cube532: THREE.Mesh
    Cube533: THREE.Mesh
    Cube534: THREE.Mesh
    Cube535: THREE.Mesh
    Cube404: THREE.Mesh
    Cube536: THREE.Mesh
    Cube537: THREE.Mesh
    Cube538: THREE.Mesh
    wall_3_Material001_0007: THREE.Mesh
    Cube539: THREE.Mesh
    Cube540: THREE.Mesh
    Cube541: THREE.Mesh
    Cube542: THREE.Mesh
    Cube543: THREE.Mesh
    Cube544: THREE.Mesh
    Cube545: THREE.Mesh
    Cube546: THREE.Mesh
    Cube547: THREE.Mesh
    Cube548: THREE.Mesh
    Cube549: THREE.Mesh
    Cube550: THREE.Mesh
    Cube551: THREE.Mesh
    Cube552: THREE.Mesh
    Cube553: THREE.Mesh
    Cube554: THREE.Mesh
    Cube555: THREE.Mesh
    Cube556: THREE.Mesh
    Cube557: THREE.Mesh
    Cube558: THREE.Mesh
    Cube559: THREE.Mesh
    Cube560: THREE.Mesh
    Cube561: THREE.Mesh
    Cube562: THREE.Mesh
    Cube563: THREE.Mesh
    Cube564: THREE.Mesh
    Cube565: THREE.Mesh
    Cube566: THREE.Mesh
    Cube567: THREE.Mesh
    Cube568: THREE.Mesh
    Cube569: THREE.Mesh
    Cube570: THREE.Mesh
    Object_4003: THREE.Mesh
    Cube190: THREE.Mesh
    Cube313: THREE.Mesh
    Column102: THREE.Mesh
    Column105: THREE.Mesh
    Column106: THREE.Mesh
    Column107: THREE.Mesh
    Column108: THREE.Mesh
    Column109: THREE.Mesh
    Column110: THREE.Mesh
    Column111: THREE.Mesh
    Column112: THREE.Mesh
    Column113: THREE.Mesh
    Column114: THREE.Mesh
    Column115: THREE.Mesh
    Column116: THREE.Mesh
    Column117: THREE.Mesh
    Column118: THREE.Mesh
    Column119: THREE.Mesh
    Column120: THREE.Mesh
    Column121: THREE.Mesh
    Column122: THREE.Mesh
    Column123: THREE.Mesh
    Column124: THREE.Mesh
    Column125: THREE.Mesh
    Column126: THREE.Mesh
    Column127: THREE.Mesh
    Column128: THREE.Mesh
    Column129: THREE.Mesh
    Column130: THREE.Mesh
    Column131: THREE.Mesh
    Column132: THREE.Mesh
    Column133: THREE.Mesh
    Cube370: THREE.Mesh
    Cube371: THREE.Mesh
    Cube436: THREE.Mesh
    Column134: THREE.Mesh
    Column135: THREE.Mesh
    Column136: THREE.Mesh
    Column137: THREE.Mesh
    Column138: THREE.Mesh
    Column139: THREE.Mesh
    Column140: THREE.Mesh
    Column141: THREE.Mesh
    Column142: THREE.Mesh
    Column143: THREE.Mesh
    Column144: THREE.Mesh
    Column145: THREE.Mesh
    Cube437: THREE.Mesh
    Cube438: THREE.Mesh
    Cube454: THREE.Mesh
    Cube455: THREE.Mesh
    Cube456: THREE.Mesh
    Cube571: THREE.Mesh
    Cube572: THREE.Mesh
    Cube573: THREE.Mesh
    Cube574: THREE.Mesh
    Cube575: THREE.Mesh
    Cube576: THREE.Mesh
    Cube577: THREE.Mesh
    Cube578: THREE.Mesh
    Cube579: THREE.Mesh
    Cube580: THREE.Mesh
    Cube581: THREE.Mesh
    Cube582: THREE.Mesh
    Cube583: THREE.Mesh
    Cube584: THREE.Mesh
    Column146: THREE.Mesh
    Column_box_top080: THREE.Mesh
    Column147: THREE.Mesh
    Column_box_top081: THREE.Mesh
    Column148: THREE.Mesh
    Column_box_top082: THREE.Mesh
    Column149: THREE.Mesh
    Column_box_top083: THREE.Mesh
    Column150: THREE.Mesh
    Column_box_top084: THREE.Mesh
    Column151: THREE.Mesh
    Column_box_top085: THREE.Mesh
    Column152: THREE.Mesh
    Column_box_top086: THREE.Mesh
    Cube585: THREE.Mesh
    Cube586: THREE.Mesh
    Cube587: THREE.Mesh
    Cube588: THREE.Mesh
    Cube589: THREE.Mesh
    Cube590: THREE.Mesh
    Cube591: THREE.Mesh
    Cube592: THREE.Mesh
    Cube159: THREE.Mesh
    Cube593: THREE.Mesh
    wall_3_Material001_0001: THREE.Mesh
    wall_3_Material001_0006: THREE.Mesh
    wall_3_Material001_0008: THREE.Mesh
    Cube333: THREE.Mesh
    Cube594: THREE.Mesh
    Cube595: THREE.Mesh
    Cube596: THREE.Mesh
    wall_3_Material001_0009: THREE.Mesh
    wall_3_Material001_0010: THREE.Mesh
    wall_3_Material001_0011: THREE.Mesh
    wall_3_Material001_0012: THREE.Mesh
    wall_3_Material001_0013: THREE.Mesh
    Cube113: THREE.Mesh
    Cube469: THREE.Mesh
    Cube470: THREE.Mesh
    Cube471: THREE.Mesh
    Cube475: THREE.Mesh
    Cube171: THREE.Mesh
    Cube194: THREE.Mesh
    Cube154: THREE.Mesh
    Cube237: THREE.Mesh
    Cube281: THREE.Mesh
    Cube317: THREE.Mesh
    Cube476: THREE.Mesh
    Cube478: THREE.Mesh
    Object_12002: THREE.Mesh
    Object_12003: THREE.Mesh
    Object_12004: THREE.Mesh
    Object_12005: THREE.Mesh
    Object_12006: THREE.Mesh
    Object_12007: THREE.Mesh
    Object_12008: THREE.Mesh
    Object_19001: THREE.Mesh
    Object_19003: THREE.Mesh
    Object_10002: THREE.Mesh
    Object_10003: THREE.Mesh
    Cube598: THREE.Mesh
    endtable1_top__low003_endtable1_0001: THREE.Mesh
    endtable1_top__low003_endtable1_0002: THREE.Mesh
    lampscrew_low001_lamp01_0001: THREE.Mesh
    chairlegs_low001_chair1_0001: THREE.Mesh
    Object_19004: THREE.Mesh
    Object_19005: THREE.Mesh
    Object_19006: THREE.Mesh
    Object_19007: THREE.Mesh
    Object_34002: THREE.Mesh
    Object_34003: THREE.Mesh
    Object_34004: THREE.Mesh
    Object_34005: THREE.Mesh
    Object_34006: THREE.Mesh
    Object_34007: THREE.Mesh
    Object_17003: THREE.Mesh
    Object_11003: THREE.Mesh
    Object_8005: THREE.Mesh
    Object_8006: THREE.Mesh
    Cube485_Material002_0001: THREE.Mesh
    Cube484_Material002_0001: THREE.Mesh
    Cube483_Material002_0001: THREE.Mesh
    Cube482_Material002_0001: THREE.Mesh
    Cube481_Material002_0001: THREE.Mesh
    Cube480_Material002_0001: THREE.Mesh
    Cube479_Material002_0001: THREE.Mesh
    Cube478_Material002_0001: THREE.Mesh
    Cube477_Material002_0001: THREE.Mesh
    Cube476_Material002_0001: THREE.Mesh
    Cylinder292_Material006_0001: THREE.Mesh
    Cylinder290_Material006_0001: THREE.Mesh
    Cube476_Material002_0002: THREE.Mesh
    Cube477_Material002_0002: THREE.Mesh
    Cube478_Material002_0002: THREE.Mesh
    Cube479_Material002_0002: THREE.Mesh
    Cube480_Material002_0002: THREE.Mesh
    Cube481_Material002_0002: THREE.Mesh
    Cube483_Material002_0002: THREE.Mesh
    Cube484_Material002_0002: THREE.Mesh
    Cube485_Material002_0002: THREE.Mesh
    Cylinder290_Material006_0002: THREE.Mesh
    Cylinder292_Material006_0002: THREE.Mesh
    Cube480_Material002_0003: THREE.Mesh
    Cube480_Material002_0004: THREE.Mesh
    Cube480_Material002_0005: THREE.Mesh
    Cube480_Material002_0006: THREE.Mesh
    Cube480_Material002_0007: THREE.Mesh
    Cube480_Material002_0008: THREE.Mesh
    Cube480_Material002_0009: THREE.Mesh
    Cube480_Material002_0010: THREE.Mesh
    Cube483_Material002_0003: THREE.Mesh
    Cube480_Material002_0011: THREE.Mesh
    Cube483_Material002_0004: THREE.Mesh
    Cylinder292_Material006_0003: THREE.Mesh
    Cylinder290_Material006_0003: THREE.Mesh
    Cube485_Material002_0003: THREE.Mesh
    Cube485_Material002_0004: THREE.Mesh
    Cube480_Material002_0012: THREE.Mesh
    Cube480_Material002_0013: THREE.Mesh
    Cube480_Material002_0014: THREE.Mesh
    Cube480_Material002_0015: THREE.Mesh
    Cube480_Material002_0016: THREE.Mesh
    Cube480_Material002_0017: THREE.Mesh
    Cube480_Material002_0018: THREE.Mesh
    Cube480_Material002_0019: THREE.Mesh
    Cube480_Material002_0020: THREE.Mesh
    Cube480_Material002_0021: THREE.Mesh
    Cube480_Material002_0022: THREE.Mesh
    Cube480_Material002_0023: THREE.Mesh
    Cube480_Material002_0024: THREE.Mesh
    Cube480_Material002_0025: THREE.Mesh
    Cube480_Material002_0026: THREE.Mesh
    Cube480_Material002_0027: THREE.Mesh
    Cube480_Material002_0028: THREE.Mesh
    Cube480_Material002_0029: THREE.Mesh
    Cube480_Material002_0030: THREE.Mesh
    Cube480_Material002_0031: THREE.Mesh
    Cube480_Material002_0032: THREE.Mesh
    Cube480_Material002_0033: THREE.Mesh
    Cube480_Material002_0034: THREE.Mesh
    Cube480_Material002_0035: THREE.Mesh
    Cube480_Material002_0036: THREE.Mesh
    Cube480_Material002_0037: THREE.Mesh
    Cube480_Material002_0038: THREE.Mesh
    Cube480_Material002_0039: THREE.Mesh
    Cube480_Material002_0040: THREE.Mesh
    Cube480_Material002_0041: THREE.Mesh
    Cube480_Material002_0042: THREE.Mesh
    Cube480_Material002_0043: THREE.Mesh
    Cube480_Material002_0044: THREE.Mesh
    Cube480_Material002_0045: THREE.Mesh
    Cube480_Material002_0046: THREE.Mesh
    Cube480_Material002_0047: THREE.Mesh
    Cube480_Material002_0048: THREE.Mesh
    Cube480_Material002_0049: THREE.Mesh
    Cube480_Material002_0050: THREE.Mesh
    Cube480_Material002_0051: THREE.Mesh
    Cube480_Material002_0052: THREE.Mesh
    Cube480_Material002_0053: THREE.Mesh
    Cube480_Material002_0054: THREE.Mesh
    Cube480_Material002_0055: THREE.Mesh
    Cube480_Material002_0056: THREE.Mesh
    Cube480_Material002_0057: THREE.Mesh
    Cube480_Material002_0058: THREE.Mesh
    Cube480_Material002_0059: THREE.Mesh
    Cube480_Material002_0060: THREE.Mesh
    Cube480_Material002_0061: THREE.Mesh
    Cube480_Material002_0062: THREE.Mesh
    Cube480_Material002_0063: THREE.Mesh
    Cylinder290_Material006_0004: THREE.Mesh
    Cylinder290_Material006_0005: THREE.Mesh
    Cylinder290_Material006_0006: THREE.Mesh
    Cylinder290_Material006_0007: THREE.Mesh
    Cylinder290_Material006_0008: THREE.Mesh
    Cylinder290_Material006_0009: THREE.Mesh
    Cylinder290_Material006_0010: THREE.Mesh
    Cylinder290_Material006_0011: THREE.Mesh
    Cylinder290_Material006_0012: THREE.Mesh
    Cube485_Material002_0005: THREE.Mesh
    Cube485_Material002_0006: THREE.Mesh
    Cube485_Material002_0007: THREE.Mesh
    Cube485_Material002_0008: THREE.Mesh
    Cube485_Material002_0009: THREE.Mesh
    Cube485_Material002_0010: THREE.Mesh
    Cube485_Material002_0011: THREE.Mesh
    Cube485_Material002_0012: THREE.Mesh
    Cube485_Material002_0013: THREE.Mesh
    Cube485_Material002_0014: THREE.Mesh
    Cube485_Material002_0015: THREE.Mesh
    Cube485_Material002_0016: THREE.Mesh
    Cube483_Material002_0005: THREE.Mesh
    Cube483_Material002_0006: THREE.Mesh
    Cube483_Material002_0007: THREE.Mesh
    Cube483_Material002_0008: THREE.Mesh
    Cube485_Material002_0017: THREE.Mesh
    Cube485_Material002_0018: THREE.Mesh
    Cube483_Material002_0009: THREE.Mesh
    Cube483_Material002_0010: THREE.Mesh
    Cube480_Material002_0064: THREE.Mesh
    Cube480_Material002_0065: THREE.Mesh
    Cube480_Material002_0066: THREE.Mesh
    Cube480_Material002_0067: THREE.Mesh
    Cube480_Material002_0068: THREE.Mesh
    Cube480_Material002_0069: THREE.Mesh
    Cube480_Material002_0070: THREE.Mesh
    Cube480_Material002_0071: THREE.Mesh
    Cube480_Material002_0072: THREE.Mesh
    Cylinder292_Material006_0005: THREE.Mesh
    Cylinder290_Material006_0014: THREE.Mesh
    Cube480_Material002_0073: THREE.Mesh
    Cylinder290_Material006_0015: THREE.Mesh
    Cylinder292_Material006_0006: THREE.Mesh
    Cube480_Material002_0074: THREE.Mesh
    Cube480_Material002_0075: THREE.Mesh
    Cube480_Material002_0076: THREE.Mesh
    Cube480_Material002_0077: THREE.Mesh
    Cube480_Material002_0078: THREE.Mesh
    Cube480_Material002_0079: THREE.Mesh
    Cube480_Material002_0080: THREE.Mesh
    Cube480_Material002_0081: THREE.Mesh
    Cube483_Material002_0011: THREE.Mesh
    Cube483_Material002_0012: THREE.Mesh
    Cylinder292_Material006_0007: THREE.Mesh
    Cylinder290_Material006_0016: THREE.Mesh
    Cube485_Material002_0019: THREE.Mesh
    Cube485_Material002_0020: THREE.Mesh
    Object_34011: THREE.Mesh
    Object_8008: THREE.Mesh
    Object_8009: THREE.Mesh
    Object_22002: THREE.Mesh
    Object_20005: THREE.Mesh
    Object_22003: THREE.Mesh
    Object_22004: THREE.Mesh
    wall_pillar_Material001_0008: THREE.Mesh
    endtable1_top__low006_endtable1_0001: THREE.Mesh
    endtable1_top__low003_endtable1_0003: THREE.Mesh
    lampscrew_low001_lamp01_0002: THREE.Mesh
    Object_19008: THREE.Mesh
    Object_19009: THREE.Mesh
    endtable1_top__low003_endtable1_0004: THREE.Mesh
    Cube480_Material002_0082: THREE.Mesh
    Cube480_Material002_0083: THREE.Mesh

    Object_19010: THREE.Mesh
    Object_19011: THREE.Mesh
    Object_8010: THREE.Mesh
    Object_8011: THREE.Mesh
    lampscrew_low001_lamp01_0003: THREE.Mesh
    Object_14005: THREE.Mesh
    Object_14006: THREE.Mesh
    Cube870: THREE.Mesh
    Object_22005: THREE.Mesh
    Object_22006: THREE.Mesh
    Object_12009: THREE.Mesh
    Object_12010: THREE.Mesh
    Object_12011: THREE.Mesh
    Object_12012: THREE.Mesh
    Object_12013: THREE.Mesh
    Object_12014: THREE.Mesh
    Object_20006: THREE.Mesh
    UBH_ConeShape_zOther_Props_01_0001: THREE.Mesh
    UBH_Garbage_01Shape_zMechanical_Parts_0002: THREE.Mesh
    UBH_Garbage_05Shape_zGarbage_0002: THREE.Mesh
    UBH_Garbage_05Shape_zMechanical_Parts_0002: THREE.Mesh
    UBH_Garbage_01Shape_zMechanical_Parts_0003: THREE.Mesh
    UBH_Garbage_05Shape_zGarbage_0003: THREE.Mesh
    UBH_Garbage_05Shape_zMechanical_Parts_0003: THREE.Mesh
    UBH_Machine_Part_03Shape_zMechanical_Parts_0001: THREE.Mesh
    UBH_Garbage_05Shape_zOther_Props_01_0001: THREE.Mesh
    UBH_Garbage_05Shape_zOther_Props_01_0002: THREE.Mesh
    UBH_Garbage_05Shape_zOther_Props_01_0003: THREE.Mesh
    UBH_ConeShape_zOther_Props_01_0002: THREE.Mesh
    UBH_Garbage_01Shape_zOther_Props_01_0001: THREE.Mesh
    UBH_Garbage_05Shape_zOther_Props_01_0004: THREE.Mesh
    UBH_Garbage_05Shape_zOther_Props_01_0005: THREE.Mesh
    Cube871: THREE.Mesh
    Object_19012: THREE.Mesh
    Object_22007: THREE.Mesh
    Object_23001: THREE.Mesh
    Object_19013: THREE.Mesh
    Object_20007: THREE.Mesh
    Column155: THREE.Mesh
    Column156: THREE.Mesh
    Object_19014: THREE.Mesh
    Column153: THREE.Mesh
    Cube872: THREE.Mesh
    Cube873: THREE.Mesh
    Cube874: THREE.Mesh
    Object_14007: THREE.Mesh
    Object_37003: THREE.Mesh
    Object_17005: THREE.Mesh
    Object_20008: THREE.Mesh
    Object_11004: THREE.Mesh
    Object_8012: THREE.Mesh
    Object_40002: THREE.Mesh
    Object_31002: THREE.Mesh
    Object_28001: THREE.Mesh
    Object_24003: THREE.Mesh
    Object_26003: THREE.Mesh
    Cube480_Material002_0084: THREE.Mesh
    Cube480_Material002_0085: THREE.Mesh
    endtable1_top__low003_endtable1_0005: THREE.Mesh
    Object_19015: THREE.Mesh
    Object_19016: THREE.Mesh
    endtable1_top__low003_endtable1_0006: THREE.Mesh
    endtable1_top__low006_endtable1_0002: THREE.Mesh
    lampscrew_low001_lamp01_0004: THREE.Mesh
    Object_12015: THREE.Mesh
    Object_10004: THREE.Mesh
    Column154: THREE.Mesh
    Column_box_top087: THREE.Mesh
    Cube480_Material002_0086: THREE.Mesh
    Cube480_Material002_0087: THREE.Mesh
    Cube480_Material002_0088: THREE.Mesh
    UBH_Burning_BarrelShape_zOther_Props_01_0001: THREE.Mesh
    UBH_ConeShape_zOther_Props_01_0003: THREE.Mesh
    wall_pillar_thing_Material001_0027: THREE.Mesh
    Object_6003: THREE.Mesh
    Object_8014: THREE.Mesh
    Object_9001: THREE.Mesh
    Object_4005: THREE.Mesh
    Object_4006: THREE.Mesh
    Cube198: THREE.Mesh
    Object_4007: THREE.Mesh
    defaultMaterial002: THREE.Mesh
    defaultMaterial003: THREE.Mesh
    Object_6004: THREE.Mesh
    Object_8015: THREE.Mesh
    Object_9002: THREE.Mesh
    Object_4008: THREE.Mesh
    Object_6005: THREE.Mesh
    Object_8016: THREE.Mesh
    Object_9003: THREE.Mesh
    Object_4009: THREE.Mesh
    Object_8017: THREE.Mesh
    Object_8018: THREE.Mesh
    Object_6006: THREE.Mesh
    Object_8019: THREE.Mesh
    Object_9004: THREE.Mesh
    Object_4010: THREE.Mesh
    Object_6007: THREE.Mesh
    Object_8020: THREE.Mesh
    Object_9005: THREE.Mesh
    Object_4011: THREE.Mesh
    defaultMaterial004: THREE.Mesh
    defaultMaterial005: THREE.Mesh
    Object_4012: THREE.Mesh
    Object_4013: THREE.Mesh
    defaultMaterial006: THREE.Mesh
    defaultMaterial007: THREE.Mesh
    Object_6008: THREE.Mesh
    Object_8021: THREE.Mesh
    Object_9006: THREE.Mesh
    Object_4014: THREE.Mesh
    Object_6009: THREE.Mesh
    Object_8022: THREE.Mesh
    Object_9007: THREE.Mesh
    Object_4015: THREE.Mesh
    Object_8023: THREE.Mesh
    Object_8024: THREE.Mesh
    Object_6010: THREE.Mesh
    Object_8025: THREE.Mesh
    Object_9008: THREE.Mesh
    Object_4016: THREE.Mesh
    Object_6011: THREE.Mesh
    Object_8026: THREE.Mesh
    Object_9009: THREE.Mesh
    Object_4017: THREE.Mesh
    defaultMaterial008: THREE.Mesh
    defaultMaterial009: THREE.Mesh
    Object_4018: THREE.Mesh
    Object_4019: THREE.Mesh
    defaultMaterial010: THREE.Mesh
    defaultMaterial011: THREE.Mesh
    Object_6012: THREE.Mesh
    Object_8027: THREE.Mesh
    Object_9010: THREE.Mesh
    Object_4020: THREE.Mesh
    Object_6013: THREE.Mesh
    Object_8028: THREE.Mesh
    Object_9011: THREE.Mesh
    Object_4021: THREE.Mesh
    Object_8029: THREE.Mesh
    Object_4022: THREE.Mesh
    defaultMaterial012: THREE.Mesh
    defaultMaterial013: THREE.Mesh
    Object_6014: THREE.Mesh
    Object_8030: THREE.Mesh
    Object_9012: THREE.Mesh
    Object_4023: THREE.Mesh
    Object_6015: THREE.Mesh
    Object_8031: THREE.Mesh
    Object_9013: THREE.Mesh
    Object_4024: THREE.Mesh
    Object_8032: THREE.Mesh
    wall_pillar_thing_Material001_0028: THREE.Mesh
    wall_pillar_thing_Material001_0029: THREE.Mesh
    wall_pillar_thing_Material001_0030: THREE.Mesh
    wall_pillar_thing_Material001_0031: THREE.Mesh
    wall_pillar_thing_Material001_0032: THREE.Mesh
    wall_pillar_thing_Material001_0033: THREE.Mesh
    wall_pillar_thing_Material001_0001: THREE.Mesh
    wall_pillar_thing_Material001_0002: THREE.Mesh
    wall_pillar_thing_Material001_0004: THREE.Mesh
    wall_pillar_thing_Material001_0006: THREE.Mesh
  }
  materials: {
    Ceiling_Light_Surrounds: THREE.MeshStandardMaterial
    ['Material.086']: THREE.MeshStandardMaterial
    ['Material.221']: THREE.MeshStandardMaterial
    Column_material: THREE.MeshStandardMaterial
    Column_rect: THREE.MeshStandardMaterial
    ['Column_material.001']: THREE.MeshStandardMaterial
    ['Column_rect.001']: THREE.MeshStandardMaterial
    ['Material.222']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.072']: THREE.MeshStandardMaterial
    hosp: THREE.MeshStandardMaterial
    ['Material.007']: THREE.MeshStandardMaterial
    ['Material.009']: THREE.MeshStandardMaterial
    ['Material.011']: THREE.MeshStandardMaterial
    ['Material.012']: THREE.MeshStandardMaterial
    ['Material.013']: THREE.MeshStandardMaterial
    ['Material.022']: THREE.MeshStandardMaterial
    ['Material.014']: THREE.MeshStandardMaterial
    ['Material.015']: THREE.MeshStandardMaterial
    ['Material.029']: THREE.MeshStandardMaterial
    ['Material.030']: THREE.MeshStandardMaterial
    ['Material.031']: THREE.MeshStandardMaterial
    ['Material.032']: THREE.MeshStandardMaterial
    ['Material.033']: THREE.MeshStandardMaterial
    ['Material.034']: THREE.MeshStandardMaterial
    ['Material.035']: THREE.MeshStandardMaterial
    ['Material.045']: THREE.MeshStandardMaterial
    ['Material.046']: THREE.MeshStandardMaterial
    ['Material.047']: THREE.MeshStandardMaterial
    ['Material.050']: THREE.MeshStandardMaterial
    ['Material.051']: THREE.MeshStandardMaterial
    ['Material.052']: THREE.MeshStandardMaterial
    ['Material.053']: THREE.MeshStandardMaterial
    ['Material.054']: THREE.MeshStandardMaterial
    ['Material.055']: THREE.MeshStandardMaterial
    ['Material.056']: THREE.MeshStandardMaterial
    ['Material.057']: THREE.MeshStandardMaterial
    ['Material.058']: THREE.MeshStandardMaterial
    ['Material.059']: THREE.MeshStandardMaterial
    ['Material.060']: THREE.MeshStandardMaterial
    ['Material.061']: THREE.MeshStandardMaterial
    ['Material.062']: THREE.MeshStandardMaterial
    ['Material.063']: THREE.MeshStandardMaterial
    ['Material.065']: THREE.MeshStandardMaterial
    ['Material.066']: THREE.MeshStandardMaterial
    ['Material.068']: THREE.MeshStandardMaterial
    ['Material.069']: THREE.MeshStandardMaterial
    ['Material.070']: THREE.MeshStandardMaterial
    ['Material.073']: THREE.MeshStandardMaterial
    ['Material.074']: THREE.MeshStandardMaterial
    ['Material.075']: THREE.MeshStandardMaterial
    ['Material.076']: THREE.MeshStandardMaterial
    ['Material.078']: THREE.MeshStandardMaterial
    ['Material.474']: THREE.MeshStandardMaterial
    ['Material.080']: THREE.MeshStandardMaterial
    ['Material.081']: THREE.MeshStandardMaterial
    ['Material.079']: THREE.MeshStandardMaterial
    ['Material.477']: THREE.MeshStandardMaterial
    ['Material.087']: THREE.MeshStandardMaterial
    ['Material.090']: THREE.MeshStandardMaterial
    ['Material.091']: THREE.MeshStandardMaterial
    ['Material.092']: THREE.MeshStandardMaterial
    ['Material.093']: THREE.MeshStandardMaterial
    ['Material.094']: THREE.MeshStandardMaterial
    ['Material.095']: THREE.MeshStandardMaterial
    ['Material.096']: THREE.MeshStandardMaterial
    ['Material.098']: THREE.MeshStandardMaterial
    ['Material.083']: THREE.MeshStandardMaterial
    ['Material.100']: THREE.MeshStandardMaterial
    ['Material.102']: THREE.MeshStandardMaterial
    ['Material.103']: THREE.MeshStandardMaterial
    ['Material.104']: THREE.MeshStandardMaterial
    ['Material.106']: THREE.MeshStandardMaterial
    ['Material.107']: THREE.MeshStandardMaterial
    ['Material.108']: THREE.MeshStandardMaterial
    ['Material.110']: THREE.MeshStandardMaterial
    ['Material.111']: THREE.MeshStandardMaterial
    ['Material.113']: THREE.MeshStandardMaterial
    ['Material.114']: THREE.MeshStandardMaterial
    ['Material.115']: THREE.MeshStandardMaterial
    ['Material.133']: THREE.MeshStandardMaterial
    ['Material.134']: THREE.MeshStandardMaterial
    ['Material.135']: THREE.MeshStandardMaterial
    ['Material.136']: THREE.MeshStandardMaterial
    ['Material.137']: THREE.MeshStandardMaterial
    ['Material.138']: THREE.MeshStandardMaterial
    ['Material.139']: THREE.MeshStandardMaterial
    ['Material.140']: THREE.MeshStandardMaterial
    ['Material.141']: THREE.MeshStandardMaterial
    ['Material.142']: THREE.MeshStandardMaterial
    ['Material.143']: THREE.MeshStandardMaterial
    ['Material.145']: THREE.MeshStandardMaterial
    ['Material.149']: THREE.MeshStandardMaterial
    ['Material.150']: THREE.MeshStandardMaterial
    ['Material.151']: THREE.MeshStandardMaterial
    ['Material.152']: THREE.MeshStandardMaterial
    ['Material.153']: THREE.MeshStandardMaterial
    ['Material.154']: THREE.MeshStandardMaterial
    ['Material.155']: THREE.MeshStandardMaterial
    ['Material.156']: THREE.MeshStandardMaterial
    ['Material.157']: THREE.MeshStandardMaterial
    ['Material.158']: THREE.MeshStandardMaterial
    ['Material.159']: THREE.MeshStandardMaterial
    ['Material.160']: THREE.MeshStandardMaterial
    ['Material.165']: THREE.MeshStandardMaterial
    ['Material.166']: THREE.MeshStandardMaterial
    ['Material.167']: THREE.MeshStandardMaterial
    ['Material.168']: THREE.MeshStandardMaterial
    ['Material.169']: THREE.MeshStandardMaterial
    ['Column_material.002']: THREE.MeshStandardMaterial
    ['Column_rect.002']: THREE.MeshStandardMaterial
    ['Column_material.003']: THREE.MeshStandardMaterial
    ['Column_rect.003']: THREE.MeshStandardMaterial
    ['Column_material.004']: THREE.MeshStandardMaterial
    ['Column_rect.004']: THREE.MeshStandardMaterial
    ['Column_material.005']: THREE.MeshStandardMaterial
    ['Column_rect.005']: THREE.MeshStandardMaterial
    ['Column_material.006']: THREE.MeshStandardMaterial
    ['Column_rect.006']: THREE.MeshStandardMaterial
    ['Column_material.007']: THREE.MeshStandardMaterial
    ['Column_rect.007']: THREE.MeshStandardMaterial
    ['Column_material.008']: THREE.MeshStandardMaterial
    ['Column_rect.008']: THREE.MeshStandardMaterial
    ['Column_material.009']: THREE.MeshStandardMaterial
    ['Column_rect.009']: THREE.MeshStandardMaterial
    ['Column_material.010']: THREE.MeshStandardMaterial
    ['Column_rect.010']: THREE.MeshStandardMaterial
    ['Column_material.011']: THREE.MeshStandardMaterial
    ['Column_rect.011']: THREE.MeshStandardMaterial
    ['Column_material.012']: THREE.MeshStandardMaterial
    ['Column_rect.012']: THREE.MeshStandardMaterial
    ['Column_material.013']: THREE.MeshStandardMaterial
    ['Column_rect.013']: THREE.MeshStandardMaterial
    ['Column_material.014']: THREE.MeshStandardMaterial
    ['Column_rect.014']: THREE.MeshStandardMaterial
    ['Column_material.015']: THREE.MeshStandardMaterial
    ['Column_rect.015']: THREE.MeshStandardMaterial
    ['Column_material.016']: THREE.MeshStandardMaterial
    ['Column_rect.016']: THREE.MeshStandardMaterial
    ['Column_material.017']: THREE.MeshStandardMaterial
    ['Column_rect.017']: THREE.MeshStandardMaterial
    ['Column_material.018']: THREE.MeshStandardMaterial
    ['Column_rect.018']: THREE.MeshStandardMaterial
    ['Column_material.019']: THREE.MeshStandardMaterial
    ['Column_rect.019']: THREE.MeshStandardMaterial
    ['Column_material.020']: THREE.MeshStandardMaterial
    ['Column_rect.020']: THREE.MeshStandardMaterial
    ['Column_material.021']: THREE.MeshStandardMaterial
    ['Column_rect.021']: THREE.MeshStandardMaterial
    ['Column_material.022']: THREE.MeshStandardMaterial
    ['Column_rect.022']: THREE.MeshStandardMaterial
    ['Column_material.023']: THREE.MeshStandardMaterial
    ['Column_rect.023']: THREE.MeshStandardMaterial
    ['Column_material.024']: THREE.MeshStandardMaterial
    ['Column_rect.024']: THREE.MeshStandardMaterial
    ['Column_material.025']: THREE.MeshStandardMaterial
    ['Column_rect.025']: THREE.MeshStandardMaterial
    ['Column_material.026']: THREE.MeshStandardMaterial
    ['Column_rect.026']: THREE.MeshStandardMaterial
    ['Column_material.027']: THREE.MeshStandardMaterial
    ['Column_rect.027']: THREE.MeshStandardMaterial
    ['Column_material.028']: THREE.MeshStandardMaterial
    ['Column_material.029']: THREE.MeshStandardMaterial
    ['Column_rect.028']: THREE.MeshStandardMaterial
    ['Column_material.030']: THREE.MeshStandardMaterial
    ['Column_rect.029']: THREE.MeshStandardMaterial
    ['Column_material.031']: THREE.MeshStandardMaterial
    ['Column_rect.030']: THREE.MeshStandardMaterial
    ['Column_material.032']: THREE.MeshStandardMaterial
    ['Column_rect.031']: THREE.MeshStandardMaterial
    ['Column_material.033']: THREE.MeshStandardMaterial
    ['Column_rect.032']: THREE.MeshStandardMaterial
    ['Column_material.034']: THREE.MeshStandardMaterial
    ['Column_rect.033']: THREE.MeshStandardMaterial
    ['Column_material.035']: THREE.MeshStandardMaterial
    ['Column_rect.034']: THREE.MeshStandardMaterial
    ['Column_material.036']: THREE.MeshStandardMaterial
    ['Column_rect.035']: THREE.MeshStandardMaterial
    ['Column_material.037']: THREE.MeshStandardMaterial
    ['Column_rect.036']: THREE.MeshStandardMaterial
    ['Column_material.038']: THREE.MeshStandardMaterial
    ['Column_rect.037']: THREE.MeshStandardMaterial
    ['Column_material.039']: THREE.MeshStandardMaterial
    ['Column_rect.038']: THREE.MeshStandardMaterial
    ['Column_material.040']: THREE.MeshStandardMaterial
    ['Column_rect.039']: THREE.MeshStandardMaterial
    ['Column_material.041']: THREE.MeshStandardMaterial
    ['Column_rect.040']: THREE.MeshStandardMaterial
    ['Column_material.042']: THREE.MeshStandardMaterial
    ['Column_rect.041']: THREE.MeshStandardMaterial
    ['Column_material.043']: THREE.MeshStandardMaterial
    ['Column_material.044']: THREE.MeshStandardMaterial
    ['Column_rect.042']: THREE.MeshStandardMaterial
    ['Column_material.045']: THREE.MeshStandardMaterial
    ['Column_rect.043']: THREE.MeshStandardMaterial
    ['Column_material.046']: THREE.MeshStandardMaterial
    ['Column_rect.044']: THREE.MeshStandardMaterial
    ['Column_material.047']: THREE.MeshStandardMaterial
    ['Column_rect.045']: THREE.MeshStandardMaterial
    ['Column_material.048']: THREE.MeshStandardMaterial
    ['Column_material.049']: THREE.MeshStandardMaterial
    ['Column_rect.046']: THREE.MeshStandardMaterial
    ['Column_material.050']: THREE.MeshStandardMaterial
    ['Column_rect.047']: THREE.MeshStandardMaterial
    ['Column_material.051']: THREE.MeshStandardMaterial
    ['Column_rect.048']: THREE.MeshStandardMaterial
    ['Column_material.052']: THREE.MeshStandardMaterial
    ['Column_rect.049']: THREE.MeshStandardMaterial
    ['Column_material.053']: THREE.MeshStandardMaterial
    ['Column_rect.050']: THREE.MeshStandardMaterial
    ['Column_material.054']: THREE.MeshStandardMaterial
    ['Column_rect.051']: THREE.MeshStandardMaterial
    ['Column_material.055']: THREE.MeshStandardMaterial
    ['Column_rect.052']: THREE.MeshStandardMaterial
    ['Column_material.056']: THREE.MeshStandardMaterial
    ['Column_rect.053']: THREE.MeshStandardMaterial
    ['Column_material.057']: THREE.MeshStandardMaterial
    ['Column_rect.054']: THREE.MeshStandardMaterial
    ['Column_material.058']: THREE.MeshStandardMaterial
    ['Column_rect.055']: THREE.MeshStandardMaterial
    ['Column_material.059']: THREE.MeshStandardMaterial
    ['Column_rect.056']: THREE.MeshStandardMaterial
    ['Column_material.060']: THREE.MeshStandardMaterial
    ['Column_rect.057']: THREE.MeshStandardMaterial
    ['Column_material.061']: THREE.MeshStandardMaterial
    ['Column_rect.058']: THREE.MeshStandardMaterial
    ['Column_material.062']: THREE.MeshStandardMaterial
    ['Column_rect.059']: THREE.MeshStandardMaterial
    ['Column_material.063']: THREE.MeshStandardMaterial
    ['Column_material.064']: THREE.MeshStandardMaterial
    ['Column_rect.060']: THREE.MeshStandardMaterial
    ['Column_material.065']: THREE.MeshStandardMaterial
    ['Column_rect.061']: THREE.MeshStandardMaterial
    ['Column_material.066']: THREE.MeshStandardMaterial
    ['Column_rect.062']: THREE.MeshStandardMaterial
    ['Column_material.067']: THREE.MeshStandardMaterial
    ['Column_rect.063']: THREE.MeshStandardMaterial
    ['Column_material.068']: THREE.MeshStandardMaterial
    ['Column_rect.064']: THREE.MeshStandardMaterial
    ['Column_material.069']: THREE.MeshStandardMaterial
    ['Column_rect.065']: THREE.MeshStandardMaterial
    ['Column_material.070']: THREE.MeshStandardMaterial
    ['Column_rect.066']: THREE.MeshStandardMaterial
    ['Column_material.071']: THREE.MeshStandardMaterial
    ['Column_rect.067']: THREE.MeshStandardMaterial
    ['Column_material.072']: THREE.MeshStandardMaterial
    ['Column_rect.068']: THREE.MeshStandardMaterial
    ['Column_material.073']: THREE.MeshStandardMaterial
    ['Column_material.074']: THREE.MeshStandardMaterial
    ['Column_rect.069']: THREE.MeshStandardMaterial
    ['Column_material.075']: THREE.MeshStandardMaterial
    ['Column_rect.070']: THREE.MeshStandardMaterial
    ['Column_material.076']: THREE.MeshStandardMaterial
    ['Column_rect.071']: THREE.MeshStandardMaterial
    ['Column_material.077']: THREE.MeshStandardMaterial
    ['Column_rect.072']: THREE.MeshStandardMaterial
    ['Column_material.078']: THREE.MeshStandardMaterial
    ['Column_material.079']: THREE.MeshStandardMaterial
    ['Column_rect.073']: THREE.MeshStandardMaterial
    ['Column_material.080']: THREE.MeshStandardMaterial
    ['Column_rect.074']: THREE.MeshStandardMaterial
    ['Column_material.081']: THREE.MeshStandardMaterial
    ['Column_rect.075']: THREE.MeshStandardMaterial
    ['Column_material.082']: THREE.MeshStandardMaterial
    ['Column_rect.076']: THREE.MeshStandardMaterial
    ['Column_material.083']: THREE.MeshStandardMaterial
    ['Column_rect.077']: THREE.MeshStandardMaterial
    ['Column_material.084']: THREE.MeshStandardMaterial
    ['Column_rect.078']: THREE.MeshStandardMaterial
    ['Column_material.085']: THREE.MeshStandardMaterial
    ['Column_rect.079']: THREE.MeshStandardMaterial
    ['Material.170']: THREE.MeshStandardMaterial
    ['Column_material.086']: THREE.MeshStandardMaterial
    ['Column_material.087']: THREE.MeshStandardMaterial
    ['Column_material.088']: THREE.MeshStandardMaterial
    ['Column_material.089']: THREE.MeshStandardMaterial
    ['Column_material.090']: THREE.MeshStandardMaterial
    ['Column_material.091']: THREE.MeshStandardMaterial
    ['Column_material.092']: THREE.MeshStandardMaterial
    ['Column_material.093']: THREE.MeshStandardMaterial
    ['Column_material.094']: THREE.MeshStandardMaterial
    ['Column_material.095']: THREE.MeshStandardMaterial
    ['Column_material.096']: THREE.MeshStandardMaterial
    ['Column_material.097']: THREE.MeshStandardMaterial
    ['Column_material.098']: THREE.MeshStandardMaterial
    ['Column_material.099']: THREE.MeshStandardMaterial
    ['Column_material.100']: THREE.MeshStandardMaterial
    ['Column_material.101']: THREE.MeshStandardMaterial
    ['Material.099']: THREE.MeshStandardMaterial
    ['Material.082']: THREE.MeshStandardMaterial
    ['Material.071']: THREE.MeshStandardMaterial
    ['Material.084']: THREE.MeshStandardMaterial
    ['Column_material.103']: THREE.MeshStandardMaterial
    ['Column_material.104']: THREE.MeshStandardMaterial
    Material: THREE.MeshStandardMaterial
    ['Material.064']: THREE.MeshStandardMaterial
    ['Material.067']: THREE.MeshStandardMaterial
    ['Material.097']: THREE.MeshStandardMaterial
    ['Material.173']: THREE.MeshStandardMaterial
    ['Material.174']: THREE.MeshStandardMaterial
    ['Material.175']: THREE.MeshStandardMaterial
    ['Material.176']: THREE.MeshStandardMaterial
    ['Material.178']: THREE.MeshStandardMaterial
    ['Material.187']: THREE.MeshStandardMaterial
    ['Material.188']: THREE.MeshStandardMaterial
    ['Material.192']: THREE.MeshStandardMaterial
    ['Material.195']: THREE.MeshStandardMaterial
    ['Material.196']: THREE.MeshStandardMaterial
    ['Material.197']: THREE.MeshStandardMaterial
    ['Material.198']: THREE.MeshStandardMaterial
    ['Material.200']: THREE.MeshStandardMaterial
    ['Material.203']: THREE.MeshStandardMaterial
    ['Material.204']: THREE.MeshStandardMaterial
    ['Material.177']: THREE.MeshStandardMaterial
    ['Material.208']: THREE.MeshStandardMaterial
    ['Material.209']: THREE.MeshStandardMaterial
    ['Material.210']: THREE.MeshStandardMaterial
    ['Material.211']: THREE.MeshStandardMaterial
    ['Material.212']: THREE.MeshStandardMaterial
    ['Material.213']: THREE.MeshStandardMaterial
    ['Material.214']: THREE.MeshStandardMaterial
    ['Material.215']: THREE.MeshStandardMaterial
    ['Material.216']: THREE.MeshStandardMaterial
    ['Material.217']: THREE.MeshStandardMaterial
    ['Material.218']: THREE.MeshStandardMaterial
    ['Material.219']: THREE.MeshStandardMaterial
    ['Material.457']: THREE.MeshStandardMaterial
    ['Material.223']: THREE.MeshStandardMaterial
    ['Material.224']: THREE.MeshStandardMaterial
    ['Material.225']: THREE.MeshStandardMaterial
    ['Material.226']: THREE.MeshStandardMaterial
    ['Material.227']: THREE.MeshStandardMaterial
    ['Material.228']: THREE.MeshStandardMaterial
    ['Material.229']: THREE.MeshStandardMaterial
    ['Material.233']: THREE.MeshStandardMaterial
    ['Material.234']: THREE.MeshStandardMaterial
    ['Material.235']: THREE.MeshStandardMaterial
    ['Material.236']: THREE.MeshStandardMaterial
    ['Material.237']: THREE.MeshStandardMaterial
    ['Material.238']: THREE.MeshStandardMaterial
    ['Material.239']: THREE.MeshStandardMaterial
    ['Material.240']: THREE.MeshStandardMaterial
    ['Material.241']: THREE.MeshStandardMaterial
    ['Material.243']: THREE.MeshStandardMaterial
    ['Material.244']: THREE.MeshStandardMaterial
    ['Material.112']: THREE.MeshStandardMaterial
    ['Material.179']: THREE.MeshStandardMaterial
    ['Material.232']: THREE.MeshStandardMaterial
    ['Material.242']: THREE.MeshStandardMaterial
    ['Material.245']: THREE.MeshStandardMaterial
    ['Material.246']: THREE.MeshStandardMaterial
    ['Material.247']: THREE.MeshStandardMaterial
    ['Material.248']: THREE.MeshStandardMaterial
    ['Material.249']: THREE.MeshStandardMaterial
    ['Material.250']: THREE.MeshStandardMaterial
    ['Material.251']: THREE.MeshStandardMaterial
    ['Material.252']: THREE.MeshStandardMaterial
    ['Material.253']: THREE.MeshStandardMaterial
    ['Material.254']: THREE.MeshStandardMaterial
    ['Material.255']: THREE.MeshStandardMaterial
    ['Material.256']: THREE.MeshStandardMaterial
    ['Material.257']: THREE.MeshStandardMaterial
    ['Material.258']: THREE.MeshStandardMaterial
    ['Material.259']: THREE.MeshStandardMaterial
    ['Material.262']: THREE.MeshStandardMaterial
    ['Material.263']: THREE.MeshStandardMaterial
    ['Material.264']: THREE.MeshStandardMaterial
    ['Material.265']: THREE.MeshStandardMaterial
    ['Material.266']: THREE.MeshStandardMaterial
    ['Material.267']: THREE.MeshStandardMaterial
    ['Material.268']: THREE.MeshStandardMaterial
    ['Material.269']: THREE.MeshStandardMaterial
    ['Material.270']: THREE.MeshStandardMaterial
    ['Material.271']: THREE.MeshStandardMaterial
    ['Material.272']: THREE.MeshStandardMaterial
    ['Material.273']: THREE.MeshStandardMaterial
    ['Material.274']: THREE.MeshStandardMaterial
    ['Material.275']: THREE.MeshStandardMaterial
    ['Material.276']: THREE.MeshStandardMaterial
    ['Material.277']: THREE.MeshStandardMaterial
    ['Material.278']: THREE.MeshStandardMaterial
    ['Material.279']: THREE.MeshStandardMaterial
    ['Material.280']: THREE.MeshStandardMaterial
    ['Material.281']: THREE.MeshStandardMaterial
    ['Material.282']: THREE.MeshStandardMaterial
    ['Material.283']: THREE.MeshStandardMaterial
    ['Material.284']: THREE.MeshStandardMaterial
    ['Material.285']: THREE.MeshStandardMaterial
    ['Material.286']: THREE.MeshStandardMaterial
    ['Material.287']: THREE.MeshStandardMaterial
    ['Material.288']: THREE.MeshStandardMaterial
    ['Material.289']: THREE.MeshStandardMaterial
    ['Material.290']: THREE.MeshStandardMaterial
    ['Material.291']: THREE.MeshStandardMaterial
    ['Material.292']: THREE.MeshStandardMaterial
    ['Material.296']: THREE.MeshStandardMaterial
    ['Material.297']: THREE.MeshStandardMaterial
    ['Material.298']: THREE.MeshStandardMaterial
    ['Material.299']: THREE.MeshStandardMaterial
    ['Material.300']: THREE.MeshStandardMaterial
    ['Material.302']: THREE.MeshStandardMaterial
    ['Material.303']: THREE.MeshStandardMaterial
    ['Material.304']: THREE.MeshStandardMaterial
    ['Material.305']: THREE.MeshStandardMaterial
    ['Material.306']: THREE.MeshStandardMaterial
    ['Material.307']: THREE.MeshStandardMaterial
    ['Material.308']: THREE.MeshStandardMaterial
    ['Material.309']: THREE.MeshStandardMaterial
    ['Material.310']: THREE.MeshStandardMaterial
    ['Material.311']: THREE.MeshStandardMaterial
    ['Material.261']: THREE.MeshStandardMaterial
    ['Material.301']: THREE.MeshStandardMaterial
    ['Material.318']: THREE.MeshStandardMaterial
    ['Material.319']: THREE.MeshStandardMaterial
    ['Material.320']: THREE.MeshStandardMaterial
    ['Material.321']: THREE.MeshStandardMaterial
    ['Material.322']: THREE.MeshStandardMaterial
    ['Material.323']: THREE.MeshStandardMaterial
    ['Material.324']: THREE.MeshStandardMaterial
    ['Material.325']: THREE.MeshStandardMaterial
    ['Material.326']: THREE.MeshStandardMaterial
    ['Material.327']: THREE.MeshStandardMaterial
    ['Material.331']: THREE.MeshStandardMaterial
    ['Material.332']: THREE.MeshStandardMaterial
    ['Material.333']: THREE.MeshStandardMaterial
    ['Material.336']: THREE.MeshStandardMaterial
    ['Material.338']: THREE.MeshStandardMaterial
    ['Material.339']: THREE.MeshStandardMaterial
    ['Material.340']: THREE.MeshStandardMaterial
    ['Material.341']: THREE.MeshStandardMaterial
    ['Material.342']: THREE.MeshStandardMaterial
    ['Material.343']: THREE.MeshStandardMaterial
    ['Material.344']: THREE.MeshStandardMaterial
    ['Material.345']: THREE.MeshStandardMaterial
    ['Material.346']: THREE.MeshStandardMaterial
    ['Material.348']: THREE.MeshStandardMaterial
    ['Material.349']: THREE.MeshStandardMaterial
    ['Material.350']: THREE.MeshStandardMaterial
    ['Material.351']: THREE.MeshStandardMaterial
    ['Material.352']: THREE.MeshStandardMaterial
    ['Material.353']: THREE.MeshStandardMaterial
    ['Material.354']: THREE.MeshStandardMaterial
    ['Material.355']: THREE.MeshStandardMaterial
    ['Material.356']: THREE.MeshStandardMaterial
    ['Material.357']: THREE.MeshStandardMaterial
    ['Material.358']: THREE.MeshStandardMaterial
    ['Material.359']: THREE.MeshStandardMaterial
    ['Material.360']: THREE.MeshStandardMaterial
    ['Material.361']: THREE.MeshStandardMaterial
    ['Material.362']: THREE.MeshStandardMaterial
    ['Material.363']: THREE.MeshStandardMaterial
    ['Material.364']: THREE.MeshStandardMaterial
    ['Material.365']: THREE.MeshStandardMaterial
    ['Material.366']: THREE.MeshStandardMaterial
    ['Material.367']: THREE.MeshStandardMaterial
    ['Material.368']: THREE.MeshStandardMaterial
    ['Material.369']: THREE.MeshStandardMaterial
    ['Material.370']: THREE.MeshStandardMaterial
    ['Material.371']: THREE.MeshStandardMaterial
    ['Material.372']: THREE.MeshStandardMaterial
    ['Material.373']: THREE.MeshStandardMaterial
    ['Material.374']: THREE.MeshStandardMaterial
    ['Material.375']: THREE.MeshStandardMaterial
    ['Material.376']: THREE.MeshStandardMaterial
    ['Material.378']: THREE.MeshStandardMaterial
    ['Material.379']: THREE.MeshStandardMaterial
    ['Material.380']: THREE.MeshStandardMaterial
    ['Material.381']: THREE.MeshStandardMaterial
    ['Material.382']: THREE.MeshStandardMaterial
    ['Material.383']: THREE.MeshStandardMaterial
    ['Material.384']: THREE.MeshStandardMaterial
    ['Material.385']: THREE.MeshStandardMaterial
    ['Material.386']: THREE.MeshStandardMaterial
    ['Material.387']: THREE.MeshStandardMaterial
    ['Material.388']: THREE.MeshStandardMaterial
    ['Material.389']: THREE.MeshStandardMaterial
    ['Material.390']: THREE.MeshStandardMaterial
    ['Material.391']: THREE.MeshStandardMaterial
    ['Material.392']: THREE.MeshStandardMaterial
    ['Material.393']: THREE.MeshStandardMaterial
    ['Material.394']: THREE.MeshStandardMaterial
    ['Material.395']: THREE.MeshStandardMaterial
    ['Material.396']: THREE.MeshStandardMaterial
    ['Material.315']: THREE.MeshStandardMaterial
    ['Material.316']: THREE.MeshStandardMaterial
    ['Material.398']: THREE.MeshStandardMaterial
    ['Material.399']: THREE.MeshStandardMaterial
    ['Material.400']: THREE.MeshStandardMaterial
    ['Material.401']: THREE.MeshStandardMaterial
    ['Material.402']: THREE.MeshStandardMaterial
    ['Material.403']: THREE.MeshStandardMaterial
    ['Material.404']: THREE.MeshStandardMaterial
    ['Material.405']: THREE.MeshStandardMaterial
    ['Material.406']: THREE.MeshStandardMaterial
    ['Material.407']: THREE.MeshStandardMaterial
    ['Material.408']: THREE.MeshStandardMaterial
    ['Material.409']: THREE.MeshStandardMaterial
    ['Material.410']: THREE.MeshStandardMaterial
    ['Material.411']: THREE.MeshStandardMaterial
    ['Material.412']: THREE.MeshStandardMaterial
    ['Material.413']: THREE.MeshStandardMaterial
    ['Material.414']: THREE.MeshStandardMaterial
    ['Material.415']: THREE.MeshStandardMaterial
    ['Material.416']: THREE.MeshStandardMaterial
    ['Material.417']: THREE.MeshStandardMaterial
    ['Material.418']: THREE.MeshStandardMaterial
    ['Material.419']: THREE.MeshStandardMaterial
    ['Material.420']: THREE.MeshStandardMaterial
    ['Material.347']: THREE.MeshStandardMaterial
    ['Material.377']: THREE.MeshStandardMaterial
    ['Material.397']: THREE.MeshStandardMaterial
    ['Material.421']: THREE.MeshStandardMaterial
    ['Material.422']: THREE.MeshStandardMaterial
    ['Material.423']: THREE.MeshStandardMaterial
    ['Material.424']: THREE.MeshStandardMaterial
    ['Material.425']: THREE.MeshStandardMaterial
    ['Material.426']: THREE.MeshStandardMaterial
    ['Material.427']: THREE.MeshStandardMaterial
    ['Material.428']: THREE.MeshStandardMaterial
    ['Material.429']: THREE.MeshStandardMaterial
    ['Material.430']: THREE.MeshStandardMaterial
    ['Column_material.153']: THREE.MeshStandardMaterial
    ['Column_material.130']: THREE.MeshStandardMaterial
    ['Column_material.132']: THREE.MeshStandardMaterial
    ['Column_material.133']: THREE.MeshStandardMaterial
    ['Column_material.134']: THREE.MeshStandardMaterial
    ['Column_material.135']: THREE.MeshStandardMaterial
    ['Material.085']: THREE.MeshStandardMaterial
    ['Material.044']: THREE.MeshStandardMaterial
    ['Material.260']: THREE.MeshStandardMaterial
    ['Material.048']: THREE.MeshStandardMaterial
    ['Material.101']: THREE.MeshStandardMaterial
    ['Material.207']: THREE.MeshStandardMaterial
    ['Material.230']: THREE.MeshStandardMaterial
    ['Column_material.102']: THREE.MeshStandardMaterial
    ['Column_rect.080']: THREE.MeshStandardMaterial
    ['Column_material.106']: THREE.MeshStandardMaterial
    ['Column_rect.081']: THREE.MeshStandardMaterial
    ['Column_material.124']: THREE.MeshStandardMaterial
    ['Column_rect.082']: THREE.MeshStandardMaterial
    ['Column_material.127']: THREE.MeshStandardMaterial
    ['Column_rect.085']: THREE.MeshStandardMaterial
    ['Column_rect.086']: THREE.MeshStandardMaterial
    ['Material.437']: THREE.MeshStandardMaterial
    ['Material.438']: THREE.MeshStandardMaterial
    ['Material.439']: THREE.MeshStandardMaterial
    ['Material.440']: THREE.MeshStandardMaterial
    ['Material.441']: THREE.MeshStandardMaterial
    ['Material.442']: THREE.MeshStandardMaterial
    ['Material.443']: THREE.MeshStandardMaterial
    ['Material.450']: THREE.MeshStandardMaterial
    ['Material.455']: THREE.MeshStandardMaterial
    ['Material.458']: THREE.MeshStandardMaterial
    ['Material.459']: THREE.MeshStandardMaterial
    ['Material.460']: THREE.MeshStandardMaterial
    ['Material.461']: THREE.MeshStandardMaterial
    ['Material.462']: THREE.MeshStandardMaterial
    ['Material.463']: THREE.MeshStandardMaterial
    ['Material.464']: THREE.MeshStandardMaterial
    ['Material.465']: THREE.MeshStandardMaterial
    ['Material.466']: THREE.MeshStandardMaterial
    ['Material.467']: THREE.MeshStandardMaterial
    ['Material.469']: THREE.MeshStandardMaterial
    ['Material.470']: THREE.MeshStandardMaterial
    ['Material.471']: THREE.MeshStandardMaterial
    ['Material.478']: THREE.MeshStandardMaterial
    ['Material.479']: THREE.MeshStandardMaterial
    ['Material.480']: THREE.MeshStandardMaterial
    ['Material.481']: THREE.MeshStandardMaterial
    ['Material.482']: THREE.MeshStandardMaterial
    ['Material.088']: THREE.MeshStandardMaterial
    ['Material.089']: THREE.MeshStandardMaterial
    ['Material.001']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.004']: THREE.MeshStandardMaterial
    ['Material.005']: THREE.MeshStandardMaterial
    ['Material.010']: THREE.MeshStandardMaterial
    ['Material.016']: THREE.MeshStandardMaterial
    ['Chairs_A.001']: THREE.MeshStandardMaterial
    ['Chairs_A.002']: THREE.MeshStandardMaterial
    ['Chairs_A.003']: THREE.MeshStandardMaterial
    ['Chairs_A.004']: THREE.MeshStandardMaterial
    ['Chairs_A.005']: THREE.MeshStandardMaterial
    ['Chairs_A.006']: THREE.MeshStandardMaterial
    ['Chairs_A.007']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.001']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.003']: THREE.MeshStandardMaterial
    ['Chairs_A.008']: THREE.MeshStandardMaterial
    ['Chairs_A.009']: THREE.MeshStandardMaterial
    ['Material.017']: THREE.MeshStandardMaterial
    ['endtable1.001']: THREE.MeshStandardMaterial
    ['endtable1.002']: THREE.MeshStandardMaterial
    ['lamp01.001']: THREE.MeshStandardMaterial
    ['chair1.001']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.004']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.005']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.006']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.007']: THREE.MeshStandardMaterial
    ['lambert15.001']: THREE.MeshStandardMaterial
    ['lambert15.002']: THREE.MeshStandardMaterial
    ['lambert15.003']: THREE.MeshStandardMaterial
    ['lambert15.004']: THREE.MeshStandardMaterial
    ['lambert15.005']: THREE.MeshStandardMaterial
    ['lambert15.006']: THREE.MeshStandardMaterial
    ['lambert16.001']: THREE.MeshStandardMaterial
    ['material.002']: THREE.MeshStandardMaterial
    ['lambert1.001']: THREE.MeshStandardMaterial
    ['lambert1.002']: THREE.MeshStandardMaterial
    ['Material.036']: THREE.MeshStandardMaterial
    ['Material.028']: THREE.MeshStandardMaterial
    ['Material.038']: THREE.MeshStandardMaterial
    ['Material.037']: THREE.MeshStandardMaterial
    ['Material.040']: THREE.MeshStandardMaterial
    ['Material.041']: THREE.MeshStandardMaterial
    ['Material.042']: THREE.MeshStandardMaterial
    ['Material.043']: THREE.MeshStandardMaterial
    ['Material.049']: THREE.MeshStandardMaterial
    ['Material.077']: THREE.MeshStandardMaterial
    ['Material.105']: THREE.MeshStandardMaterial
    ['Material.119']: THREE.MeshStandardMaterial
    ['Material.122']: THREE.MeshStandardMaterial
    ['Material.161']: THREE.MeshStandardMaterial
    ['Material.162']: THREE.MeshStandardMaterial
    ['Material.164']: THREE.MeshStandardMaterial
    ['Material.220']: THREE.MeshStandardMaterial
    ['Material.317']: THREE.MeshStandardMaterial
    ['Material.328']: THREE.MeshStandardMaterial
    ['Material.329']: THREE.MeshStandardMaterial
    ['Material.330']: THREE.MeshStandardMaterial
    ['Material.334']: THREE.MeshStandardMaterial
    ['Material.335']: THREE.MeshStandardMaterial
    ['Material.337']: THREE.MeshStandardMaterial
    ['Material.444']: THREE.MeshStandardMaterial
    ['Material.445']: THREE.MeshStandardMaterial
    ['Material.446']: THREE.MeshStandardMaterial
    ['Material.447']: THREE.MeshStandardMaterial
    ['Material.448']: THREE.MeshStandardMaterial
    ['Material.449']: THREE.MeshStandardMaterial
    ['Material.451']: THREE.MeshStandardMaterial
    ['Material.452']: THREE.MeshStandardMaterial
    ['Material.453']: THREE.MeshStandardMaterial
    ['Material.454']: THREE.MeshStandardMaterial
    ['Material.456']: THREE.MeshStandardMaterial
    ['Material.472']: THREE.MeshStandardMaterial
    ['Material.473']: THREE.MeshStandardMaterial
    ['Material.475']: THREE.MeshStandardMaterial
    ['Material.476']: THREE.MeshStandardMaterial
    ['Material.483']: THREE.MeshStandardMaterial
    ['Material.484']: THREE.MeshStandardMaterial
    ['Material.485']: THREE.MeshStandardMaterial
    ['Material.486']: THREE.MeshStandardMaterial
    ['Material.487']: THREE.MeshStandardMaterial
    ['Material.488']: THREE.MeshStandardMaterial
    ['Material.489']: THREE.MeshStandardMaterial
    ['Material.490']: THREE.MeshStandardMaterial
    ['Material.491']: THREE.MeshStandardMaterial
    ['Material.492']: THREE.MeshStandardMaterial
    ['Material.493']: THREE.MeshStandardMaterial
    ['Material.494']: THREE.MeshStandardMaterial
    ['Material.495']: THREE.MeshStandardMaterial
    ['Material.496']: THREE.MeshStandardMaterial
    ['Material.497']: THREE.MeshStandardMaterial
    ['Material.498']: THREE.MeshStandardMaterial
    ['Material.499']: THREE.MeshStandardMaterial
    ['Material.500']: THREE.MeshStandardMaterial
    ['Material.501']: THREE.MeshStandardMaterial
    ['Material.502']: THREE.MeshStandardMaterial
    ['Material.503']: THREE.MeshStandardMaterial
    ['Material.504']: THREE.MeshStandardMaterial
    ['Material.505']: THREE.MeshStandardMaterial
    ['Material.506']: THREE.MeshStandardMaterial
    ['Material.507']: THREE.MeshStandardMaterial
    ['Material.508']: THREE.MeshStandardMaterial
    ['Material.509']: THREE.MeshStandardMaterial
    ['Material.510']: THREE.MeshStandardMaterial
    ['Material.511']: THREE.MeshStandardMaterial
    ['Material.512']: THREE.MeshStandardMaterial
    ['Material.513']: THREE.MeshStandardMaterial
    ['Material.514']: THREE.MeshStandardMaterial
    ['Material.515']: THREE.MeshStandardMaterial
    ['Material.516']: THREE.MeshStandardMaterial
    ['Material.517']: THREE.MeshStandardMaterial
    ['Material.518']: THREE.MeshStandardMaterial
    ['Material.519']: THREE.MeshStandardMaterial
    ['Material.520']: THREE.MeshStandardMaterial
    ['Material.521']: THREE.MeshStandardMaterial
    ['Material.522']: THREE.MeshStandardMaterial
    ['Material.523']: THREE.MeshStandardMaterial
    ['Material.524']: THREE.MeshStandardMaterial
    ['Material.525']: THREE.MeshStandardMaterial
    ['Material.526']: THREE.MeshStandardMaterial
    ['Material.527']: THREE.MeshStandardMaterial
    ['Material.528']: THREE.MeshStandardMaterial
    ['Material.529']: THREE.MeshStandardMaterial
    ['Material.530']: THREE.MeshStandardMaterial
    ['Material.531']: THREE.MeshStandardMaterial
    ['Material.532']: THREE.MeshStandardMaterial
    ['Material.533']: THREE.MeshStandardMaterial
    ['Material.534']: THREE.MeshStandardMaterial
    ['Material.535']: THREE.MeshStandardMaterial
    ['Material.536']: THREE.MeshStandardMaterial
    ['Material.537']: THREE.MeshStandardMaterial
    ['Material.538']: THREE.MeshStandardMaterial
    ['Material.539']: THREE.MeshStandardMaterial
    ['Material.543']: THREE.MeshStandardMaterial
    ['Material.544']: THREE.MeshStandardMaterial
    ['Material.545']: THREE.MeshStandardMaterial
    ['Material.546']: THREE.MeshStandardMaterial
    ['Material.547']: THREE.MeshStandardMaterial
    ['Material.548']: THREE.MeshStandardMaterial
    ['Material.549']: THREE.MeshStandardMaterial
    ['Material.550']: THREE.MeshStandardMaterial
    ['Material.551']: THREE.MeshStandardMaterial
    ['Material.552']: THREE.MeshStandardMaterial
    ['Material.553']: THREE.MeshStandardMaterial
    ['Material.554']: THREE.MeshStandardMaterial
    ['Material.555']: THREE.MeshStandardMaterial
    ['Material.541']: THREE.MeshStandardMaterial
    ['Material.563']: THREE.MeshStandardMaterial
    ['Material.556']: THREE.MeshStandardMaterial
    ['Material.564']: THREE.MeshStandardMaterial
    ['Material.565']: THREE.MeshStandardMaterial
    ['Material.566']: THREE.MeshStandardMaterial
    ['Material.567']: THREE.MeshStandardMaterial
    ['Material.568']: THREE.MeshStandardMaterial
    ['Material.569']: THREE.MeshStandardMaterial
    ['Material.570']: THREE.MeshStandardMaterial
    ['Material.571']: THREE.MeshStandardMaterial
    ['Material.561']: THREE.MeshStandardMaterial
    ['Material.562']: THREE.MeshStandardMaterial
    ['Material.557']: THREE.MeshStandardMaterial
    ['Material.558']: THREE.MeshStandardMaterial
    ['Material.559']: THREE.MeshStandardMaterial
    ['Material.560']: THREE.MeshStandardMaterial
    ['lambert15.007']: THREE.MeshStandardMaterial
    ['lambert1.003']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.001']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.008']: THREE.MeshStandardMaterial
    ['lambert17.001']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.009']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.010']: THREE.MeshStandardMaterial
    ['Material.572']: THREE.MeshStandardMaterial
    ['endtable1.003']: THREE.MeshStandardMaterial
    ['lamp01.002']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.011']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.012']: THREE.MeshStandardMaterial
    ['endtable1.004']: THREE.MeshStandardMaterial
    ['Material.573']: THREE.MeshStandardMaterial
    ['Material.574']: THREE.MeshStandardMaterial
    ['Material.575']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.013']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.014']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.002']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.003']: THREE.MeshStandardMaterial
    ['lamp01.003']: THREE.MeshStandardMaterial
    ['Chairs_A.010']: THREE.MeshStandardMaterial
    ['Chairs_A.011']: THREE.MeshStandardMaterial
    ['Material.576']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.015']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.016']: THREE.MeshStandardMaterial
    ['Chairs_A.012']: THREE.MeshStandardMaterial
    ['Chairs_A.013']: THREE.MeshStandardMaterial
    ['Chairs_A.014']: THREE.MeshStandardMaterial
    ['Chairs_A.015']: THREE.MeshStandardMaterial
    ['Chairs_A.016']: THREE.MeshStandardMaterial
    ['Chairs_A.017']: THREE.MeshStandardMaterial
    ['lambert17.002']: THREE.MeshStandardMaterial
    ['zOther_Props_01_0.001']: THREE.MeshStandardMaterial
    ['zMechanical_Parts_1.002']: THREE.MeshStandardMaterial
    ['zGarbage.002']: THREE.MeshStandardMaterial
    ['zMechanical_Parts_0.002']: THREE.MeshStandardMaterial
    ['zMechanical_Parts_1.003']: THREE.MeshStandardMaterial
    ['zGarbage.003']: THREE.MeshStandardMaterial
    ['zMechanical_Parts_0.003']: THREE.MeshStandardMaterial
    ['zMechanical_Parts.001']: THREE.MeshStandardMaterial
    ['zOther_Props_01_1.001']: THREE.MeshStandardMaterial
    ['zOther_Props_01_1.002']: THREE.MeshStandardMaterial
    ['zOther_Props_01_1.003']: THREE.MeshStandardMaterial
    ['zOther_Props_01_0.002']: THREE.MeshStandardMaterial
    ['zOther_Props_01_2.001']: THREE.MeshStandardMaterial
    ['zOther_Props_01_1.004']: THREE.MeshStandardMaterial
    ['zOther_Props_01_1.005']: THREE.MeshStandardMaterial
    ['Material.578']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.018']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.017']: THREE.MeshStandardMaterial
    ['Glass_Cupboard_A.001']: THREE.MeshStandardMaterial
    ['Column_material.109']: THREE.MeshStandardMaterial
    ['Column_material.110']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.019']: THREE.MeshStandardMaterial
    ['Column_material.111']: THREE.MeshStandardMaterial
    ['Material.579']: THREE.MeshStandardMaterial
    ['lambert15.008']: THREE.MeshStandardMaterial
    ['lambert16.002']: THREE.MeshStandardMaterial
    ['lambert17.003']: THREE.MeshStandardMaterial
    ['material.004']: THREE.MeshStandardMaterial
    ['lambert1.004']: THREE.MeshStandardMaterial
    ['lambert18.001']: THREE.MeshStandardMaterial
    ['emission1.001']: THREE.MeshStandardMaterial
    ['fenster.001']: THREE.MeshStandardMaterial
    ['lambert19.001']: THREE.MeshStandardMaterial
    ['Material.580']: THREE.MeshStandardMaterial
    ['Material.581']: THREE.MeshStandardMaterial
    ['endtable1.006']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.020']: THREE.MeshStandardMaterial
    ['Trims_Painted_A.021']: THREE.MeshStandardMaterial
    ['endtable1.005']: THREE.MeshStandardMaterial
    ['lamp01.004']: THREE.MeshStandardMaterial
    ['Chairs_A.018']: THREE.MeshStandardMaterial
    ['Column_material.112']: THREE.MeshStandardMaterial
    ['Column_rect.083']: THREE.MeshStandardMaterial
    ['Material.582']: THREE.MeshStandardMaterial
    ['Material.584']: THREE.MeshStandardMaterial
    ['Material.585']: THREE.MeshStandardMaterial
    ['zOther_Props_01.001']: THREE.MeshStandardMaterial
    ['zOther_Props_01_0.003']: THREE.MeshStandardMaterial
    ['Material.586']: THREE.MeshStandardMaterial
    ['bullet_holder.001']: THREE.MeshStandardMaterial
    ['bullet_bottom.001']: THREE.MeshStandardMaterial
    ['ammo_body.001']: THREE.MeshStandardMaterial
    ['material.006']: THREE.MeshStandardMaterial
    ['material.003']: THREE.MeshStandardMaterial
    ['Material.540']: THREE.MeshStandardMaterial
    ['material.007']: THREE.MeshStandardMaterial
    ['Material.542']: THREE.MeshStandardMaterial
    ['Material_001.001']: THREE.MeshStandardMaterial
    ['bullet_holder.002']: THREE.MeshStandardMaterial
    ['bullet_bottom.002']: THREE.MeshStandardMaterial
    ['ammo_body.002']: THREE.MeshStandardMaterial
    ['material.008']: THREE.MeshStandardMaterial
    ['bullet_holder.003']: THREE.MeshStandardMaterial
    ['bullet_bottom.003']: THREE.MeshStandardMaterial
    ['ammo_body.003']: THREE.MeshStandardMaterial
    ['material.009']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.004']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.005']: THREE.MeshStandardMaterial
    ['bullet_holder.004']: THREE.MeshStandardMaterial
    ['bullet_bottom.004']: THREE.MeshStandardMaterial
    ['ammo_body.004']: THREE.MeshStandardMaterial
    ['material.010']: THREE.MeshStandardMaterial
    ['bullet_holder.005']: THREE.MeshStandardMaterial
    ['bullet_bottom.005']: THREE.MeshStandardMaterial
    ['ammo_body.005']: THREE.MeshStandardMaterial
    ['material.011']: THREE.MeshStandardMaterial
    ['Material_001.002']: THREE.MeshStandardMaterial
    ['Material.587']: THREE.MeshStandardMaterial
    ['material.012']: THREE.MeshStandardMaterial
    ['material.013']: THREE.MeshStandardMaterial
    ['Material.588']: THREE.MeshStandardMaterial
    ['Material_001.003']: THREE.MeshStandardMaterial
    ['bullet_holder.006']: THREE.MeshStandardMaterial
    ['bullet_bottom.006']: THREE.MeshStandardMaterial
    ['ammo_body.006']: THREE.MeshStandardMaterial
    ['material.014']: THREE.MeshStandardMaterial
    ['bullet_holder.007']: THREE.MeshStandardMaterial
    ['bullet_bottom.007']: THREE.MeshStandardMaterial
    ['ammo_body.007']: THREE.MeshStandardMaterial
    ['material.015']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.006']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.007']: THREE.MeshStandardMaterial
    ['bullet_holder.008']: THREE.MeshStandardMaterial
    ['bullet_bottom.008']: THREE.MeshStandardMaterial
    ['ammo_body.008']: THREE.MeshStandardMaterial
    ['material.016']: THREE.MeshStandardMaterial
    ['bullet_holder.009']: THREE.MeshStandardMaterial
    ['bullet_bottom.009']: THREE.MeshStandardMaterial
    ['ammo_body.009']: THREE.MeshStandardMaterial
    ['material.017']: THREE.MeshStandardMaterial
    ['Material_001.004']: THREE.MeshStandardMaterial
    ['Material.589']: THREE.MeshStandardMaterial
    ['material.018']: THREE.MeshStandardMaterial
    ['material.019']: THREE.MeshStandardMaterial
    ['Material.590']: THREE.MeshStandardMaterial
    ['Material_001.005']: THREE.MeshStandardMaterial
    ['bullet_holder.010']: THREE.MeshStandardMaterial
    ['bullet_bottom.010']: THREE.MeshStandardMaterial
    ['ammo_body.010']: THREE.MeshStandardMaterial
    ['material.020']: THREE.MeshStandardMaterial
    ['bullet_holder.011']: THREE.MeshStandardMaterial
    ['bullet_bottom.011']: THREE.MeshStandardMaterial
    ['ammo_body.011']: THREE.MeshStandardMaterial
    ['material.021']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.008']: THREE.MeshStandardMaterial
    ['material.022']: THREE.MeshStandardMaterial
    ['Material.591']: THREE.MeshStandardMaterial
    ['Material_001.006']: THREE.MeshStandardMaterial
    ['bullet_holder.012']: THREE.MeshStandardMaterial
    ['bullet_bottom.012']: THREE.MeshStandardMaterial
    ['ammo_body.012']: THREE.MeshStandardMaterial
    ['material.023']: THREE.MeshStandardMaterial
    ['bullet_holder.013']: THREE.MeshStandardMaterial
    ['bullet_bottom.013']: THREE.MeshStandardMaterial
    ['ammo_body.013']: THREE.MeshStandardMaterial
    ['material.024']: THREE.MeshStandardMaterial
    ['Table_Kitchen_A.009']: THREE.MeshStandardMaterial
    ['Material.109']: THREE.MeshStandardMaterial
    ['Material.120']: THREE.MeshStandardMaterial
    ['Material.121']: THREE.MeshStandardMaterial
    ['Material.172']: THREE.MeshStandardMaterial
    ['Material.468']: THREE.MeshStandardMaterial
    ['Material.577']: THREE.MeshStandardMaterial
    ['Material.583']: THREE.MeshStandardMaterial
    ['Material.592']: THREE.MeshStandardMaterial
    ['Material.593']: THREE.MeshStandardMaterial
    ['Material.594']: THREE.MeshStandardMaterial
  }
}

// helper to build a fiber-like bump map once
function makeCarpetBumpTexture(size = 256): THREE.CanvasTexture {
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d")!;
  ctx.fillStyle = "#888";
  ctx.fillRect(0, 0, size, size);

  ctx.globalAlpha = 0.18;
  for (let i = 0; i < size * 45; i++) {
    const x = Math.random() * size;
    const y = Math.random() * size;
    const len = 5 + Math.random() * 10;
    const ang = Math.random() * Math.PI * 2;
    ctx.lineWidth = 0.6 + Math.random() * 0.8;
    ctx.strokeStyle = Math.random() < 0.5 ? "#9a9a9a" : "#7a7a7a";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
    ctx.stroke();
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = 8;
  tex.repeat.set(48, 48); // small fibers across a big floor
  return tex;
}

// module-scoped singleton so we don't need hooks in Model()
let __carpetBump: THREE.CanvasTexture | null = null;
const LIGHT_INTENSITY = 2.8;      // brighter glow
const LIGHT_DISTANCE  = 12;       // larger radius of light
const LIGHT_DECAY     = 1.5;      // softer falloff

function FluoroFixture({ nodeName }: { nodeName: string }) {
  const { scene, camera } = useThree();
  const group = useRef<THREE.Group>(null!);
  const pos = useRef(new THREE.Vector3());
  const quat = useRef(new THREE.Quaternion());
  const scl = useRef(new THREE.Vector3());

  const lightRefs = useRef<THREE.PointLight[]>([]);
  const lastOnAt  = useRef<number[]>([]);

  useEffect(() => {
    const src = scene.getObjectByName(nodeName) as THREE.Mesh | undefined;
    if (!src) return;

    src.updateWorldMatrix(true, false);
    src.matrixWorld.decompose(pos.current, quat.current, scl.current);
    group.current.position.copy(pos.current);
    group.current.quaternion.copy(quat.current);

    const m = src.material as THREE.MeshStandardMaterial;
    if (m && "emissive" in m) {
      m.color.set("#ffffff");                     // pure white panel
      m.emissive = new THREE.Color("#fff8d6");    // warm bright glow
      m.emissiveIntensity = 3.0;                  // panel looks lit up
      m.roughness = 1.0;
      m.metalness = 0.0;
    }
    src.castShadow = false;
    src.receiveShadow = true;
  }, [scene, nodeName]);

  const lightPositionsLocal: [number, number, number][] = useMemo(
    () => [
      [-1.5, 2.0, -1.4],
         [-2.7, 2.0, -7.4],
      [-8.7, 2.0, -1.4],
//  [-77.698, 2.0, -106.662],

//  [-34.629, 2.0, -123.048],

//  [-51.408, 2.0, -106.934],

//  [3.501, 2.0, -114.622],

//  [-135.155, 2.0, -131.446],

//  [-103.148, 2.0, -129.254],

//  [-89.827, 2.0, -106.662],

//  [-29.032, 2.0, -100.962],

//  [-104.812, 2.0, -79.333],

//  [-118.704, 2.0, -82.272],
// [-118.353, 2.0, -110.219],

//  [-2.092, 12.0, -95.823],

//  [-67.62, 2.0, -17.221],

//  [-82.721, 2.0, -32.008],

//  [-122.276, 2.0, -40.019],

//  [-15.699, 2.0, -50.556],

//  [-34.251, 2.0, -0.171],

//  [-51.743, 2.0, 14.092],

//  [-50.675, 2.0, -32.375],

//  [-66.391, 2.0, -52.069],

//  [6.329, 2.0, -35.462],

//  [-0.578, 2.0, -29.422],

//  [-21.028, 2.0, -38.206],

//  [-55.863, 2.0, -50.738],
    ],
    []
  );

  const tmpLocal = useRef(new THREE.Vector3());
  const tmpWorld = useRef(new THREE.Vector3());
  const camPos   = useRef(new THREE.Vector3());
// tiny procedural ‚Äúfiber‚Äù bump texture for carpet
const carpetBump = useMemo(() => {
  const size = 256;
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d")!;
  ctx.fillStyle = "#888";
  ctx.fillRect(0, 0, size, size);

  ctx.globalAlpha = 0.18;
  for (let i = 0; i < size * 45; i++) {
    const x = Math.random() * size;
    const y = Math.random() * size;
    const len = 5 + Math.random() * 10;
    const ang = Math.random() * Math.PI * 2;
    ctx.lineWidth = 0.6 + Math.random() * 0.8;
    ctx.strokeStyle = Math.random() < 0.5 ? "#9a9a9a" : "#7a7a7a";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
    ctx.stroke();
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = 8;
  tex.repeat.set(48, 48); // finer fibers on a big floor
  return tex;
}, []);

  useEffect(() => {
    lastOnAt.current = lightPositionsLocal.map(() => 0);
  }, [lightPositionsLocal]);


  return (
    <group ref={group}>
      {lightPositionsLocal.map((p, i) => (
        <pointLight
          key={i}
          ref={(el) => {
            if (el) lightRefs.current[i] = el;
          }}
          color="#fffbe6"
          intensity={LIGHT_INTENSITY}
          distance={LIGHT_DISTANCE}
          decay={LIGHT_DECAY}
          castShadow={false}
          position={p}
          visible={true}

        />
      ))}
    </group>
  );
}

export function CorridorLights() {
  const { camera } = useThree();
  useFrame(() => {
    (window as any).__R3F_CAMERA = camera;
    (window as any).__LIGHT_HOLES = [];
  });

  const NAMES = ["Cube484", "Cube485", "Cube198", "Cube486"];
  return (
    <>
      {NAMES.map((n) => (
        <FluoroFixture key={n} nodeName={n} />
      ))}
    </>
  );
}


export function Model(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF("/bloccc.glb") as GLTFResult
  const carpetBump = (__carpetBump ??= makeCarpetBumpTexture(256));

  return (
    <group {...props} dispose={null} position={[400, 0, 400]}>
    
      <group position={[0.272, 0.3, 0.1]}>
        <Table />
      </group>
      <Car1 position={[-21, 0.01, -120]} scale={[-0.016, 0.009, 0.009]} />
<CorridorLights />

<mesh
  castShadow
  receiveShadow
  geometry={nodes.Plane.geometry}
  position={[-46.804, 0.03, -60.777]}
  scale={114.921}
  material={undefined} // override GLTF material
>
  <meshStandardMaterial
    color={"#61564a"}   // tweak carpet tone
    roughness={0.97}
    metalness={0}
    bumpMap={carpetBump}
    bumpScale={0.08}    // 0.05‚Äì0.12 for more/less fuzz
  />
</mesh>


      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube.geometry}
        material={materials['Material.086']}
        position={[-92.052, 1.909, -69.77]}
        scale={[0.15, 2.01, 19]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube001.geometry}
        material={materials['Material.221']}
        position={[-83.541, 1.909, -89.393]}
        scale={[0.15, 2.01, 0.816]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube003.geometry}
        material={materials['Material.221']}
        position={[-85.778, 1.909, -88.673]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.369]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube004.geometry}
        material={materials['Material.221']}
        position={[-83.541, 1.909, -93.715]}
        scale={[0.15, 2.01, 1.078]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube005.geometry}
        material={materials['Material.221']}
        position={[-82.913, 1.911, -90.095]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 0.622]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube006.geometry}
        material={materials['Material.221']}
        position={[-78.795, 1.909, -91.228]}
        scale={[0.24, 2.01, 1.23]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube007.geometry}
        material={materials['Material.221']}
        position={[-81.134, 1.911, -92.55]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube008.geometry}
        material={materials['Material.221']}
        position={[-86.948, 1.911, -94.79]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column.geometry}
        material={materials.Column_material}
        position={[-89.647, 0.023, -91.275]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_bottom.geometry}
          material={materials.Column_rect}
          position={[0, -0.05, 0]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top.geometry}
          material={materials.Column_rect}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube009.geometry}
        material={materials['Material.221']}
        position={[-90.33, 1.909, -97.178]}
        scale={[0.15, 2.01, 2.538]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube010.geometry}
        material={materials['Material.221']}
        position={[-89.269, 1.911, -99.637]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.089]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube011.geometry}
        material={materials['Material.221']}
        position={[-88.045, 1.909, -104.846]}
        scale={[0.15, 2.01, 5.241]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube012.geometry}
        material={materials['Material.221']}
        position={[-77.853, 1.911, -104.328]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.201]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube013.geometry}
        material={materials['Material.221']}
        position={[-85.096, 1.911, -109.953]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.127]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube014.geometry}
        material={materials['Material.221']}
        position={[-82.101, 1.911, -107.143]}
        scale={[0.15, 2.01, 2.995]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube015.geometry}
        material={materials['Material.221']}
        position={[-73.782, 1.911, -105.206]}
        scale={[0.15, 2.01, 1.035]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube016.geometry}
        material={materials['Material.221']}
        position={[-75.971, 1.911, -109.941]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.35]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube017.geometry}
        material={materials['Material.221']}
        position={[-84.678, 1.911, -122.531]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 6.425]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube018.geometry}
        material={materials['Material.221']}
        position={[-78.16, 1.911, -116.232]}
        scale={[0.15, 2.01, 6.425]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube019.geometry}
        material={materials['Material.221']}
        position={[-91.042, 1.909, -123.636]}
        scale={[0.15, 2.01, 1.121]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube020.geometry}
        material={materials['Material.221']}
        position={[-94.525, 1.911, -124.558]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube021.geometry}
        material={materials['Material.086']}
        position={[-95.464, 1.827, -88.62]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube022.geometry}
        material={materials['Material.086']}
        position={[-101.277, 1.866, -90.86]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube023.geometry}
        material={materials['Material.221']}
        position={[-103.617, 1.894, -92.182]}
        rotation={[-3.109, 0, 3.136]}
        scale={[0.24, 2.01, 1.23]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube024.geometry}
        material={materials['Material.221']}
        position={[-101.277, 1.945, -93.313]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube025.geometry}
        material={materials['Material.086']}
        position={[-98.871, 1.841, -89.695]}
        rotation={[-3.109, 0, 3.136]}
        scale={[0.15, 2.01, 1.078]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube026.geometry}
        material={materials['Material.221']}
        position={[-97.646, 2.016, -94.734]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 1.389]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube027.geometry}
        material={materials['Material.221']}
        position={[-98.871, 1.98, -94.015]}
        rotation={[-3.109, 0, 3.136]}
        scale={[0.15, 2.01, 0.816]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube028.geometry}
        material={materials['Material.221']}
        position={[-96.41, 1.909, -97.22]}
        scale={[0.15, 2.01, 2.736]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube029.geometry}
        material={materials['Material.221']}
        position={[-99.051, 1.911, -100.026]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.778]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube030.geometry}
        material={materials['Material.221']}
        position={[-101.586, 1.909, -102.812]}
        scale={[0.15, 2.01, 3.327]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube031.geometry}
        material={materials['Material.221']}
        position={[-102.361, 2.016, -113.183]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube032.geometry}
        material={materials['Material.221']}
        position={[-103.139, 2.016, -114.021]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube033.geometry}
        material={materials['Material.221']}
        position={[-102.58, 2.016, -114.973]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube034.geometry}
        material={materials['Material.221']}
        position={[-102.015, 1.909, -117.439]}
        rotation={[0, 0, Math.PI]}
        scale={[0.15, 2.01, 2.685]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube035.geometry}
        material={materials['Material.221']}
        position={[-91.601, 1.909, -107.654]}
        scale={[0.15, 2.01, 2.649]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube036.geometry}
        material={materials['Material.221']}
        position={[-97.708, 1.909, -107.654]}
        scale={[0.15, 2.01, 2.649]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube037.geometry}
        material={materials['Material.221']}
        position={[-94.615, 1.909, -104.993]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.001]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube038.geometry}
        material={materials['Material.221']}
        position={[-98.291, 2.016, -110.275]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube040.geometry}
        material={materials['Material.221']}
        position={[-92.832, 1.909, -110.177]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.149]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube041.geometry}
        material={materials['Material.221']}
        position={[-96.558, 1.909, -112.025]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.455]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube042.geometry}
        material={materials['Material.221']}
        position={[-98.865, 2.016, -111.037]}
        scale={[0.15, 2.01, 0.8]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube043.geometry}
        material={materials['Material.221']}
        position={[-102.374, 2.016, -107.994]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube044.geometry}
        material={materials['Material.221']}
        position={[-102.934, 2.016, -107.041]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube045.geometry}
        material={materials['Material.221']}
        position={[-102.155, 2.016, -106.204]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube046.geometry}
        material={materials['Material.221']}
        position={[-101.715, 1.909, -110.454]}
        scale={[0.15, 2.01, 2.711]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube047.geometry}
        material={materials['Material.221']}
        position={[-97.936, 1.909, -122.204]}
        scale={[0.15, 2.01, 2.403]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube048.geometry}
        material={materials['Material.221']}
        position={[-99.966, 1.911, -120.05]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.053]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube049.geometry}
        material={materials['Material.221']}
        position={[-83.431, 1.909, -113.609]}
        rotation={[0, -1.564, 0]}
        scale={[0.15, 2.01, 2.248]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube050.geometry}
        material={materials['Material.221']}
        position={[-84.653, 1.909, -118.803]}
        rotation={[0, -1.564, 0]}
        scale={[0.15, 2.01, 3.285]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube051.geometry}
        material={materials['Material.221']}
        position={[-81.308, 1.909, -116.162]}
        rotation={[Math.PI, -0.006, Math.PI]}
        scale={[0.15, 2.01, 2.649]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube053.geometry}
        material={materials['Material.221']}
        position={[-86.559, 1.909, -115.667]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.175]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube054.geometry}
        material={materials['Material.221']}
        position={[-87.781, 1.909, -117.175]}
        rotation={[Math.PI, -0.006, Math.PI]}
        scale={[0.15, 2.01, 1.6]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube055.geometry}
        material={materials['Material.221']}
        position={[-96.244, 1.909, -114.882]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.455]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube056.geometry}
        material={materials['Material.221']}
        position={[-93.968, 2.016, -115.371]}
        scale={[0.15, 2.01, 0.655]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube057.geometry}
        material={materials['Material.221']}
        position={[-91.965, 1.909, -115.855]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.123]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube058.geometry}
        material={materials['Material.221']}
        position={[-89.908, 2.016, -116.439]}
        scale={[0.15, 2.01, 0.655]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube059.geometry}
        material={materials['Material.221']}
        position={[-94.259, 1.827, -117.121]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 4.48]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube060.geometry}
        material={materials['Material.221']}
        position={[-98.594, 2.016, -115.936]}
        scale={[0.15, 2.01, 1.081]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column001.geometry}
        material={materials['Column_material.001']}
        position={[-79.301, 0.023, -109.846]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_bottom001.geometry}
          material={materials['Column_rect.001']}
          position={[0, -0.05, 0]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top001.geometry}
          material={materials['Column_rect.001']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061.geometry}
        material={materials['Material.221']}
        position={[-73.782, 1.911, -109.075]}
        scale={[0.15, 2.01, 1.066]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube062.geometry}
        material={materials['Material.222']}
        position={[-69.425, 1.911, -106.057]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.137]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube063.geometry}
        material={materials['Material.222']}
        position={[-66.515, 1.911, -108.149]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 7.207]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube064.geometry}
        material={nodes.Cube064.material}
        position={[-53.846, 3.027, -114.726]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 3.071, 5.612]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube065.geometry}
        material={nodes.Cube065.material}
        position={[-59.401, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube068.geometry}
        material={nodes.Cube068.material}
        position={[-53.846, -7.045, -100.522]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 13.373]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube070.geometry}
        material={nodes.Cube070.material}
        position={[-57.749, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube071.geometry}
        material={nodes.Cube071.material}
        position={[-56.168, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube072.geometry}
        material={nodes.Cube072.material}
        position={[-54.536, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube073.geometry}
        material={nodes.Cube073.material}
        position={[-52.934, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube074.geometry}
        material={nodes.Cube074.material}
        position={[-51.295, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube075.geometry}
        material={nodes.Cube075.material}
        position={[-49.677, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube076.geometry}
        material={nodes.Cube076.material}
        position={[-48.133, 2.998, -111.485]}
        scale={[0.15, 3.121, 3.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube077.geometry}
        material={nodes.Cube077.material}
        position={[-47.888, -7.299, -100.336]}
        scale={[0.15, 13.45, 4.228]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube078.geometry}
        material={nodes.Cube078.material}
        position={[-53.763, 3.051, -96.018]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 3.104, 5.948]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane001.geometry}
        material={nodes.Plane001.material}
        position={[-53.8, 6.119, -105.505]}
        scale={[5.797, 1, 9.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube069.geometry}
        material={nodes.Cube069.material}
        position={[-53.763, -2.949, -96.018]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 3.104, 5.948]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube079.geometry}
        material={nodes.Cube079.material}
        position={[-53.763, -8.949, -96.018]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 3.104, 5.948]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube080.geometry}
        material={nodes.Cube080.material}
        position={[-53.763, -13.949, -96.018]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 3.104, 5.948]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube081.geometry}
        material={nodes.Cube081.material}
        position={[-53.483, -20.538, -99.769]}
        rotation={[1.561, Math.PI / 2, 0]}
        scale={[0.15, 4.393, 6.236]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube082.geometry}
        material={nodes.Cube082.material}
        position={[-53.763, -19.933, -96.018]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 3.104, 5.948]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube066.geometry}
        material={nodes.Cube066.material}
        position={[-59.355, -7.299, -101.182]}
        scale={[0.15, 13.45, 4.892]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube083.geometry}
        material={materials['Material.222']}
        position={[-43.564, 1.911, -104.413]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.201]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube084.geometry}
        material={materials['Material.003']}
        position={[-41.79, 1.911, -108.229]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 6.424]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube085.geometry}
        material={materials['Material.222']}
        position={[-39.537, 1.909, -97.903]}
        scale={[0.24, 2.01, 6.691]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube086.geometry}
        material={materials['Material.222']}
        position={[-35.624, 1.909, -101.762]}
        scale={[0.24, 2.01, 6.669]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube087.geometry}
        material={materials['Material.222']}
        position={[-30.342, 1.911, -91.171]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.505]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube088.geometry}
        material={materials['Material.222']}
        position={[-35.03, 1.911, -95.26]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 0.67]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube089.geometry}
        material={nodes.Cube089.material}
        position={[-26.092, 4.446, -86.369]}
        scale={[0.24, 4.6, 4.961]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube090.geometry}
        material={nodes.Cube090.material}
        position={[-26.092, 4.446, -100.202]}
        scale={[0.24, 4.6, 4.961]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube091.geometry}
        material={nodes.Cube091.material}
        position={[-4.63, 4.446, -93.051]}
        scale={[0.24, 4.6, 11.653]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube092.geometry}
        material={nodes.Cube092.material}
        position={[-15.317, 4.446, -104.908]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.24, 4.6, 11.008]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube093.geometry}
        material={nodes.Cube093.material}
        position={[-8.406, 4.446, -81.53]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.24, 4.6, 3.718]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube094.geometry}
        material={nodes.Cube094.material}
        position={[-22.483, 4.446, -81.53]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.24, 4.6, 3.832]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube095.geometry}
        material={nodes.Cube095.material}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube096.geometry}
        material={nodes.Cube096.material}
        position={[-7.644, 10.361, -107.498]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube097.geometry}
        material={nodes.Cube097.material}
        position={[-11.628, 10.361, -107.498]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube098.geometry}
        material={nodes.Cube098.material}
        position={[-15.786, 10.361, -107.498]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube099.geometry}
        material={nodes.Cube099.material}
        position={[-19.86, 10.361, -107.498]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube100.geometry}
        material={nodes.Cube100.material}
        position={[-24.292, 10.361, -107.498]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube101.geometry}
        material={nodes.Cube101.material}
        position={[-28.243, 10.361, -103.066]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube102.geometry}
        material={nodes.Cube102.material}
        position={[-28.243, 10.361, -98.014]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube103.geometry}
        material={nodes.Cube103.material}
        position={[-28.243, 10.361, -88.989]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube104.geometry}
        material={nodes.Cube104.material}
        position={[-28.243, 10.361, -83.302]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube105.geometry}
        material={nodes.Cube105.material}
        position={[-2.525, 10.361, -103.066]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube106.geometry}
        material={nodes.Cube106.material}
        position={[-2.525, 10.361, -98.533]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube107.geometry}
        material={nodes.Cube107.material}
        position={[-2.525, 10.361, -93.112]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube108.geometry}
        material={nodes.Cube108.material}
        position={[-2.525, 10.361, -87.688]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube109.geometry}
        material={nodes.Cube109.material}
        position={[-2.525, 10.361, -82.533]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.255, 0.371, 2.371]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube110.geometry}
        material={materials['Material.072']}
        position={[-11.946, 1.909, -67.968]}
        scale={[0.15, 2.01, 3.444]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube112.geometry}
        material={nodes.Cube112.material}
        position={[-23.208, 1.447, -43.79]}
        scale={[4.213, 1.594, 0.052]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube002.geometry}
        material={materials.hosp}
        position={[-25.442, 1.193, -72.603]}
        scale={[0.15, 1.343, 8.562]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube114.geometry}
        material={materials['Material.007']}
        position={[-41.79, 1.911, -114.503]}
        scale={[0.15, 2.01, 6.424]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube115.geometry}
        material={materials['Material.009']}
        position={[-45.82, 1.911, -114.503]}
        scale={[0.15, 2.01, 6.424]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube116.geometry}
        material={materials['Material.221']}
        position={[-70.474, 1.911, -114.503]}
        scale={[0.15, 2.01, 6.424]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube117.geometry}
        material={materials['Material.011']}
        position={[-67.651, 1.911, -114.503]}
        scale={[0.15, 2.01, 6.424]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube118.geometry}
        material={materials['Material.012']}
        position={[-54.142, 1.911, -119.936]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 8.408]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube119.geometry}
        material={materials['Material.013']}
        position={[-53, 1.911, -125.904]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 20.007]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube120.geometry}
        material={materials['Material.022']}
        position={[-37.493, 1.911, -119.182]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube121.geometry}
        material={materials['Material.222']}
        position={[-39.673, 1.911, -121.184]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.285]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube122.geometry}
        material={materials['Material.222']}
        position={[-31.299, 1.911, -119.182]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube123.geometry}
        material={materials['Material.222']}
        position={[-34.493, 1.911, -116.493]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube124.geometry}
        material={materials['Material.222']}
        position={[-29.225, 1.911, -118.41]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube126.geometry}
        material={materials['Material.222']}
        position={[-38.431, 1.911, -109.966]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube127.geometry}
        material={materials['Material.222']}
        position={[-35.087, 1.911, -114.462]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 0.689]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube128.geometry}
        material={materials['Material.222']}
        position={[-33.762, 1.911, -108.048]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 0.672]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube129.geometry}
        material={materials['Material.222']}
        position={[-30.018, 1.911, -109.599]}
        scale={[0.15, 2.01, 3.289]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube130.geometry}
        material={materials['Material.222']}
        position={[-27.461, 1.911, -109.966]}
        scale={[0.15, 2.01, 5.071]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube131.geometry}
        material={materials['Material.222']}
        position={[-34.489, 1.911, -101.769]}
        scale={[0.15, 2.01, 6.451]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube132.geometry}
        material={materials['Material.222']}
        position={[-33.053, 1.911, -109.966]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube133.geometry}
        material={materials['Material.014']}
        position={[-31.541, 1.911, -112.009]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube134.geometry}
        material={materials['Material.015']}
        position={[-32.923, 1.911, -117.224]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube125.geometry}
        material={materials['Material.222']}
        position={[-27.85, 1.911, -120.456]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube135.geometry}
        material={materials['Material.222']}
        position={[-26.216, 1.911, -114.946]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube136.geometry}
        material={materials['Material.222']}
        position={[-24.789, 1.911, -113.305]}
        scale={[0.15, 2.01, 1.713]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube137.geometry}
        material={materials['Material.222']}
        position={[-33.196, 1.911, -127.851]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube138.geometry}
        material={materials['Material.222']}
        position={[-28.979, 1.911, -122.73]}
        scale={[0.15, 2.01, 2.113]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube139.geometry}
        material={materials['Material.222']}
        position={[-17.214, 1.911, -129.771]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 15.986]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0003.geometry}
        material={materials['Material.022']}
        position={[-7.958, 3.548, -120.125]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube140.geometry}
        material={materials['Material.222']}
        position={[-1.16, 1.911, -126.508]}
        scale={[0.15, 2.01, 3.414]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube141.geometry}
        material={materials['Material.022']}
        position={[0.418, 1.911, -123.247]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube142.geometry}
        material={materials['Material.222']}
        position={[1.852, 1.911, -128.622]}
        scale={[0.15, 2.01, 5.444]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube143.geometry}
        material={materials['Material.222']}
        position={[3.801, 1.911, -133.924]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube144.geometry}
        material={materials['Material.222']}
        position={[5.565, 1.911, -128.622]}
        scale={[0.15, 2.01, 5.444]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube145.geometry}
        material={materials['Material.222']}
        position={[1.852, 1.911, -106.174]}
        scale={[0.15, 2.01, 5.444]}
      />
      <group position={[-2.712, 0, -101.319]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0001.geometry}
              material={materials['Material.029']}
              position={[0.42, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[0.051, 0, -104.36]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0002.geometry}
              material={materials['Material.030']}
              position={[0.42, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.709, 0, -107.045]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0003.geometry}
                material={materials['Material.031']}
                position={[0.42, 1.428, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-0.272, 0, -109.366]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0004.geometry}
              material={materials['Material.032']}
              position={[0.42, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.905, 0, -111.942]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0005.geometry}
              material={materials['Material.033']}
              position={[0.42, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.66, 0, -114.123]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0006.geometry}
              material={materials['Material.034']}
              position={[0.42, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-3.066, 0, -114.123]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0007.geometry}
              material={materials['Material.035']}
              position={[0.42, 4.105, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube146.geometry}
        material={materials['Material.222']}
        position={[5.254, 1.911, -100.873]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.491]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube147.geometry}
        material={materials['Material.222']}
        position={[5.544, 1.911, -98.535]}
        scale={[0.15, 2.01, 2.487]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube148.geometry}
        material={materials['Material.022']}
        position={[2.926, 1.911, -96.186]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.593]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube149.geometry}
        material={materials['Material.222']}
        position={[3.247, 1.911, -91.844]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube150.geometry}
        material={materials['Material.222']}
        position={[7.04, 1.911, -123.247]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube151.geometry}
        material={materials['Material.222']}
        position={[8.48, 1.911, -117.84]}
        scale={[0.15, 2.01, 5.444]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube152.geometry}
        material={materials['Material.222']}
        position={[7.04, 1.911, -112.554]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube153.geometry}
        material={materials['Material.222']}
        position={[5.836, 1.911, -109.442]}
        scale={[0.15, 2.01, 3.189]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube155.geometry}
        material={materials['Material.222']}
        position={[10.631, 1.911, -106.386]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.915]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube156.geometry}
        material={materials['Material.222']}
        position={[15.383, 1.911, -101.013]}
        scale={[0.15, 2.01, 5.444]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube157.geometry}
        material={materials['Material.222']}
        position={[13.44, 1.911, -95.772]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.683]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube158.geometry}
        material={materials['Material.222']}
        position={[12.986, 1.911, -98.191]}
        scale={[0.15, 2.01, 2.487]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_3_Material001_0002.geometry}
        material={materials['Material.045']}
        position={[2.063, -23.803, 0]}
        scale={[0.709, 4.01, 2.001]}
      />
      <group
        position={[19.737, 0, -101.319]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0003.geometry}
              material={materials['Material.046']}
              position={[1.937, -29.87, 0]}
              scale={[0.709, 4.346, 2.001]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube160.geometry}
        material={materials['Material.047']}
        position={[10.631, 1.911, -106.386]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.915]}
      />
      <group
        position={[2.598, 0, -78.836]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.002]}>
            <group position={[0, 0, -413.623]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0009.geometry}
                material={materials['Material.050']}
                position={[-1.158, 1.428, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -78.836]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.002]}>
            <group position={[0, 0, -413.623]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0010.geometry}
                material={materials['Material.051']}
                position={[-1.158, 1.428, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -83.275]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0011.geometry}
              material={materials['Material.052']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[2.433, 0, -83.275]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0012.geometry}
              material={materials['Material.053']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -75.345]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0013.geometry}
              material={materials['Material.054']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -71.886]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0014.geometry}
              material={materials['Material.055']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -68.342]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.623]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0015.geometry}
              material={materials['Material.056']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -64.713]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0016.geometry}
              material={materials['Material.057']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[4.775, 0, -61.226]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.001]}>
            <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0017.geometry}
                material={materials['Material.058']}
                position={[-1.158, 1.428, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[2.598, 0, -75.012]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0018.geometry}
              material={materials['Material.059']}
              position={[-1.158, 1.428, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[2.598, 0, -71.653]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.002]}>
            <group position={[0, 0, -413.623]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0019.geometry}
                material={materials['Material.060']}
                position={[-1.158, 1.671, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[2.598, 0, -68.477]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.002]}>
            <group position={[0, 0, -413.623]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0020.geometry}
                material={materials['Material.061']}
                position={[-1.158, 1.671, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[2.598, 0, -64.705]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.002]}>
            <group position={[0, 0, -413.623]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0021.geometry}
                material={materials['Material.062']}
                position={[-1.158, 1.671, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[2.598, 0, -61.156]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0022.geometry}
              material={materials['Material.063']}
              position={[-1.158, 1.671, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube161.geometry}
        material={materials['Material.065']}
        position={[0.216, 1.911, -58.658]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.935]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube162.geometry}
        material={materials['Material.066']}
        position={[-3.601, 1.911, -56.625]}
        rotation={[0, -0.02, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube164.geometry}
        material={materials['Material.068']}
        position={[-7.187, 1.911, -54.573]}
        rotation={[0, -0.018, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube163.geometry}
        material={materials['Material.069']}
        position={[-7.022, 1.911, -61.729]}
        rotation={[0, -0.02, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube165.geometry}
        material={materials['Material.070']}
        position={[-5.879, 1.911, -66.842]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 6.193]}
      />
      <group
        position={[-3.129, 0, -61.156]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.398, 0.402, 1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0023.geometry}
              material={materials['Material.072']}
              position={[-1.158, 1.671, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube166.geometry}
        material={materials['Material.072']}
        position={[-7.187, 1.911, -48.338]}
        rotation={[0, -0.018, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube167.geometry}
        material={materials['Material.073']}
        position={[-9.543, 1.911, -59.889]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.517]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube168.geometry}
        material={materials['Material.074']}
        position={[-9.543, 1.911, -56.413]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.517]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube169.geometry}
        material={materials['Material.075']}
        position={[8.975, 1.911, -62.014]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube170.geometry}
        material={materials['Material.076']}
        position={[7.81, 1.911, -66.003]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.332]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube172.geometry}
        material={materials['Material.078']}
        position={[3.943, 1.911, -56.905]}
        rotation={[0, -0.02, 0]}
        scale={[0.15, 2.01, 1.88]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube173.geometry}
        material={materials['Material.474']}
        position={[7.495, 1.911, -60.12]}
        rotation={[0, -0.02, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube174.geometry}
        material={materials['Material.080']}
        position={[3.564, 1.911, -55.023]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube175.geometry}
        material={materials['Material.081']}
        position={[2.129, 1.911, -51.095]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.981]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0010.geometry}
        material={materials['Material.079']}
        position={[7.53, -0.02, -45.127]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <group
        position={[26.685, 0, -51.135]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0004.geometry}
              material={materials['Material.477']}
              position={[4.466, -18.577, 0]}
              scale={[0.709, 4.737, 2.001]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube176.geometry}
        material={materials['Material.087']}
        position={[8.919, 1.911, -20.499]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube177.geometry}
        material={materials['Material.087']}
        position={[4.404, 1.911, -15.466]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube178.geometry}
        material={materials['Material.087']}
        position={[8.919, 1.911, -10.462]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <group
        position={[26.685, 0, -69.386]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0005.geometry}
              material={materials['Material.090']}
              position={[3.386, -22.127, 0]}
              scale={[0.709, 1.782, 2.001]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube179.geometry}
        material={materials['Material.091']}
        position={[-15.162, 1.911, -16.226]}
        rotation={[0, -0.012, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube180.geometry}
        material={materials['Material.092']}
        position={[-11.545, 1.911, -16.226]}
        rotation={[0, -0.012, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube181.geometry}
        material={materials['Material.093']}
        position={[-7.119, 1.911, -15.466]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.299]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube182.geometry}
        material={materials['Material.094']}
        position={[-2.849, 1.911, -16.226]}
        rotation={[0, -0.012, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube183.geometry}
        material={materials['Material.095']}
        position={[-1.273, 1.911, -9.58]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.939]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube184.geometry}
        material={materials['Material.096']}
        position={[-13.623, 1.911, 2.528]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 25.415]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube185.geometry}
        material={nodes.Cube185.material}
        position={[-20.003, 1.909, -67.73]}
        scale={[0.15, 2.01, 13.747]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube186.geometry}
        material={materials['Material.086']}
        position={[-87.951, 1.909, -69.77]}
        scale={[0.15, 2.01, 19]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube187.geometry}
        material={materials['Material.098']}
        position={[-99.035, 2.2, -19.878]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.247, 4.723]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube188.geometry}
        material={materials['Material.083']}
        position={[-108.722, 2.2, -17.322]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.241, 22.514]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube189.geometry}
        material={materials['Material.100']}
        position={[-94.369, 1.909, -25.183]}
        scale={[0.15, 2.01, 5.241]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube191.geometry}
        material={materials['Material.102']}
        position={[-92.727, 1.909, -30.241]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.697]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube192.geometry}
        material={materials['Material.103']}
        position={[-91.153, 1.909, -28.636]}
        scale={[0.15, 2.01, 1.697]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube193.geometry}
        material={materials['Material.104']}
        position={[-86.349, 1.909, -20.699]}
        scale={[0.15, 2.01, 3.525]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube195.geometry}
        material={materials['Material.106']}
        position={[-86.834, 1.909, -27.237]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.338]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube196.geometry}
        material={materials['Material.107']}
        position={[-88.395, 1.909, -33.549]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube197.geometry}
        material={materials['Material.108']}
        position={[-80.665, 1.909, -52.166]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube199.geometry}
        material={materials['Material.110']}
        position={[-80.629, 1.909, -55]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube200.geometry}
        material={materials['Material.111']}
        position={[-80.548, 1.909, -56.939]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube202.geometry}
        material={materials['Material.113']}
        position={[-80.446, 1.909, -61.695]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube203.geometry}
        material={materials['Material.114']}
        position={[-80.464, 1.909, -64.526]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube204.geometry}
        material={materials['Material.115']}
        position={[-80.398, 1.909, -66.549]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube205.geometry}
        material={materials.hosp}
        position={[-82.723, 1.909, -69.183]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 5.05]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube206.geometry}
        material={materials.hosp}
        position={[-80.351, 1.909, -70.987]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube207.geometry}
        material={materials.hosp}
        position={[-82.737, 1.909, -73.709]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 5.234]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube208.geometry}
        material={materials['Material.086']}
        position={[-80.888, 1.909, -75.853]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube211.geometry}
        material={materials['Material.086']}
        position={[-67.341, 1.909, -75.769]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 7.463]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube212.geometry}
        material={materials.hosp}
        position={[-72.09, 1.909, -73.709]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube213.geometry}
        material={materials.hosp}
        position={[-72.223, 1.909, -70.987]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube214.geometry}
        material={materials.hosp}
        position={[-72.255, 1.909, -69.183]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube215.geometry}
        material={materials.hosp}
        position={[-72.32, 1.909, -66.549]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube216.geometry}
        material={materials.hosp}
        position={[-72.356, 1.909, -64.526]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube217.geometry}
        material={materials.hosp}
        position={[-72.386, 1.909, -61.695]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube218.geometry}
        material={materials.hosp}
        position={[-72.415, 1.909, -59.666]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube219.geometry}
        material={materials.hosp}
        position={[-72.455, 1.909, -56.939]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube220.geometry}
        material={materials.hosp}
        position={[-72.46, 1.909, -55]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube221.geometry}
        material={materials.hosp}
        position={[-72.512, 1.909, -52.166]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.675]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube222.geometry}
        material={materials['Material.086']}
        position={[-84.134, 1.911, -78.517]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube223.geometry}
        material={materials['Material.221']}
        position={[-82.513, 1.909, -87.975]}
        scale={[0.193, 2.01, 2.089]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube224.geometry}
        material={materials['Material.222']}
        position={[-61.1, 1.911, -106.057]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.854]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube225.geometry}
        material={materials['Material.086']}
        position={[-75.775, 1.911, -80.891]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 8.441]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube226.geometry}
        material={materials['Material.221']}
        position={[-76.373, 1.911, -90.147]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube227.geometry}
        material={materials['Material.133']}
        position={[-65.586, 1.909, -100.855]}
        scale={[0.15, 2.01, 5.241]}
      />
      <group position={[-10.243, 0, -84.934]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group position={[-204.22, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_thing_Material001_0012.geometry}
                material={materials['Material.134']}
                position={[-48.599, 11.16, 0]}
                scale={[1.585, 1.636, 2.03]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.243, 0, -78.91]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0013.geometry}
              material={materials['Material.135']}
              position={[-48.599, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.243, 0, -72.948]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0014.geometry}
              material={materials['Material.136']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.243, 0, -72.948]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0015.geometry}
              material={materials['Material.137']}
              position={[-48.599, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.243, 0, -78.956]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0016.geometry}
              material={materials['Material.138']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-16.263, 0, -78.956]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0017.geometry}
              material={materials['Material.139']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-16.263, 0, -84.878]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0018.geometry}
              material={materials['Material.140']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.457, 0, -84.878]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0019.geometry}
              material={materials['Material.141']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-22.197, 0, -84.878]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0020.geometry}
              material={materials['Material.142']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-22.197, 0, -79.176]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[-204.22, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_thing_Material001_0021.geometry}
                material={materials['Material.143']}
                position={[-54.711, 11.16, 0]}
                scale={[1.585, 1.636, 2.03]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-15.968, 0, -72.553]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0023.geometry}
              material={materials['Material.145']}
              position={[-54.711, 11.16, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube228.geometry}
        material={materials['Material.086']}
        position={[-55.543, 1.911, -80.076]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 8.441]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube229.geometry}
        material={materials.hosp}
        position={[-59.843, 1.909, -73.353]}
        scale={[0.15, 2.01, 2.518]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube230.geometry}
        material={materials.hosp}
        position={[-56.886, 1.909, -73.589]}
        scale={[0.15, 2.01, 2.962]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube231.geometry}
        material={materials.hosp}
        position={[-49.263, 1.909, -76.416]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 7.463]}
      />
      <group position={[-45.991, 0, -75.035]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0024.geometry}
              material={materials['Material.149']}
              position={[-0.209, 4.105, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-45.991, 0, -75.035]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0025.geometry}
              material={materials['Material.150']}
              position={[-0.23, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-44.648, 0, -78.14]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0026.geometry}
              material={materials['Material.151']}
              position={[1.317, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-42.783, 0, -81.298]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0027.geometry}
              material={materials['Material.152']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-42.783, 0, -84.313]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0028.geometry}
              material={materials['Material.153']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-45.386, 0, -84.313]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0029.geometry}
              material={materials['Material.154']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-48.134, 0, -84.313]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0030.geometry}
              material={materials['Material.155']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[12.862, 0, -78.956]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0022.geometry}
              material={materials['Material.156']}
              position={[-54.711, 16.968, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group position={[-45.378, 0, -81.298]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0031.geometry}
              material={materials['Material.157']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-48.198, 0, -81.298]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0032.geometry}
              material={materials['Material.158']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-48.185, 0, -78.14]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0033.geometry}
              material={materials['Material.159']}
              position={[2.025, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-43.055, 0, -75.035]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0034.geometry}
              material={materials['Material.160']}
              position={[-0.23, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube232.geometry}
        material={materials['Material.222']}
        position={[-38.272, 1.911, -91.283]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.337]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube233.geometry}
        material={materials['Material.222']}
        position={[-39.683, 1.909, -89.091]}
        scale={[0.15, 2.01, 2.34]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube234.geometry}
        material={materials.hosp}
        position={[-36.224, 1.909, -63.719]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube235.geometry}
        material={materials['Material.222']}
        position={[-38.409, 1.909, -80.044]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <group position={[-35.218, 0, -75.035]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0035.geometry}
              material={materials['Material.165']}
              position={[-0.23, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-36.223, 0, -66.737]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0036.geometry}
              material={materials['Material.166']}
              position={[-0.23, 7.028, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube236.geometry}
        material={materials['Material.167']}
        position={[-72.935, 1.911, -130.443]}
        scale={[0.15, 2.01, 4.542]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube238.geometry}
        material={materials['Material.221']}
        position={[-83.099, 1.911, -129.308]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.195, 2.01, 6.425]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube239.geometry}
        material={materials['Material.221']}
        position={[-72.423, 1.911, -121.116]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.195, 2.01, 2.111]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube240.geometry}
        material={materials['Material.221']}
        position={[-85.92, 1.909, -127.846]}
        rotation={[Math.PI, -0.006, Math.PI]}
        scale={[0.15, 2.01, 1.6]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube241.geometry}
        material={materials['Material.221']}
        position={[-80.728, 1.909, -124.196]}
        rotation={[Math.PI, -0.006, Math.PI]}
        scale={[0.15, 2.01, 1.6]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube242.geometry}
        material={materials['Material.221']}
        position={[-107.37, 1.911, -134.877]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 34.708]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube243.geometry}
        material={materials['Material.221']}
        position={[-134.072, 1.911, -129.308]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.195, 2.01, 6.425]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube244.geometry}
        material={materials['Material.221']}
        position={[-127.838, 1.909, -126.185]}
        scale={[0.15, 2.01, 3.231]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube245.geometry}
        material={materials['Material.221']}
        position={[-125.06, 1.909, -126.246]}
        scale={[0.15, 2.01, 3.231]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube246.geometry}
        material={materials['Material.221']}
        position={[-116.94, 1.827, -130.843]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.48]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube247.geometry}
        material={materials['Material.221']}
        position={[-118.925, 1.909, -128.604]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.455]}
      />
      <group position={[-22.197, 0, -113.343]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.001]}>
            <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_thing_Material001_0024.geometry}
                material={materials['Material.168']}
                position={[-89.739, 11.16, 0]}
                scale={[1.585, 1.636, 2.03]}
              />
            </group>
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube248.geometry}
        material={materials['Material.221']}
        position={[-108.917, 1.909, -128.165]}
        rotation={[Math.PI, -0.006, Math.PI]}
        scale={[0.15, 2.01, 1.6]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube249.geometry}
        material={materials['Material.221']}
        position={[-102.444, 1.909, -127.152]}
        rotation={[Math.PI, -0.006, Math.PI]}
        scale={[0.15, 2.01, 2.649]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube250.geometry}
        material={materials['Material.221']}
        position={[-104.567, 1.909, -124.598]}
        rotation={[0, -1.564, 0]}
        scale={[0.15, 2.01, 2.248]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube251.geometry}
        material={materials['Material.221']}
        position={[-107.878, 2.051, -110.454]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 2.711]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube252.geometry}
        material={materials['Material.221']}
        position={[-107.438, 1.945, -106.204]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube253.geometry}
        material={materials['Material.221']}
        position={[-106.659, 1.946, -107.041]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube254.geometry}
        material={materials['Material.221']}
        position={[-107.219, 1.945, -107.994]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube255.geometry}
        material={materials['Material.221']}
        position={[-107.577, 2.052, -118.095]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 3.231]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube256.geometry}
        material={materials['Material.221']}
        position={[-107.013, 1.945, -114.973]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube257.geometry}
        material={materials['Material.221']}
        position={[-106.453, 1.946, -114.021]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube258.geometry}
        material={materials['Material.221']}
        position={[-107.232, 1.945, -113.183]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube259.geometry}
        material={materials['Material.221']}
        position={[-108.007, 2.051, -102.812]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 3.327]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube260.geometry}
        material={materials['Material.221']}
        position={[-121.506, 2.051, -102.812]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 3.327]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube261.geometry}
        material={materials['Material.221']}
        position={[-120.731, 1.945, -113.183]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube262.geometry}
        material={materials['Material.221']}
        position={[-119.953, 1.946, -114.021]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube263.geometry}
        material={materials['Material.221']}
        position={[-120.513, 1.945, -114.973]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube264.geometry}
        material={materials['Material.221']}
        position={[-121.077, 2.052, -117.478]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 2.492]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube265.geometry}
        material={materials['Material.221']}
        position={[-120.718, 1.945, -107.994]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube266.geometry}
        material={materials['Material.221']}
        position={[-120.159, 1.946, -107.041]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube267.geometry}
        material={materials['Material.221']}
        position={[-120.937, 1.945, -106.204]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube268.geometry}
        material={materials['Material.221']}
        position={[-121.378, 2.051, -110.454]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 2.711]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube269.geometry}
        material={materials['Material.221']}
        position={[-115.272, 1.909, -110.454]}
        scale={[0.15, 2.01, 2.711]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube270.geometry}
        material={materials['Material.221']}
        position={[-115.713, 2.016, -106.204]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube271.geometry}
        material={materials['Material.221']}
        position={[-115.573, 1.909, -118.095]}
        rotation={[0, 0, Math.PI]}
        scale={[0.15, 2.01, 3.231]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube272.geometry}
        material={materials['Material.221']}
        position={[-116.137, 2.016, -114.973]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube273.geometry}
        material={materials['Material.221']}
        position={[-116.697, 2.016, -114.021]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube274.geometry}
        material={materials['Material.221']}
        position={[-115.918, 2.016, -113.183]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube275.geometry}
        material={materials['Material.221']}
        position={[-115.144, 1.909, -102.812]}
        scale={[0.15, 2.01, 3.327]}
      />
      <group position={[-22.197, 0, -113.343]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.001]}>
            <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_thing_Material001_0025.geometry}
                material={materials['Material.169']}
                position={[-89.739, 11.16, 0]}
                scale={[1.585, 1.636, 2.03]}
              />
            </group>
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column002.geometry}
        material={materials['Column_material.002']}
        position={[-114.157, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top002.geometry}
          material={materials['Column_rect.002']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column003.geometry}
        material={materials['Column_material.003']}
        position={[-113.032, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top003.geometry}
          material={materials['Column_rect.003']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column004.geometry}
        material={materials['Column_material.004']}
        position={[-111.955, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top004.geometry}
          material={materials['Column_rect.004']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column005.geometry}
        material={materials['Column_material.005']}
        position={[-110.977, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top005.geometry}
          material={materials['Column_rect.005']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column006.geometry}
        material={materials['Column_material.006']}
        position={[-110.101, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top006.geometry}
          material={materials['Column_rect.006']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column007.geometry}
        material={materials['Column_material.007']}
        position={[-109.192, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top007.geometry}
          material={materials['Column_rect.007']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column008.geometry}
        material={materials['Column_material.008']}
        position={[-108.261, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top008.geometry}
          material={materials['Column_rect.008']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column009.geometry}
        material={materials['Column_material.009']}
        position={[-115.128, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top009.geometry}
          material={materials['Column_rect.009']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column010.geometry}
        material={materials['Column_material.010']}
        position={[-115.128, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top010.geometry}
          material={materials['Column_rect.010']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column011.geometry}
        material={materials['Column_material.011']}
        position={[-108.261, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top011.geometry}
          material={materials['Column_rect.011']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column012.geometry}
        material={materials['Column_material.012']}
        position={[-109.192, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top012.geometry}
          material={materials['Column_rect.012']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column013.geometry}
        material={materials['Column_material.013']}
        position={[-110.101, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top013.geometry}
          material={materials['Column_rect.013']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column014.geometry}
        material={materials['Column_material.014']}
        position={[-110.977, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top014.geometry}
          material={materials['Column_rect.014']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column015.geometry}
        material={materials['Column_material.015']}
        position={[-111.955, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top015.geometry}
          material={materials['Column_rect.015']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column016.geometry}
        material={materials['Column_material.016']}
        position={[-113.032, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top016.geometry}
          material={materials['Column_rect.016']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column017.geometry}
        material={materials['Column_material.017']}
        position={[-114.157, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top017.geometry}
          material={materials['Column_rect.017']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column018.geometry}
        material={materials['Column_material.018']}
        position={[-114.157, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top018.geometry}
          material={materials['Column_rect.018']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column019.geometry}
        material={materials['Column_material.019']}
        position={[-113.032, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top019.geometry}
          material={materials['Column_rect.019']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column020.geometry}
        material={materials['Column_material.020']}
        position={[-111.955, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top020.geometry}
          material={materials['Column_rect.020']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column021.geometry}
        material={materials['Column_material.021']}
        position={[-110.977, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top021.geometry}
          material={materials['Column_rect.021']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column022.geometry}
        material={materials['Column_material.022']}
        position={[-110.101, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top022.geometry}
          material={materials['Column_rect.022']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column023.geometry}
        material={materials['Column_material.023']}
        position={[-109.192, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top023.geometry}
          material={materials['Column_rect.023']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column024.geometry}
        material={materials['Column_material.024']}
        position={[-108.261, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top024.geometry}
          material={materials['Column_rect.024']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column025.geometry}
        material={materials['Column_material.025']}
        position={[-115.128, 0.023, -119.921]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top025.geometry}
          material={materials['Column_rect.025']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column026.geometry}
        material={materials['Column_material.026']}
        position={[-115.128, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top026.geometry}
          material={materials['Column_rect.026']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column027.geometry}
        material={materials['Column_material.027']}
        position={[-108.261, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top027.geometry}
          material={materials['Column_rect.027']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column028.geometry}
        material={materials['Column_material.028']}
        position={[-115.128, 0.023, -117.367]}
        scale={[1, 1.714, 1]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column029.geometry}
        material={materials['Column_material.029']}
        position={[-108.261, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top028.geometry}
          material={materials['Column_rect.028']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column030.geometry}
        material={materials['Column_material.030']}
        position={[-109.192, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top029.geometry}
          material={materials['Column_rect.029']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column031.geometry}
        material={materials['Column_material.031']}
        position={[-110.101, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top030.geometry}
          material={materials['Column_rect.030']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column032.geometry}
        material={materials['Column_material.032']}
        position={[-110.977, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top031.geometry}
          material={materials['Column_rect.031']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column033.geometry}
        material={materials['Column_material.033']}
        position={[-111.955, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top032.geometry}
          material={materials['Column_rect.032']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column034.geometry}
        material={materials['Column_material.034']}
        position={[-113.032, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top033.geometry}
          material={materials['Column_rect.033']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column035.geometry}
        material={materials['Column_material.035']}
        position={[-114.157, 0.023, -117.367]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top034.geometry}
          material={materials['Column_rect.034']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column036.geometry}
        material={materials['Column_material.036']}
        position={[-114.157, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top035.geometry}
          material={materials['Column_rect.035']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column037.geometry}
        material={materials['Column_material.037']}
        position={[-113.032, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top036.geometry}
          material={materials['Column_rect.036']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column038.geometry}
        material={materials['Column_material.038']}
        position={[-111.955, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top037.geometry}
          material={materials['Column_rect.037']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column039.geometry}
        material={materials['Column_material.039']}
        position={[-110.977, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top038.geometry}
          material={materials['Column_rect.038']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column040.geometry}
        material={materials['Column_material.040']}
        position={[-110.101, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top039.geometry}
          material={materials['Column_rect.039']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column041.geometry}
        material={materials['Column_material.041']}
        position={[-109.192, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top040.geometry}
          material={materials['Column_rect.040']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column042.geometry}
        material={materials['Column_material.042']}
        position={[-108.261, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top041.geometry}
          material={materials['Column_rect.041']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column043.geometry}
        material={materials['Column_material.043']}
        position={[-115.128, 0.023, -114.786]}
        scale={[1, 1.714, 1]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column044.geometry}
        material={materials['Column_material.044']}
        position={[-108.261, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top042.geometry}
          material={materials['Column_rect.042']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column045.geometry}
        material={materials['Column_material.045']}
        position={[-115.128, 0.023, -114.786]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top043.geometry}
          material={materials['Column_rect.043']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column046.geometry}
        material={materials['Column_material.046']}
        position={[-115.128, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top044.geometry}
          material={materials['Column_rect.044']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column047.geometry}
        material={materials['Column_material.047']}
        position={[-108.261, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top045.geometry}
          material={materials['Column_rect.045']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column048.geometry}
        material={materials['Column_material.048']}
        position={[-115.128, 0.023, -104.993]}
        scale={[1, 1.714, 1]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column049.geometry}
        material={materials['Column_material.049']}
        position={[-108.261, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top046.geometry}
          material={materials['Column_rect.046']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column050.geometry}
        material={materials['Column_material.050']}
        position={[-109.192, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top047.geometry}
          material={materials['Column_rect.047']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column051.geometry}
        material={materials['Column_material.051']}
        position={[-110.101, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top048.geometry}
          material={materials['Column_rect.048']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column052.geometry}
        material={materials['Column_material.052']}
        position={[-110.977, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top049.geometry}
          material={materials['Column_rect.049']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column053.geometry}
        material={materials['Column_material.053']}
        position={[-111.955, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top050.geometry}
          material={materials['Column_rect.050']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column054.geometry}
        material={materials['Column_material.054']}
        position={[-113.032, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top051.geometry}
          material={materials['Column_rect.051']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column055.geometry}
        material={materials['Column_material.055']}
        position={[-114.157, 0.023, -104.993]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top052.geometry}
          material={materials['Column_rect.052']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column056.geometry}
        material={materials['Column_material.056']}
        position={[-114.157, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top053.geometry}
          material={materials['Column_rect.053']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column057.geometry}
        material={materials['Column_material.057']}
        position={[-113.032, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top054.geometry}
          material={materials['Column_rect.054']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column058.geometry}
        material={materials['Column_material.058']}
        position={[-111.955, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top055.geometry}
          material={materials['Column_rect.055']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column059.geometry}
        material={materials['Column_material.059']}
        position={[-110.977, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top056.geometry}
          material={materials['Column_rect.056']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column060.geometry}
        material={materials['Column_material.060']}
        position={[-110.101, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top057.geometry}
          material={materials['Column_rect.057']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column061.geometry}
        material={materials['Column_material.061']}
        position={[-109.192, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top058.geometry}
          material={materials['Column_rect.058']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column062.geometry}
        material={materials['Column_material.062']}
        position={[-108.261, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top059.geometry}
          material={materials['Column_rect.059']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column063.geometry}
        material={materials['Column_material.063']}
        position={[-115.128, 0.023, -103.199]}
        scale={[1, 1.714, 1]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column064.geometry}
        material={materials['Column_material.064']}
        position={[-108.261, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top060.geometry}
          material={materials['Column_rect.060']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column065.geometry}
        material={materials['Column_material.065']}
        position={[-115.128, 0.023, -103.199]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top061.geometry}
          material={materials['Column_rect.061']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column066.geometry}
        material={materials['Column_material.066']}
        position={[-114.157, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top062.geometry}
          material={materials['Column_rect.062']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column067.geometry}
        material={materials['Column_material.067']}
        position={[-113.032, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top063.geometry}
          material={materials['Column_rect.063']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column068.geometry}
        material={materials['Column_material.068']}
        position={[-111.955, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top064.geometry}
          material={materials['Column_rect.064']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column069.geometry}
        material={materials['Column_material.069']}
        position={[-110.977, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top065.geometry}
          material={materials['Column_rect.065']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column070.geometry}
        material={materials['Column_material.070']}
        position={[-110.101, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top066.geometry}
          material={materials['Column_rect.066']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column071.geometry}
        material={materials['Column_material.071']}
        position={[-109.192, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top067.geometry}
          material={materials['Column_rect.067']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column072.geometry}
        material={materials['Column_material.072']}
        position={[-108.261, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top068.geometry}
          material={materials['Column_rect.068']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column073.geometry}
        material={materials['Column_material.073']}
        position={[-115.128, 0.023, -101.294]}
        scale={[1, 1.714, 1]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column074.geometry}
        material={materials['Column_material.074']}
        position={[-108.261, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top069.geometry}
          material={materials['Column_rect.069']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column075.geometry}
        material={materials['Column_material.075']}
        position={[-115.128, 0.023, -101.294]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top070.geometry}
          material={materials['Column_rect.070']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column076.geometry}
        material={materials['Column_material.076']}
        position={[-115.128, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top071.geometry}
          material={materials['Column_rect.071']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column077.geometry}
        material={materials['Column_material.077']}
        position={[-108.261, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top072.geometry}
          material={materials['Column_rect.072']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column078.geometry}
        material={materials['Column_material.078']}
        position={[-115.128, 0.023, -99.629]}
        scale={[1, 1.714, 1]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column079.geometry}
        material={materials['Column_material.079']}
        position={[-108.261, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top073.geometry}
          material={materials['Column_rect.073']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column080.geometry}
        material={materials['Column_material.080']}
        position={[-109.192, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top074.geometry}
          material={materials['Column_rect.074']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column081.geometry}
        material={materials['Column_material.081']}
        position={[-110.101, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top075.geometry}
          material={materials['Column_rect.075']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column082.geometry}
        material={materials['Column_material.082']}
        position={[-110.977, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top076.geometry}
          material={materials['Column_rect.076']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column083.geometry}
        material={materials['Column_material.083']}
        position={[-111.955, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top077.geometry}
          material={materials['Column_rect.077']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column084.geometry}
        material={materials['Column_material.084']}
        position={[-113.032, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top078.geometry}
          material={materials['Column_rect.078']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column085.geometry}
        material={materials['Column_material.085']}
        position={[-114.157, 0.023, -99.629]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top079.geometry}
          material={materials['Column_rect.079']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube276.geometry}
        material={materials['Material.221']}
        position={[-115.849, 1.945, -107.994]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.709]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube277.geometry}
        material={materials['Material.221']}
        position={[-116.536, 1.946, -107.041]}
        rotation={[0, 0, -3.14]}
        scale={[0.15, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube278.geometry}
        material={materials['Material.221']}
        position={[-119.874, 1.909, -119.952]}
        rotation={[0, -1.564, 0]}
        scale={[0.15, 2.01, 1.929]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube279.geometry}
        material={materials['Material.221']}
        position={[-121.262, 1.909, -127.209]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={[0.15, 2.01, 1.6]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube280.geometry}
        material={materials['Material.221']}
        position={[-98.865, 2.016, -133.717]}
        scale={[0.15, 2.01, 0.8]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube282.geometry}
        material={materials['Material.221']}
        position={[-92.832, 1.909, -132.856]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.149]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube283.geometry}
        material={materials['Material.221']}
        position={[-94.108, 1.909, -133.779]}
        scale={[0.15, 2.01, 1.058]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube284.geometry}
        material={materials['Material.221']}
        position={[-97.708, 1.909, -130.334]}
        scale={[0.15, 2.01, 2.649]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube285.geometry}
        material={materials['Material.221']}
        position={[-91.601, 1.909, -130.334]}
        scale={[0.15, 2.01, 2.649]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube286.geometry}
        material={materials['Material.221']}
        position={[-142.004, 2.105, -125.113]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[0.15, 2.01, 1.6]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube287.geometry}
        material={materials['Material.221']}
        position={[-143.298, 2.105, -127.507]}
        rotation={[-Math.PI, 0.042, -Math.PI]}
        scale={[0.15, 2.01, 2.455]}
      />
      <group position={[-47.918, 0, -113.343]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -0.001]}>
            <group position={[-204.22, 0, -413.622]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_thing_Material001_0026.geometry}
                material={materials['Material.170']}
                position={[-89.739, 9.785, 0]}
                scale={[1.585, 1.636, 2.03]}
              />
            </group>
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column086.geometry}
        material={materials['Column_material.086']}
        position={[-142.861, 0.023, -133.508]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column087.geometry}
        material={materials['Column_material.087']}
        position={[-141.861, 0.023, -133.508]}
        rotation={[0.424, 0, 0]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column088.geometry}
        material={materials['Column_material.088']}
        position={[-141.861, 0.023, -133.508]}
        rotation={[0.337, -0.263, -0.638]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column089.geometry}
        material={materials['Column_material.089']}
        position={[-141.861, 0.023, -133.508]}
        rotation={[-0.326, -0.263, -0.638]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column090.geometry}
        material={materials['Column_material.090']}
        position={[-141.861, 0.023, -133.508]}
        rotation={[1.32, -0.263, -0.638]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column091.geometry}
        material={materials['Column_material.091']}
        position={[-142.861, 0.023, -133.508]}
        rotation={[1.337, 0, 0]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column092.geometry}
        material={materials['Column_material.092']}
        position={[-142.861, 2.023, -133.508]}
        rotation={[1.936, 0, 0]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column093.geometry}
        material={materials['Column_material.093']}
        position={[-142.861, 2.023, -133.508]}
        rotation={[1.141, 0, 0]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column094.geometry}
        material={materials['Column_material.094']}
        position={[-142.861, 2.023, -133.508]}
        rotation={[-2.114, 0, 0]}
        scale={[2.202, 1.714, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube288.geometry}
        material={materials['Material.221']}
        position={[-146.298, 2.105, -135.507]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={[0.15, 2.01, 2.455]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube289.geometry}
        material={materials['Material.221']}
        position={[-146.004, 2.105, -131.113]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube290.geometry}
        material={materials['Material.221']}
        position={[-144.298, 2.105, -135.507]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.455]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube291.geometry}
        material={materials['Material.086']}
        position={[-112.485, 1.841, -89.427]}
        rotation={[-0.724, 1.522, 0.718]}
        scale={[0.15, 2.01, 1.078]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube292.geometry}
        material={materials['Material.221']}
        position={[-109.827, 1.894, -94.079]}
        rotation={[-0.724, 1.522, 0.718]}
        scale={[0.24, 2.01, 1.23]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube293.geometry}
        material={materials['Material.086']}
        position={[-111.233, 1.866, -91.789]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube294.geometry}
        material={materials['Material.086']}
        position={[-113.684, 1.827, -86.061]}
        rotation={[-Math.PI, 0.037, -Math.PI]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube295.geometry}
        material={materials['Material.086']}
        position={[-110.684, 1.827, -81.061]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube296.geometry}
        material={materials['Material.086']}
        position={[-108.233, 1.866, -86.789]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube297.geometry}
        material={materials['Material.086']}
        position={[-106.827, 1.894, -89.079]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[0.24, 2.01, 1.23]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube298.geometry}
        material={materials['Material.086']}
        position={[-109.485, 1.841, -84.427]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.078]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube299.geometry}
        material={materials['Material.086']}
        position={[-97.245, 1.841, -64.764]}
        rotation={[-1.252, -1.537, -1.258]}
        scale={[0.15, 2.01, 1.078]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube300.geometry}
        material={materials['Material.086']}
        position={[-99.681, 1.894, -59.992]}
        rotation={[-1.252, -1.537, -1.258]}
        scale={[0.24, 2.01, 1.23]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube301.geometry}
        material={materials['Material.086']}
        position={[-98.384, 1.866, -62.345]}
        rotation={[0.006, 0.01, -0.032]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube302.geometry}
        material={materials['Material.086']}
        position={[-96.206, 1.827, -68.183]}
        rotation={[0.006, 0.01, -0.032]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube303.geometry}
        material={materials['Material.086']}
        position={[-101.004, 2.105, -80.883]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube304.geometry}
        material={materials['Material.086']}
        position={[-101.004, 2.105, -73.303]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube305.geometry}
        material={materials['Material.086']}
        position={[-109.004, 2.105, -75.113]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube306.geometry}
        material={materials['Material.086']}
        position={[-109.004, 2.105, -68.113]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube307.geometry}
        material={materials['Material.086']}
        position={[-101.004, 4.105, -65.669]}
        rotation={[2.58, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube308.geometry}
        material={materials['Material.221']}
        position={[-128.879, 1.827, -81.424]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 1.441]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube309.geometry}
        material={materials['Material.221']}
        position={[-126.684, 1.827, -85.061]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 1.064]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube310.geometry}
        material={materials['Material.221']}
        position={[-126.684, 1.827, -81.061]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 1.064]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube311.geometry}
        material={materials['Material.221']}
        position={[-115.881, 1.827, -85.221]}
        rotation={[0, 0.007, 0]}
        scale={[0.15, 2.01, 4.48]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube312.geometry}
        material={materials['Material.221']}
        position={[-117.626, 1.909, -94.816]}
        rotation={[0, 0.013, 0]}
        scale={[0.15, 2.01, 3.285]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube314.geometry}
        material={materials['Material.221']}
        position={[-123.315, 1.911, -84.906]}
        rotation={[Math.PI, -0.007, Math.PI]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube315.geometry}
        material={materials['Material.221']}
        position={[-121.354, 1.911, -94.766]}
        rotation={[Math.PI, -0.007, Math.PI]}
        scale={[0.15, 2.01, 6.425]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column095.geometry}
        material={materials['Column_material.095']}
        position={[-121.229, 0.023, -93.508]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 1.589, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column096.geometry}
        material={materials['Column_material.096']}
        position={[-121.229, 1.582, -93.508]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 1.589, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column097.geometry}
        material={materials['Column_material.097']}
        position={[-116.051, 1.582, -83.774]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 0.955, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column098.geometry}
        material={materials['Column_material.098']}
        position={[-117.081, -0.091, -84.056]}
        scale={[2.202, 1.942, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column099.geometry}
        material={materials['Column_material.099']}
        position={[-118.548, -0.091, -84.056]}
        scale={[2.202, 1.814, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column100.geometry}
        material={materials['Column_material.100']}
        position={[-120.2, -0.091, -84.056]}
        scale={[2.202, 1.776, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column101.geometry}
        material={materials['Column_material.101']}
        position={[-117.081, -0.091, -85.852]}
        scale={[2.202, 2.716, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube316.geometry}
        material={materials['Material.099']}
        position={[-127.329, 1.841, -46.922]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.078]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube318.geometry}
        material={materials['Material.082']}
        position={[-126.077, 1.866, -49.284]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 2.568]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube319.geometry}
        material={materials['Material.071']}
        position={[-128.528, 1.827, -43.556]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 3.556]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube320.geometry}
        material={materials['Material.084']}
        position={[-126.764, 1.894, -51.785]}
        rotation={[-0.724, 1.522, 0.718]}
        scale={[0.241, 2.017, 5.062]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column103.geometry}
        material={materials['Column_material.103']}
        position={[-116.051, 0.703, -83.774]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 0.955, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column104.geometry}
        material={materials['Column_material.104']}
        position={[-116.051, 2.443, -83.774]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 0.955, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube322.geometry}
        material={materials.Material}
        position={[-56.767, 6.133, -107.157]}
        rotation={[0, 1.535, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube323.geometry}
        material={materials['Material.064']}
        position={[-51.408, 6.133, -106.934]}
        rotation={[0, 1.535, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube324.geometry}
        material={materials['Material.067']}
        position={[-51.408, 6.133, -99.852]}
        rotation={[0, 1.535, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube325.geometry}
        material={materials['Material.097']}
        position={[-57.012, 6.133, -99.852]}
        rotation={[0, 1.535, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube326.geometry}
        material={materials.hosp}
        position={[-30.051, 1.909, -68.157]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube327.geometry}
        material={materials.hosp}
        position={[-36.206, 1.909, -60.044]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube329.geometry}
        material={materials['Material.173']}
        position={[-34.777, 1.909, -29.606]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.924]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube330.geometry}
        material={materials['Material.174']}
        position={[-34.777, 1.909, -3.02]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube331.geometry}
        material={materials['Material.175']}
        position={[-39.17, 1.909, -6.218]}
        scale={[0.151, 2.01, 3.253]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube332.geometry}
        material={materials['Material.176']}
        position={[-26.73, 1.909, -12.707]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube334.geometry}
        material={materials['Material.178']}
        position={[-43.901, 1.909, 5.957]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube336.geometry}
        material={materials.hosp}
        position={[-35.994, 1.909, -43.696]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube337.geometry}
        material={materials.hosp}
        position={[-36.364, 1.909, -53.872]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.427]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube338.geometry}
        material={materials.hosp}
        position={[-28.752, 1.909, -53.872]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.427]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube339.geometry}
        material={materials.hosp}
        position={[-21.21, 1.909, -53.872]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.427]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube340.geometry}
        material={materials.hosp}
        position={[-24.152, 1.909, -50.244]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.427]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube341.geometry}
        material={materials.hosp}
        position={[-33.212, 1.909, -50.244]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.427]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube342.geometry}
        material={materials.hosp}
        position={[-33.7, 1.909, -45.616]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.427]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube343.geometry}
        material={materials['Material.187']}
        position={[-24.152, 1.909, -45.392]}
        scale={[0.151, 2.01, 1.617]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube344.geometry}
        material={materials['Material.188']}
        position={[-27.589, 1.909, -45.392]}
        scale={[0.151, 2.01, 1.617]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube345.geometry}
        material={materials.hosp}
        position={[-32.809, 1.909, -31.163]}
        scale={[0.151, 2.01, 1.617]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube346.geometry}
        material={materials.hosp}
        position={[-32.809, 1.909, -36.851]}
        scale={[0.151, 2.01, 1.617]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube347.geometry}
        material={materials.hosp}
        position={[-32.809, 1.909, -43.913]}
        scale={[0.151, 2.01, 1.617]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube348.geometry}
        material={materials['Material.192']}
        position={[-38.212, 1.909, -33.537]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.617]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube349.geometry}
        material={materials.hosp}
        position={[-78.058, 1.909, -46.279]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube350.geometry}
        material={materials.hosp}
        position={[-75.222, 1.909, -46.279]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube351.geometry}
        material={materials['Material.195']}
        position={[-75.222, 1.909, -40.696]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube335.geometry}
        material={materials['Material.196']}
        position={[-78.041, 1.909, -40.696]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube352.geometry}
        material={materials['Material.197']}
        position={[-79.546, 1.909, -42.108]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube353.geometry}
        material={materials['Material.198']}
        position={[-79.546, 1.909, -44.899]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube354.geometry}
        material={materials.hosp}
        position={[-73.722, 1.909, -44.899]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube355.geometry}
        material={materials['Material.200']}
        position={[-73.722, 1.909, -42.079]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube356.geometry}
        material={materials.hosp}
        position={[-82.092, 1.909, -47.57]}
        rotation={[Math.PI, -0.416, Math.PI]}
        scale={[0.182, 2.01, 2.941]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube357.geometry}
        material={materials.hosp}
        position={[-71.235, 1.909, -47.57]}
        rotation={[-Math.PI, 0.397, -Math.PI]}
        scale={[0.182, 2.01, 2.941]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube358.geometry}
        material={materials['Material.203']}
        position={[-81.627, 1.911, -40.712]}
        rotation={[-Math.PI, 0.458, -Math.PI]}
        scale={[0.182, 2.01, 1.687]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube359.geometry}
        material={materials['Material.204']}
        position={[-71.329, 1.909, -40.854]}
        rotation={[-3.137, -0.705, -3.136]}
        scale={[0.182, 2.01, 1.687]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube360.geometry}
        material={materials.hosp}
        position={[-85.492, 1.909, -59.737]}
        rotation={[0, -0.899, 0]}
        scale={[0.2, 2.01, 3.196]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube201.geometry}
        material={materials.hosp}
        position={[-66.968, 1.909, -65.706]}
        rotation={[0, -1.147, 0]}
        scale={[0.197, 2.01, 3]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube361.geometry}
        material={materials['Material.177']}
        position={[-86.263, 1.909, -46.406]}
        rotation={[Math.PI, -0.366, Math.PI]}
        scale={[0.212, 2.01, 4.965]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube362.geometry}
        material={materials['Material.208']}
        position={[-91.153, 1.909, -19.738]}
        scale={[0.15, 2.01, 2.665]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube363.geometry}
        material={materials['Material.209']}
        position={[-97.509, 1.909, -56.759]}
        rotation={[0, -0.899, 0]}
        scale={[0.173, 2.01, 2.501]}
      />
      <group position={[-45.991, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0037.geometry}
              material={materials['Material.210']}
              position={[-13.723, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-41.213, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0038.geometry}
              material={materials['Material.211']}
              position={[-13.879, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-37.215, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0039.geometry}
              material={materials['Material.212']}
              position={[-8.829, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-37.215, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0040.geometry}
              material={materials['Material.213']}
              position={[-13.335, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-32.826, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0041.geometry}
              material={materials['Material.214']}
              position={[-8.829, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-50.516, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0042.geometry}
                material={materials['Material.215']}
                position={[-13.723, 5.752, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-62.903, 0, -34.518]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0043.geometry}
              material={materials['Material.216']}
              position={[-13.723, 4.958, 0]}
              scale={[0.34, 0.357, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-26.885, 0, -14.366]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0044.geometry}
              material={materials['Material.217']}
              position={[-8.829, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-21.715, 0, -9.659]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0045.geometry}
              material={materials['Material.218']}
              position={[-8.829, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-26.36, 0, -6.439]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0046.geometry}
              material={materials['Material.219']}
              position={[-8.829, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-1.742, 0, -4.247]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[2.88, 1, 2.176]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.wall_thick_3_Material001_0001.geometry}
            material={materials['Material.457']}
            position={[-427.718, 0, 172.539]}
            rotation={[-Math.PI / 2, 0, -Math.PI]}
            scale={100}
          />
        </group>
      </group>
      <group
        position={[-11.194, 0, -4.247]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[2.88, 1, 2.176]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.wall_thick_3_Material001_0002.geometry}
            material={materials['Material.457']}
            position={[-427.718, 0, 172.539]}
            rotation={[-Math.PI / 2, 0, -Math.PI]}
            scale={100}
          />
        </group>
      </group>
      <group
        position={[15.501, 0, -4.247]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[2.88, 1, 2.176]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.wall_thick_3_Material001_0003.geometry}
            material={materials['Material.457']}
            position={[-427.718, 0, 172.539]}
            rotation={[-Math.PI / 2, 0, -Math.PI]}
            scale={100}
          />
        </group>
      </group>
      <group position={[-29.807, 0, -66.737]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.wall_pillar_Material001_0047.geometry}
                material={materials['Material.223']}
                position={[-0.23, 1.226, 0]}
                scale={[1, 1, 1.942]}
              />
            </group>
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube364.geometry}
        material={materials['Material.072']}
        position={[-11.946, 1.909, -50.551]}
        scale={[0.15, 2.01, 5.754]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube111.geometry}
        material={materials['Material.224']}
        position={[-26.73, 1.909, -8.745]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.557]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube365.geometry}
        material={materials['Material.225']}
        position={[-38.861, 1.909, 11.954]}
        scale={[0.151, 2.01, 9.472]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube366.geometry}
        material={materials['Material.226']}
        position={[-39.712, 1.909, -36.813]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.164]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube367.geometry}
        material={materials['Material.227']}
        position={[-39.306, 1.909, -19.491]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 10.238]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube368.geometry}
        material={materials['Material.228']}
        position={[-83.979, 1.909, -39.28]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.737]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube369.geometry}
        material={materials['Material.229']}
        position={[-71.37, 1.901, -39.911]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.121]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube372.geometry}
        material={materials['Material.221']}
        position={[-130.883, 1.827, -82.767]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 2.107]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube373.geometry}
        material={materials['Material.221']}
        position={[-133.08, 1.827, -104.362]}
        rotation={[3.136, 0, 3.109]}
        scale={[0.15, 2.015, 19.313]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube374.geometry}
        material={materials['Material.221']}
        position={[-131.405, 1.911, -124.153]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.195, 2.01, 3.632]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane003.geometry}
        material={materials['Material.022']}
        position={[-46.804, 3.88, -60.777]}
        scale={114.921}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube375.geometry}
        material={materials['Material.233']}
        position={[-15.556, 8.354, -81.588]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 4.509, 3.826]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube067.geometry}
        material={materials['Material.234']}
        position={[-29.032, 13.008, -100.962]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane004.geometry}
        material={nodes.Plane004.material}
        position={[-17.825, 13.05, -99.266]}
        scale={-19.019}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube376.geometry}
        material={materials['Material.235']}
        position={[-29.032, 13.008, -85.462]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube377.geometry}
        material={materials['Material.236']}
        position={[-2.092, 13.008, -84.915]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube378.geometry}
        material={materials['Material.237']}
        position={[-2.092, 13.008, -90.399]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube379.geometry}
        material={materials['Material.238']}
        position={[-2.092, 13.008, -95.823]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube380.geometry}
        material={materials['Material.239']}
        position={[-2.092, 13.008, -101.058]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube381.geometry}
        material={materials['Material.240']}
        position={[-9.497, 13.008, -108.218]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube382.geometry}
        material={materials['Material.241']}
        position={[-13.83, 13.008, -108.218]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube384.geometry}
        material={materials['Material.243']}
        position={[-18.131, 13.008, -108.218]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube385.geometry}
        material={materials['Material.244']}
        position={[-22.46, 13.008, -108.218]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube383.geometry}
        material={materials['Material.112']}
        position={[3.501, 3.884, -114.622]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube386.geometry}
        material={materials['Material.179']}
        position={[3.501, 3.884, -120.436]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube387.geometry}
        material={materials['Material.232']}
        position={[-5.459, 3.884, -119.899]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube388.geometry}
        material={materials['Material.242']}
        position={[-19.381, 3.884, -119.899]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube389.geometry}
        material={materials['Material.245']}
        position={[-26.724, 3.884, -123.007]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube390.geometry}
        material={materials['Material.246']}
        position={[-34.629, 3.884, -123.048]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube391.geometry}
        material={materials['Material.247']}
        position={[-43.996, 3.884, -123.048]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube392.geometry}
        material={materials['Material.248']}
        position={[-57.221, 3.884, -123.048]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube393.geometry}
        material={materials['Material.249']}
        position={[-69.092, 3.884, -123.048]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube394.geometry}
        material={materials['Material.250']}
        position={[-74.075, 3.884, -115.339]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube395.geometry}
        material={materials['Material.251']}
        position={[-76.336, 3.884, -131.944]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube396.geometry}
        material={materials['Material.252']}
        position={[-87.72, 3.884, -131.944]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube397.geometry}
        material={materials['Material.253']}
        position={[-84.655, 3.884, -120.628]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube398.geometry}
        material={materials['Material.254']}
        position={[-77.698, 3.884, -106.662]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube399.geometry}
        material={materials['Material.255']}
        position={[-89.827, 3.884, -106.662]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube400.geometry}
        material={materials['Material.256']}
        position={[-94.401, 3.884, -119.686]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube401.geometry}
        material={materials['Material.257']}
        position={[-94.401, 3.884, -129.487]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube402.geometry}
        material={materials['Material.258']}
        position={[-103.148, 3.884, -129.254]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube403.geometry}
        material={materials['Material.259']}
        position={[-109.606, 3.884, -131.446]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube406.geometry}
        material={materials['Material.262']}
        position={[-125.096, 3.884, -131.446]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube407.geometry}
        material={materials['Material.263']}
        position={[-130.155, 3.884, -131.446]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube408.geometry}
        material={materials['Material.264']}
        position={[-135.155, 3.884, -131.446]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube409.geometry}
        material={materials['Material.265']}
        position={[-139.774, 3.884, -131.446]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube405.geometry}
        material={materials['Material.266']}
        position={[-111.661, 3.884, -123.978]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube410.geometry}
        material={materials['Material.267']}
        position={[-111.661, 3.884, -110.219]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube411.geometry}
        material={materials['Material.268']}
        position={[-118.353, 3.884, -110.219]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube412.geometry}
        material={materials['Material.269']}
        position={[-118.353, 3.884, -118.203]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube413.geometry}
        material={materials['Material.270']}
        position={[-104.775, 3.884, -118.203]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube414.geometry}
        material={materials['Material.271']}
        position={[-104.775, 3.884, -110.123]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube415.geometry}
        material={materials['Material.272']}
        position={[-104.775, 3.884, -102.241]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube416.geometry}
        material={materials['Material.273']}
        position={[-118.333, 3.884, -102.241]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube417.geometry}
        material={materials['Material.274']}
        position={[-99.287, 3.884, -102.241]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube418.geometry}
        material={materials['Material.275']}
        position={[-93.666, 3.884, -97.042]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube419.geometry}
        material={materials['Material.276']}
        position={[-85.858, 3.884, -91.098]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube420.geometry}
        material={materials['Material.277']}
        position={[-84.715, 3.884, -99.716]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube421.geometry}
        material={materials['Material.278']}
        position={[-70.137, 3.884, -96.925]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube422.geometry}
        material={materials['Material.279']}
        position={[-64.226, 3.884, -91.201]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube423.geometry}
        material={materials['Material.280']}
        position={[-41.614, 3.884, -106.238]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube424.geometry}
        material={materials['Material.281']}
        position={[-43.409, 3.884, -102.791]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube425.geometry}
        material={materials['Material.282']}
        position={[-12.249, 3.884, -125.747]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube426.geometry}
        material={materials['Material.283']}
        position={[-78.742, 3.884, -85.656]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube427.geometry}
        material={materials['Material.284']}
        position={[-66.411, 3.884, -78.272]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube428.geometry}
        material={materials['Material.285']}
        position={[-126.341, 3.603, -120.852]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube429.geometry}
        material={materials['Material.286']}
        position={[-132.049, 3.603, -120.852]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube430.geometry}
        material={materials['Material.287']}
        position={[-130.051, 3.603, -109.047]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube431.geometry}
        material={materials['Material.288']}
        position={[-126.268, 3.603, -109.047]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube432.geometry}
        material={materials['Material.289']}
        position={[-130.03, 3.603, -103.164]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube433.geometry}
        material={materials['Material.290']}
        position={[-128.092, 3.603, -97.295]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube434.geometry}
        material={materials['Material.291']}
        position={[-126.174, 3.603, -91.323]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.362, -0.081, -0.47]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube435.geometry}
        material={materials['Material.292']}
        position={[-122.642, 3.549, -74.149]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-2.629, -0.081, -3.519]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube439.geometry}
        material={materials['Material.296']}
        position={[-104.812, 3.898, -71.749]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube440.geometry}
        material={materials['Material.297']}
        position={[-104.812, 3.898, -79.333]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube441.geometry}
        material={materials['Material.298']}
        position={[-104.812, 3.898, -86.711]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube442.geometry}
        material={materials['Material.299']}
        position={[-95.766, 3.898, -86.711]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube443.geometry}
        material={materials['Material.300']}
        position={[-95.766, 3.898, -79.143]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube445.geometry}
        material={materials['Material.302']}
        position={[-94.036, 3.898, -71.682]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube444.geometry}
        material={materials['Material.303']}
        position={[-94.819, 3.898, -55.155]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube446.geometry}
        material={materials['Material.304']}
        position={[-118.704, 3.898, -82.272]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube447.geometry}
        material={materials['Material.305']}
        position={[-115.731, 2.185, -85.109]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube448.geometry}
        material={materials['Material.306']}
        position={[-113.837, 2.185, -85.109]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube449.geometry}
        material={materials['Material.307']}
        position={[-90.031, 3.898, -71.33]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube450.geometry}
        material={materials['Material.308']}
        position={[-90.031, 3.898, -82.824]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube451.geometry}
        material={materials['Material.309']}
        position={[-85.767, 1.455, -34.496]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube452.geometry}
        material={materials['Material.310']}
        position={[-85.767, 1.455, -36.198]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube453.geometry}
        material={materials['Material.311']}
        position={[-85.767, 1.455, -38.019]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube457.geometry}
        material={materials['Material.261']}
        position={[-76.587, 3.898, -50.823]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube458.geometry}
        material={materials['Material.301']}
        position={[-76.587, 3.898, -50.786]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube459.geometry}
        material={materials['Material.318']}
        position={[-76.444, 3.898, -57.445]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube460.geometry}
        material={materials['Material.319']}
        position={[-76.344, 3.898, -65.152]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube461.geometry}
        material={materials['Material.320']}
        position={[-76.262, 3.898, -72.553]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube462.geometry}
        material={materials['Material.321']}
        position={[-5.41, 3.869, -22.616]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube463.geometry}
        material={materials['Material.322']}
        position={[-10.94, 3.869, -30.931]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube464.geometry}
        material={materials['Material.323']}
        position={[-20.231, 3.869, -22.791]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube465.geometry}
        material={materials['Material.324']}
        position={[-21.028, 3.869, -38.206]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube466.geometry}
        material={materials['Material.325']}
        position={[-26.25, 3.869, -22.721]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube467.geometry}
        material={materials['Material.326']}
        position={[-13.581, 3.869, -16.289]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube468.geometry}
        material={materials['Material.327']}
        position={[9.165, 3.869, -14.94]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube472.geometry}
        material={materials['Material.331']}
        position={[6.329, 3.869, -47.914]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube473.geometry}
        material={materials['Material.332']}
        position={[3.268, 3.869, -61.333]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube474.geometry}
        material={materials['Material.333']}
        position={[3.268, 3.869, -68.866]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube477.geometry}
        material={materials['Material.336']}
        position={[3.268, 3.869, -75.829]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube479.geometry}
        material={materials['Material.338']}
        position={[3.268, 3.869, -83.186]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube480.geometry}
        material={materials['Material.339']}
        position={[8.124, 3.869, -96.255]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube481.geometry}
        material={materials['Material.340']}
        position={[-0.924, 3.869, -108.89]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube482.geometry}
        material={materials['Material.341']}
        position={[9.079, 3.869, -76.642]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube483.geometry}
        material={materials['Material.342']}
        position={[7.51, 3.869, -1.397]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube484.geometry}
        material={materials['Material.343']}
        position={[-8.948, 3.869, -1.397]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube485.geometry}
        material={materials['Material.344']}
        position={[-1.886, 3.869, -1.397]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube486.geometry}
        material={materials['Material.345']}
        position={[-9.118, 3.869, -9.236]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube487.geometry}
        material={materials['Material.346']}
        position={[-18.555, 3.869, -1.397]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube488.geometry}
        material={materials['Material.348']}
        position={[-26.035, 3.869, -10.516]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube489.geometry}
        material={materials['Material.349']}
        position={[-34.112, 3.869, -6.043]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube490.geometry}
        material={materials['Material.350']}
        position={[-33.913, 3.869, -19.365]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube491.geometry}
        material={materials['Material.351']}
        position={[-34.251, 3.869, -0.171]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube492.geometry}
        material={materials['Material.352']}
        position={[-47.257, 3.869, -16.579]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube493.geometry}
        material={materials['Material.353']}
        position={[-51.63, 3.869, -4.46]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube494.geometry}
        material={materials['Material.354']}
        position={[-44.732, 3.869, -4.46]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube495.geometry}
        material={materials['Material.355']}
        position={[-51.743, 3.869, 14.092]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube496.geometry}
        material={materials['Material.356']}
        position={[-41.501, 3.869, 17.459]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube497.geometry}
        material={materials['Material.357']}
        position={[-46.427, 3.869, -32.375]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube498.geometry}
        material={materials['Material.358']}
        position={[-50.675, 3.869, -32.375]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube499.geometry}
        material={materials['Material.359']}
        position={[-58.34, 3.869, -32.375]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube500.geometry}
        material={materials['Material.360']}
        position={[-65.883, 3.869, -32.008]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube501.geometry}
        material={materials['Material.361']}
        position={[-77.772, 3.869, -32.008]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube502.geometry}
        material={materials['Material.362']}
        position={[-82.721, 3.869, -32.008]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube503.geometry}
        material={materials['Material.363']}
        position={[-89.067, 3.869, -25.243]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube504.geometry}
        material={materials['Material.364']}
        position={[-101.818, 3.869, -18.151]}
        rotation={[-Math.PI, 1.561, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube505.geometry}
        material={materials['Material.365']}
        position={[-67.62, 3.869, -17.221]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube506.geometry}
        material={materials['Material.366']}
        position={[-3.409, 3.869, -47.914]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube507.geometry}
        material={materials['Material.367']}
        position={[-9.988, 3.869, -50.556]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube508.geometry}
        material={materials['Material.368']}
        position={[-15.699, 3.869, -50.556]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube509.geometry}
        material={materials['Material.369']}
        position={[-15.699, 3.869, -62.526]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube510.geometry}
        material={materials['Material.370']}
        position={[-22.431, 3.869, -74.859]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube511.geometry}
        material={materials['Material.371']}
        position={[-22.527, 3.869, -62.526]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube512.geometry}
        material={materials['Material.372']}
        position={[-36, 3.869, -62.091]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube513.geometry}
        material={materials['Material.373']}
        position={[-36, 3.869, -73.919]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube514.geometry}
        material={materials['Material.374']}
        position={[-30.342, 3.869, -33.498]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube515.geometry}
        material={materials['Material.375']}
        position={[-30.342, 3.869, -42.272]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube516.geometry}
        material={materials['Material.376']}
        position={[-43.29, 3.869, -44.524]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube517.geometry}
        material={materials['Material.378']}
        position={[-47.826, 3.869, -44.418]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube518.geometry}
        material={materials['Material.379']}
        position={[-52.492, 3.869, -44.418]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube519.geometry}
        material={materials['Material.380']}
        position={[-56.7, 3.869, -44.418]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube520.geometry}
        material={materials['Material.381']}
        position={[-61.617, 3.869, -44.418]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube521.geometry}
        material={materials['Material.382']}
        position={[-66.391, 3.869, -44.418]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube522.geometry}
        material={materials['Material.383']}
        position={[-66.391, 3.869, -52.069]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube523.geometry}
        material={materials['Material.384']}
        position={[-66.391, 3.869, -59.873]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube524.geometry}
        material={materials['Material.385']}
        position={[-66.391, 3.869, -71.404]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube525.geometry}
        material={materials['Material.386']}
        position={[-53.04, 3.869, -73.455]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube526.geometry}
        material={materials['Material.387']}
        position={[-45.17, 3.869, -73.455]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube527.geometry}
        material={materials['Material.388']}
        position={[-45.17, 3.869, -79.842]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube528.geometry}
        material={materials['Material.389']}
        position={[-26.21, 3.869, -57.177]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube529.geometry}
        material={materials['Material.390']}
        position={[-30.342, 3.869, -51.935]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube530.geometry}
        material={materials['Material.391']}
        position={[-55.863, 3.869, -50.738]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube531.geometry}
        material={materials['Material.392']}
        position={[-45.704, 3.869, -56.753]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube532.geometry}
        material={materials['Material.393']}
        position={[-45.704, 3.869, -64.061]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube533.geometry}
        material={materials['Material.394']}
        position={[-41.831, 3.869, -64.061]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube534.geometry}
        material={materials['Material.395']}
        position={[-41.831, 3.869, -51.798]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube535.geometry}
        material={materials['Material.396']}
        position={[-55.863, 3.869, -64.517]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube404.geometry}
        material={materials['Material.315']}
        position={[-0.578, 3.869, -29.422]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube536.geometry}
        material={materials['Material.316']}
        position={[-0.578, 3.869, -12.059]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube537.geometry}
        material={materials['Material.398']}
        position={[-9.237, 1.909, -44.154]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 6.561]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube538.geometry}
        material={materials['Material.399']}
        position={[-23.429, 1.909, -43.829]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.582]}
      />
      <group position={[1.286, 0, -51.135]} rotation={[Math.PI / 2, 0, 0]} scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0007.geometry}
              material={materials['Material.400']}
              position={[4.466, -13.428, 0]}
              scale={[0.709, 2.73, 2.001]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube539.geometry}
        material={materials['Material.401']}
        position={[-15.206, 1.911, -19.053]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 12.722]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube540.geometry}
        material={materials['Material.402']}
        position={[-54.34, 1.909, -8.893]}
        scale={[0.151, 2.01, 31.117]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube541.geometry}
        material={materials['Material.403']}
        position={[-55.081, 1.909, -39.929]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 15.331]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube542.geometry}
        material={materials['Material.404']}
        position={[-56.528, 1.909, -9.413]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 13.154]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube543.geometry}
        material={materials['Material.405']}
        position={[-46.459, 1.909, 21.138]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 7.914]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube544.geometry}
        material={materials['Material.406']}
        position={[-48.966, 1.909, 17.436]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 5.269]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube545.geometry}
        material={materials['Material.407']}
        position={[-42.865, 1.909, 12.004]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.986]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube546.geometry}
        material={materials['Material.408']}
        position={[-52.415, 1.909, 5.968]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.986]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube547.geometry}
        material={materials['Material.409']}
        position={[-40.238, 1.909, -9.304]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.182]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube548.geometry}
        material={materials['Material.410']}
        position={[-59.953, 1.909, -36.446]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.368]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube549.geometry}
        material={materials['Material.411']}
        position={[-59.953, 1.909, -26.984]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.164]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube550.geometry}
        material={materials['Material.412']}
        position={[-64.535, 1.909, -26.9]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.164]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube551.geometry}
        material={materials['Material.413']}
        position={[-64.535, 1.909, -36.872]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.164]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube552.geometry}
        material={materials['Material.414']}
        position={[-66.632, 1.909, -36.678]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.259]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube553.geometry}
        material={materials['Material.415']}
        position={[-66.632, 1.909, -26.862]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.164]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube554.geometry}
        material={materials['Material.416']}
        position={[-69.895, 1.909, -19.873]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 10.89]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube555.geometry}
        material={materials['Material.417']}
        position={[-85.554, 1.909, -31.672]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 7.714]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube556.geometry}
        material={materials['Material.418']}
        position={[-76.251, 1.909, -23.845]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 9.958]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube557.geometry}
        material={materials['Material.419']}
        position={[-53.635, 1.909, -23.845]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 10.95]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube558.geometry}
        material={materials['Material.420']}
        position={[-73.722, 1.909, -42.079]}
        rotation={[Math.PI, -1.568, Math.PI]}
        scale={[0.151, 2.01, 1.513]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube559.geometry}
        material={materials['Material.347']}
        position={[-70.497, 1.909, -36.516]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.469]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube560.geometry}
        material={materials['Material.377']}
        position={[-64.176, 1.909, -12.585]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 2.956]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube561.geometry}
        material={materials['Material.397']}
        position={[-59.598, 1.909, -20.623]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 5.292]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube562.geometry}
        material={materials['Material.421']}
        position={[-60.119, 1.909, -15.572]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.246]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube563.geometry}
        material={materials['Material.422']}
        position={[-52.565, 1.909, -12.962]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.768]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube564.geometry}
        material={materials['Material.423']}
        position={[-52.565, 1.91, -14.618]}
        scale={[0.151, 2.01, 1.587]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube565.geometry}
        material={materials['Material.424']}
        position={[-44.913, 1.91, 2.189]}
        scale={[0.151, 2.01, 3.906]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube566.geometry}
        material={materials['Material.425']}
        position={[-42.498, 1.91, 9.118]}
        scale={[0.151, 2.01, 2.923]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube567.geometry}
        material={materials['Material.426']}
        position={[-46.579, 1.91, 9.118]}
        scale={[0.151, 2.01, 2.923]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube568.geometry}
        material={materials['Material.427']}
        position={[-52.415, 1.909, 1.264]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.986]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube569.geometry}
        material={materials['Material.428']}
        position={[-79.744, 1.909, -27.492]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 3.164]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube570.geometry}
        material={materials['Material.429']}
        position={[-73.084, 1.909, -32.538]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.604]}
      />
      <group position={[-95, 0, -53]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 5, 0]} scale={[15, 5, 15]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4003.geometry}
              material={materials['Material.430']}
              position={[-0.914, -0.649, 1.222]}
              rotation={[-Math.PI, 0.693, -Math.PI]}
              scale={[0.411, 0.355, 0.697]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube190.geometry}
        material={materials['Material.086']}
        position={[-109.004, 2.105, -60.829]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube313.geometry}
        material={materials['Material.086']}
        position={[-109.004, 2.105, -53.94]}
        rotation={[Math.PI, -1.535, Math.PI]}
        scale={[2.024, 2.01, 1.701]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column102.geometry}
        material={materials['Column_material.153']}
        position={[-122.625, 0.305, -48.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.864, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column105.geometry}
        material={materials['Column_material.153']}
        position={[-122.625, 0.955, -48.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.864, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column106.geometry}
        material={materials['Column_material.153']}
        position={[-122.625, 1.577, -48.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.864, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column107.geometry}
        material={materials['Column_material.153']}
        position={[-122.625, 2.203, -48.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.864, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column108.geometry}
        material={materials['Column_material.153']}
        position={[-122.625, 2.858, -48.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.864, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column109.geometry}
        material={materials['Column_material.153']}
        position={[-122.625, 3.453, -48.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.864, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column110.geometry}
        material={materials['Column_material.153']}
        position={[-119.461, 3.453, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column111.geometry}
        material={materials['Column_material.153']}
        position={[-119.461, 2.858, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column112.geometry}
        material={materials['Column_material.153']}
        position={[-119.461, 2.203, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column113.geometry}
        material={materials['Column_material.153']}
        position={[-119.461, 1.577, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column114.geometry}
        material={materials['Column_material.153']}
        position={[-119.461, 0.955, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column115.geometry}
        material={materials['Column_material.153']}
        position={[-119.461, 0.305, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column116.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 0.305, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column117.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 0.955, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column118.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 1.577, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column119.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 2.203, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column120.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 2.858, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column121.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 3.453, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column122.geometry}
        material={materials['Column_material.130']}
        position={[-114.921, 3.453, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column123.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 2.858, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column124.geometry}
        material={materials['Column_material.132']}
        position={[-114.921, 2.203, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column125.geometry}
        material={materials['Column_material.133']}
        position={[-114.921, 1.577, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column126.geometry}
        material={materials['Column_material.134']}
        position={[-114.921, 0.955, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column127.geometry}
        material={materials['Column_material.135']}
        position={[-114.921, 0.305, -48.956]}
        rotation={[Math.PI, -1.519, Math.PI / 2]}
        scale={[2.202, 1.867, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column128.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 3.453, -45.23]}
        rotation={[Math.PI, -0.921, Math.PI / 2]}
        scale={[2.202, 7.317, 2.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column129.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 2.858, -45.23]}
        rotation={[Math.PI, -0.921, Math.PI / 2]}
        scale={[2.202, 7.317, 2.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column130.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 2.203, -45.23]}
        rotation={[Math.PI, -0.921, Math.PI / 2]}
        scale={[2.202, 7.317, 2.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column131.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 1.577, -45.23]}
        rotation={[Math.PI, -0.921, Math.PI / 2]}
        scale={[2.202, 7.317, 2.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column132.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 0.955, -45.23]}
        rotation={[Math.PI, -0.921, Math.PI / 2]}
        scale={[2.202, 7.317, 2.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column133.geometry}
        material={materials['Column_material.153']}
        position={[-114.921, 0.305, -45.23]}
        rotation={[Math.PI, -0.921, Math.PI / 2]}
        scale={[2.202, 7.317, 2.419]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube370.geometry}
        material={materials['Material.085']}
        position={[-128.832, 1.827, -32.545]}
        rotation={[3.136, 0.037, 3.11]}
        scale={[0.15, 2.01, 7.957]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube371.geometry}
        material={materials['Material.044']}
        position={[-125.755, 1.894, -25.698]}
        rotation={[-0.724, 1.522, 0.718]}
        scale={[0.24, 2.014, 3.455]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube436.geometry}
        material={materials['Material.260']}
        position={[-120.919, 2.2, -20.066]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.247, 3.373]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column134.geometry}
        material={materials['Column_material.153']}
        position={[-127.237, 3.453, -22.528]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 5.049, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column135.geometry}
        material={materials['Column_material.153']}
        position={[-127.237, 2.858, -22.528]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 5.049, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column136.geometry}
        material={materials['Column_material.153']}
        position={[-127.237, 2.203, -22.528]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 5.049, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column137.geometry}
        material={materials['Column_material.153']}
        position={[-127.237, 1.577, -22.528]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 5.049, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column138.geometry}
        material={materials['Column_material.153']}
        position={[-127.237, 0.955, -22.528]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 5.049, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column139.geometry}
        material={materials['Column_material.153']}
        position={[-127.237, 0.305, -22.528]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 5.049, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column140.geometry}
        material={materials['Column_material.153']}
        position={[-129.218, 0.305, -25.63]}
        rotation={[0, -1.531, -Math.PI / 2]}
        scale={[2.202, 3.712, 2.375]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column141.geometry}
        material={materials['Column_material.153']}
        position={[-129.218, 0.955, -25.63]}
        rotation={[0, -1.531, -Math.PI / 2]}
        scale={[2.202, 3.712, 2.375]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column142.geometry}
        material={materials['Column_material.153']}
        position={[-129.218, 1.577, -25.63]}
        rotation={[0, -1.531, -Math.PI / 2]}
        scale={[2.202, 3.712, 2.375]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column143.geometry}
        material={materials['Column_material.153']}
        position={[-129.218, 2.203, -25.63]}
        rotation={[0, -1.531, -Math.PI / 2]}
        scale={[2.202, 3.712, 2.375]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column144.geometry}
        material={materials['Column_material.153']}
        position={[-129.218, 2.858, -25.63]}
        rotation={[0, -1.531, -Math.PI / 2]}
        scale={[2.202, 3.712, 2.375]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column145.geometry}
        material={materials['Column_material.153']}
        position={[-129.218, 3.453, -25.63]}
        rotation={[0, -1.531, -Math.PI / 2]}
        scale={[2.202, 3.712, 2.375]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube437.geometry}
        material={materials['Material.048']}
        position={[-112.2, 1.38, -20.478]}
        rotation={[0, 0.016, 0]}
        scale={[0.15, 2.19, 3.389]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube438.geometry}
        material={materials['Material.101']}
        position={[-106.563, 1.652, -21.022]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 1.816, 1.893]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube454.geometry}
        material={materials['Material.207']}
        position={[-99.328, 1.516, -51.565]}
        scale={[0.15, 2.01, 1.414]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube455.geometry}
        material={materials['Material.207']}
        position={[-96.54, 1.516, -49.095]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.414]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube456.geometry}
        material={materials['Material.207']}
        position={[-97.29, 1.516, -51.84]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 2.063]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube571.geometry}
        material={materials['Material.230']}
        position={[-111.679, 3.553, -31.034]}
        rotation={[-Math.PI, 0.682, -Math.PI]}
        scale={[-2.629, -0.081, -3.519]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube572.geometry}
        material={materials.hosp}
        position={[-47.565, 1.909, -70.805]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 9.406]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube573.geometry}
        material={materials.hosp}
        position={[-63.056, 1.909, -70.987]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 3.399]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube574.geometry}
        material={materials.hosp}
        position={[-54.295, 1.909, -66.932]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 10.014]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube575.geometry}
        material={materials.hosp}
        position={[-56.765, 1.909, -54.081]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 7.208]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube576.geometry}
        material={materials.hosp}
        position={[-52.271, 1.909, -47.844]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 13.636]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube577.geometry}
        material={materials.hosp}
        position={[-54.951, 1.909, -57.256]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 6.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube578.geometry}
        material={materials.hosp}
        position={[-61.215, 1.909, -60.007]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 2.68]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube579.geometry}
        material={materials.hosp}
        position={[-40.62, 1.909, -68.278]}
        scale={[0.151, 2.01, 4.67]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube580.geometry}
        material={materials.hosp}
        position={[-40.62, 1.909, -52.395]}
        scale={[0.151, 2.01, 7.536]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube581.geometry}
        material={materials.hosp}
        position={[-44.468, 1.909, -60.064]}
        scale={[0.151, 2.01, 7.101]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube582.geometry}
        material={materials.hosp}
        position={[-48.284, 1.909, -51.08]}
        scale={[0.151, 2.01, 3.385]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube583.geometry}
        material={materials.hosp}
        position={[-48.284, 1.909, -59.146]}
        scale={[0.151, 2.01, 3.385]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube584.geometry}
        material={materials.hosp}
        position={[-63.97, 1.909, -60.165]}
        rotation={[0, 0.014, 0]}
        scale={[0.151, 2.01, 13.496]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column146.geometry}
        material={materials['Column_material.102']}
        position={[-89.801, 0.023, -76.659]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top080.geometry}
          material={materials['Column_rect.080']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column147.geometry}
        material={materials['Column_material.106']}
        position={[-89.801, 0.023, -64.052]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top081.geometry}
          material={materials['Column_rect.081']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column148.geometry}
        material={materials['Column_material.124']}
        position={[-89.801, 0.023, -52.95]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top082.geometry}
          material={materials['Column_rect.082']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column149.geometry}
        material={materials['Column_material.127']}
        position={[-89.801, 0.023, -37.542]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top083.geometry}
          material={materials['Column_rect.085']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column150.geometry}
        material={materials['Column_material.127']}
        position={[-95.45, 0.023, -30.924]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top084.geometry}
          material={materials['Column_rect.085']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column151.geometry}
        material={materials['Column_material.127']}
        position={[-101.669, 0.023, -24.001]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top085.geometry}
          material={materials['Column_rect.085']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column152.geometry}
        material={materials['Column_material.127']}
        position={[-90.1, 0.023, -47.172]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top086.geometry}
          material={materials['Column_rect.086']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube585.geometry}
        material={materials['Material.437']}
        position={[-87.771, 3.869, -38.38]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube586.geometry}
        material={materials['Material.438']}
        position={[-98.633, 3.869, -24.936]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube587.geometry}
        material={materials['Material.439']}
        position={[-90.031, 3.898, -58.245]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube588.geometry}
        material={materials['Material.440']}
        position={[-90.031, 3.898, -49.364]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube589.geometry}
        material={materials['Material.441']}
        position={[-85.188, 3.898, -54.336]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube590.geometry}
        material={materials['Material.442']}
        position={[-85.188, 3.898, -65.029]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube591.geometry}
        material={materials['Material.443']}
        position={[-85.188, 3.898, -71.343]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.247, -0.081, -0.967]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube592.geometry}
        material={materials['Material.450']}
        position={[11.807, 1.911, -46.649]}
        scale={[0.15, 2.01, 49.258]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube159.geometry}
        material={materials['Material.455']}
        position={[1.309, 1.911, -25.362]}
        scale={[0.15, 2.01, 11.484]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube593.geometry}
        material={materials['Material.458']}
        position={[-6.173, 1.911, -5.305]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.15, 2.01, 4.459]}
      />
      <group position={[4.926, 0, -51.135]} rotation={[Math.PI / 2, 0, 0]} scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0001.geometry}
              material={materials['Material.459']}
              position={[4.466, -13.457, 0]}
              scale={[0.709, 1.792, 2.001]}
            />
          </group>
        </group>
      </group>
      <group position={[4.926, 0, -39.807]} rotation={[Math.PI / 2, 0, 0]} scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0006.geometry}
              material={materials['Material.460']}
              position={[4.466, -13.702, 0]}
              scale={[0.709, 1.792, 2.001]}
            />
          </group>
        </group>
      </group>
      <group
        position={[10.243, 0, -51.135]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0008.geometry}
              material={materials['Material.461']}
              position={[4.466, -12.935, 0]}
              scale={[0.709, 1.189, 2.001]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube333.geometry}
        material={materials['Material.462']}
        position={[-18.602, 1.909, -40.432]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 3.034]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube594.geometry}
        material={materials['Material.463']}
        position={[-12.08, 1.909, -36.633]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.987]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube595.geometry}
        material={materials['Material.464']}
        position={[-12.08, 1.909, -34.641]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 4.947]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube596.geometry}
        material={materials['Material.465']}
        position={[-18.574, 1.909, -26.55]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.151, 2.01, 1.307]}
      />
      <group position={[4.926, 0, -39.807]} rotation={[Math.PI / 2, 0, 0]} scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0009.geometry}
              material={materials['Material.466']}
              position={[3.955, -17.484, 0]}
              scale={[0.709, 1.925, 2.001]}
            />
          </group>
        </group>
      </group>
      <group position={[4.926, 0, -39.807]} rotation={[Math.PI / 2, 0, 0]} scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0010.geometry}
              material={materials['Material.467']}
              position={[2.609, -17.484, 0]}
              scale={[0.709, 1.925, 2.001]}
            />
          </group>
        </group>
      </group>
      <group
        position={[22.111, 0, -51.135]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0011.geometry}
              material={materials['Material.469']}
              position={[4.466, -18.488, 0]}
              scale={[0.709, 1.867, 2.001]}
            />
          </group>
        </group>
      </group>
      <group
        position={[12.047, 0, -51.135]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0012.geometry}
              material={materials['Material.470']}
              position={[4.466, -14.576, 0]}
              scale={[0.709, 0.424, 2.001]}
            />
          </group>
        </group>
      </group>
      <group
        position={[15.741, 0, -51.135]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[-3.751, -1, -1]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[333.755, 0, 95.557]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_3_Material001_0013.geometry}
              material={materials['Material.471']}
              position={[4.466, -17.12, 0]}
              scale={[0.709, 0.594, 2.001]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube113.geometry}
        material={materials['Material.478']}
        position={[6.329, 3.869, -41.772]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube469.geometry}
        material={materials['Material.479']}
        position={[6.329, 3.869, -35.462]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube470.geometry}
        material={materials['Material.480']}
        position={[6.329, 3.869, -29.357]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube471.geometry}
        material={materials['Material.481']}
        position={[6.329, 3.869, -23.036]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube475.geometry}
        material={materials['Material.482']}
        position={[9.748, 3.869, -59.399]}
        rotation={[-Math.PI, 0.033, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube171.geometry}
        material={materials['Material.088']}
        position={[-125.574, 3.869, -28.904]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube194.geometry}
        material={materials['Material.089']}
        position={[-122.276, 3.869, -40.019]}
        rotation={[-Math.PI, 1.542, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube154.geometry}
        material={materials['Material.001']}
        position={[-125.282, 1.827, -104.362]}
        rotation={[3.136, 0, 3.109]}
        scale={[0.15, 2.015, 19.313]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube237.geometry}
        material={materials['Material.002']}
        position={[-127.858, 1.827, -85.921]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 2.662]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube281.geometry}
        material={materials['Material.004']}
        position={[-113.731, 1.827, -65.882]}
        rotation={[0, 0.007, 0]}
        scale={[0.15, 2.01, 14.341]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube317.geometry}
        material={materials['Material.005']}
        position={[-131.663, 1.827, -65.882]}
        rotation={[0, 0.007, 0]}
        scale={[0.15, 2.01, 14.341]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube476.geometry}
        material={materials['Material.010']}
        position={[-116.66, 1.894, -51.785]}
        rotation={[-0.724, 1.522, 0.718]}
        scale={[0.241, 2.016, 2.94]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube478.geometry}
        material={materials['Material.016']}
        position={[-120.283, 1.827, -79.989]}
        rotation={[1.603, -1.565, 1.571]}
        scale={[0.15, 2.01, 6.564]}
      />
      <group position={[0.035, 0, -19.486]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12002.geometry}
              material={materials['Chairs_A.001']}
              position={[0, 0, -0.162]}
              rotation={[-0.805, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.616, 0, -19.486]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12003.geometry}
              material={materials['Chairs_A.002']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[0.917, 0.021, -19.163]} rotation={[-Math.PI / 2, -0.248, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12004.geometry}
              material={materials['Chairs_A.003']}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.552, 1.104, -19.392]} rotation={[Math.PI / 2, 1.526, -Math.PI]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12005.geometry}
              material={materials['Chairs_A.004']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[0.302, 1.043, -19.392]} rotation={[1.318, -0.807, -2.263]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12006.geometry}
              material={materials['Chairs_A.005']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[0.308, 1.104, -19.248]} rotation={[-0.023, -0.058, -1.572]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12007.geometry}
              material={materials['Chairs_A.006']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[0.308, 1.104, -18.624]} rotation={[-0.023, -0.058, -1.572]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12008.geometry}
              material={materials['Chairs_A.007']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.874, 0, -38.293]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19001.geometry}
              material={materials['Trims_Painted_A.001']}
              position={[0.378, -1.118, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.143, -0.258, -38.293]} rotation={[-Math.PI / 2, -0.394, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19003.geometry}
              material={materials['Trims_Painted_A.003']}
              position={[0.378, -1.118, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.381, 0, -37.763]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[1, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_10002.geometry}
              material={materials['Chairs_A.008']}
              position={[-1.104, 0.293, 0.242]}
              rotation={[-1.585, 0, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.976, 0, -37.763]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[1, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_10003.geometry}
              material={materials['Chairs_A.009']}
              position={[-0.711, 0.124, -0.293]}
              rotation={[3.067, -0.158, 1.945]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube598.geometry}
        material={materials['Material.017']}
        position={[-11.946, 1.909, -77.847]}
        scale={[0.15, 2.01, 3.444]}
      />
      <group position={[4.32, 0, -127.997]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-18.719, -1.463, 379.495]}
              rotation={[-Math.PI / 2, 0, 0]}
              scale={[85.331, 85.331, 95.766]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.endtable1_top__low003_endtable1_0001.geometry}
                material={materials['endtable1.001']}
                position={[-5.384, -6.366, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[4.986, 0, -127.997]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-18.719, -1.463, 379.495]}
              rotation={[-Math.PI / 2, 0, 0]}
              scale={[85.331, 85.331, 95.766]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.endtable1_top__low003_endtable1_0002.geometry}
                material={materials['endtable1.002']}
                position={[-5.384, -6.366, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-0.02, 0, -121.75]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[39.627, 158.43, 384.005]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.lampscrew_low001_lamp01_0001.geometry}
              material={materials['lamp01.001']}
              position={[-0.187, 0.864, 0.05]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.386, 0, -121.542]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[192.903, 36.058, 402.711]}
            rotation={[-Math.PI / 2, 0, -0.776]}
            scale={24.899}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.chairlegs_low001_chair1_0001.geometry}
              material={materials['chair1.001']}
              position={[-6.955, -5.077, 0]}
              rotation={[0, 0, 2.931]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.164, 0, -117.229]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19004.geometry}
              material={materials['Trims_Painted_A.004']}
              position={[0.924, -1.122, 0.659]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.937, 0, -117.229]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19005.geometry}
              material={materials['Trims_Painted_A.005']}
              position={[-0.871, -1.122, 0.518]}
              rotation={[0, 1.567, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.937, 0, -118.529]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19006.geometry}
              material={materials['Trims_Painted_A.006']}
              position={[-0.398, -1.122, 0.518]}
              rotation={[-Math.PI, 1.565, -Math.PI]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.937, 0, -119.837]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19007.geometry}
              material={materials['Trims_Painted_A.007']}
              position={[-0.392, -1.122, 0.57]}
              rotation={[-Math.PI, 1.565, -Math.PI]}
            />
          </group>
        </group>
      </group>
      <group position={[-9.869, 3.862, -123.224]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0, 0.001]}>
          <group position={[0, -0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[173.768, 64.025, -163.209]} rotation={[-Math.PI / 2, 0, 1.725]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_34002.geometry}
                material={materials['lambert15.001']}
                position={[-1365.375, -410.754, -387.741]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.869, 3.862, -124.29]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, -0.001, 0]}>
              <group position={[0, 0, -0.001]}>
                <group position={[173.768, 64.025, -163.21]} rotation={[-Math.PI / 2, 0, 1.725]}>
                  <group position={[0, 0, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_34003.geometry}
                      material={materials['lambert15.002']}
                      position={[-1366.362, -417.122, -386.839]}
                    />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.869, 3.862, -125.559]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0, 0.001]}>
          <group position={[0, -0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[173.768, 64.025, -163.209]} rotation={[-Math.PI / 2, 0, 1.725]}>
              <group position={[0, 0, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_34004.geometry}
                  material={materials['lambert15.003']}
                  position={[-1367.18, -623.777, -424.918]}
                  rotation={[-Math.PI / 2, 0.827, Math.PI / 2]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.869, 3.862, -126.481]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, -0.001, 0]}>
              <group position={[0, 0, -0.001]}>
                <group position={[173.768, 64.025, -163.209]} rotation={[-Math.PI / 2, 0, 1.725]}>
                  <group position={[-0.001, 0, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_34005.geometry}
                      material={materials['lambert15.004']}
                      position={[-1367.181, -623.777, -424.918]}
                      rotation={[Math.PI / 2, -0.194, -Math.PI / 2]}
                    />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.869, 3.862, -127.315]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0, 0.001]}>
          <group position={[0, -0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[173.768, 64.025, -163.208]} rotation={[-Math.PI / 2, 0, 1.725]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_34006.geometry}
                material={materials['lambert15.005']}
                position={[-1367.179, -623.777, -424.918]}
                rotation={[Math.PI / 2, -0.194, -Math.PI / 2]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.869, 3.862, -125.693]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, 0, -0.001]}>
              <group position={[173.768, 64.025, -163.21]} rotation={[-Math.PI / 2, 0, 1.725]}>
                <group position={[-0.001, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Object_34007.geometry}
                    material={materials['lambert15.006']}
                    position={[-1372.961, -488.018, -388.216]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-17.494, 3.862, -97.113]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, 0, -0.001]}>
              <group position={[136.863, 50.917, -3.399]} rotation={[0, 0.254, 0]}>
                <group position={[0, 0, -0.001]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Object_17003.geometry}
                    material={materials['lambert16.001']}
                    position={[300.259, -263.92, -1498.632]}
                    rotation={[0.034, -0.002, -0.13]}
                  />
                </group>
              </group>
              <group position={[144.174, 41.14, 116.911]} rotation={[-Math.PI / 2, 0, 0.815]}>
                <group position={[0, 0.001, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Object_11003.geometry}
                    material={materials['material.002']}
                    position={[1640.739, 1436.843, -312.734]}
                    rotation={[1.689, -1.024, 0.008]}
                  />
                </group>
              </group>
              <group position={[166.619, 21.069, 12.044]} rotation={[-Math.PI / 2, 0, -0.988]}>
                <group position={[-0.001, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Object_8005.geometry}
                    material={materials['lambert1.001']}
                    position={[-1512.658, 904.75, -273.733]}
                    rotation={[1.528, 1.187, -1.581]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-17.494, 3.862, -99.804]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, -0.001, 0]}>
              <group position={[0, 0, -0.001]}>
                <group position={[166.619, 21.069, 12.043]} rotation={[-Math.PI / 2, 0, -0.988]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Object_8006.geometry}
                    material={materials['lambert1.002']}
                    position={[-1540.255, 1026.192, -282.627]}
                    rotation={[-0.077, -0.003, 0.885]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-14.326, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1058.465, -1935.611, 637.468]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube484_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1145.437, -2011.583, 534.78]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube481_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1014.244, -2010.421, 511.755]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube479_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1113.121, -2010.421, 539.971]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube478_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1047.605, -2010.421, 539.521]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube477_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1082.077, -2010.421, 539.771]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube476_Material002_0001.geometry}
                material={materials['Material.036']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1130.274, -1965.781, 457.661]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder292_Material006_0001.geometry}
                material={materials['Material.028']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1128.482, -1977.951, 628.471]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder290_Material006_0001.geometry}
                material={materials['Material.028']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0001.geometry}
              material={materials['Material.036']}
              position={[-1058.628, -2017.252, 615.117]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube482_Material002_0001.geometry}
              material={materials['Material.036']}
              position={[-1059.721, -2017.252, 464.908]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}
            />
          </group>
        </group>
      </group>
      <group position={[-12.363, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1082.077, -2010.421, 539.771]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube476_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1047.605, -2010.421, 539.521]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube477_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1113.121, -2010.421, 539.971]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube478_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1014.244, -2010.421, 511.755]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube479_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1145.437, -2011.583, 534.78]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube481_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1058.465, -1935.611, 637.468]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube484_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0002.geometry}
                material={materials['Material.038']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
            <group
              position={[-1128.482, -1977.951, 628.471]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder290_Material006_0002.geometry}
                material={materials['Material.037']}
                position={[0.01, 1.361, 0]}
              />
            </group>
            <group
              position={[-1130.275, -1965.781, 457.661]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder292_Material006_0002.geometry}
                material={materials['Material.037']}
                position={[0.009, 1.303, 0]}
              />
            </group>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0002.geometry}
              material={materials['Material.038']}
              position={[-1058.628, -2017.252, 615.117]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}
            />
          </group>
        </group>
      </group>
      <group position={[-11.949, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0003.geometry}
                material={materials['Material.040']}
                position={[0.002, 0.335, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-11.949, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0004.geometry}
                material={materials['Material.041']}
                position={[-0.001, -0.073, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-11.557, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0005.geometry}
                material={materials['Material.042']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-11.557, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0006.geometry}
                material={materials['Material.043']}
                position={[0.002, 0.335, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-11.164, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0007.geometry}
                material={materials['Material.049']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.764, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0008.geometry}
                material={materials['Material.077']}
                position={[0.008, 1.101, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.764, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0009.geometry}
                material={materials['Material.105']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.408, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0010.geometry}
                material={materials['Material.119']}
                position={[0.008, 1.101, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.358, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1058.628, -2017.252, 615.117]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube483_Material002_0003.geometry}
                material={materials['Material.122']}
                scale={[1, 2.044, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.764, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0011.geometry}
                material={materials['Material.161']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.358, 20.305, -99.565]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1058.628, -2017.252, 615.117]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube483_Material002_0004.geometry}
                material={materials['Material.162']}
                scale={[1, 2.044, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.18, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1130.275, -1965.781, 457.661]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder292_Material006_0003.geometry}
                material={materials['Material.164']}
                position={[0.009, 1.303, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.046, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1128.482, -1977.951, 628.471]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder290_Material006_0003.geometry}
                material={materials['Material.220']}
                position={[0.01, 1.361, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.094, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0003.geometry}
                material={materials['Material.317']}
                position={[-2.248, 1.661, 0.361]}
                rotation={[0, 0, -1.617]}
                scale={[1.001, 2.564, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.094, 20.305, -96.105]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0004.geometry}
              material={materials['Material.328']}
              position={[-0.001, -0.073, 0]}
              scale={[1, 1.784, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-9.985, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0012.geometry}
                material={materials['Material.329']}
                position={[0.791, 1.096, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.985, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0013.geometry}
              material={materials['Material.330']}
              position={[0.791, 1.096, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-9.609, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0014.geometry}
              material={materials['Material.334']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-9.609, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0015.geometry}
                material={materials['Material.335']}
                position={[0.791, 1.096, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.609, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0016.geometry}
                material={materials['Material.337']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.609, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0017.geometry}
              material={materials['Material.444']}
              position={[0.791, 1.096, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-9.207, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0018.geometry}
                material={materials['Material.445']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-9.207, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0019.geometry}
              material={materials['Material.446']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-8.782, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0020.geometry}
              material={materials['Material.447']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-8.782, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0021.geometry}
                material={materials['Material.448']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-8.341, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0022.geometry}
                material={materials['Material.449']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-8.341, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0023.geometry}
              material={materials['Material.451']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-7.925, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0024.geometry}
              material={materials['Material.452']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-7.925, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0025.geometry}
                material={materials['Material.453']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-7.524, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0026.geometry}
                material={materials['Material.454']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-7.524, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0027.geometry}
              material={materials['Material.456']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-7.109, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0028.geometry}
              material={materials['Material.472']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-7.109, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0029.geometry}
                material={materials['Material.473']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-6.669, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0030.geometry}
                material={materials['Material.475']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-6.669, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0031.geometry}
              material={materials['Material.476']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-6.272, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0032.geometry}
              material={materials['Material.483']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-6.272, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0033.geometry}
                material={materials['Material.484']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-5.85, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0034.geometry}
                material={materials['Material.485']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-5.85, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0035.geometry}
              material={materials['Material.486']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-5.444, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0036.geometry}
              material={materials['Material.487']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-5.444, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0037.geometry}
                material={materials['Material.488']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-5.022, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0038.geometry}
                material={materials['Material.489']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-5.022, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0039.geometry}
              material={materials['Material.490']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-4.586, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0040.geometry}
              material={materials['Material.491']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-4.586, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0041.geometry}
                material={materials['Material.492']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-4.13, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0042.geometry}
                material={materials['Material.493']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-4.13, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0043.geometry}
              material={materials['Material.494']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-3.69, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0044.geometry}
              material={materials['Material.495']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-3.69, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0045.geometry}
                material={materials['Material.496']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-3.015, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0046.geometry}
                material={materials['Material.497']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-3.015, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0047.geometry}
              material={materials['Material.498']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.585, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0048.geometry}
              material={materials['Material.499']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.585, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0049.geometry}
                material={materials['Material.500']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-2.149, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0050.geometry}
                material={materials['Material.501']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-2.149, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0051.geometry}
              material={materials['Material.502']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.709, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0052.geometry}
              material={materials['Material.503']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.709, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0053.geometry}
                material={materials['Material.504']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-1.271, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0054.geometry}
                material={materials['Material.505']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-1.271, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0055.geometry}
              material={materials['Material.506']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.271, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0056.geometry}
              material={materials['Material.507']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.271, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0057.geometry}
                material={materials['Material.508']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-0.808, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0058.geometry}
                material={materials['Material.509']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-0.808, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0059.geometry}
              material={materials['Material.510']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.381, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0060.geometry}
              material={materials['Material.511']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-0.381, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0061.geometry}
                material={materials['Material.512']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[0.029, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-975.124, -2012.551, 538.972]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0062.geometry}
                material={materials['Material.513']}
                position={[0.794, 1.501, 0]}
                scale={[2.504, 1, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[0.029, 20.305, -102.005]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0063.geometry}
              material={materials['Material.514']}
              position={[0.794, 1.501, 0]}
              scale={[2.504, 1, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-9.046, 20.305, -95.984]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0004.geometry}
              material={materials['Material.515']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[1.954, 20.305, -95.984]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0005.geometry}
              material={materials['Material.516']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.685, 20.305, -95.984]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0006.geometry}
              material={materials['Material.517']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-5.504, 20.305, -95.984]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0007.geometry}
              material={materials['Material.518']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-8.674, 20.305, -104.511]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0008.geometry}
              material={materials['Material.519']}
              position={[0.006, 0.805, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-5.438, 20.305, -104.511]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0009.geometry}
              material={materials['Material.520']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-1.787, 20.305, -104.511]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0010.geometry}
              material={materials['Material.521']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[1.835, 20.305, -104.511]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0011.geometry}
              material={materials['Material.522']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[1.835, 20.305, -100.113]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0012.geometry}
              material={materials['Material.523']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.094, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0005.geometry}
                material={materials['Material.524']}
                position={[-0.001, -0.073, 0]}
                scale={[1, 1.784, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.094, 19.685, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0006.geometry}
                material={materials['Material.525']}
                position={[-4.557, 7.157, 0.861]}
                rotation={[0, 0, 3.137]}
                scale={[1.001, 6.034, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.094, 20.305, -93.161]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0007.geometry}
              material={materials['Material.526']}
              position={[-1.945, 1.75, 0.259]}
              rotation={[0, 0, -1.617]}
              scale={[1.001, 1.38, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.094, 19.788, -93.161]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0008.geometry}
              material={materials['Material.527']}
              position={[-0.865, 3.599, 0.259]}
              rotation={[0, 0, 3.138]}
              scale={[1.001, 2.128, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.094, 19.685, -98.065]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0009.geometry}
              material={materials['Material.528']}
              position={[-2.248, 1.661, 0.361]}
              rotation={[0, 0, -1.617]}
              scale={[1.001, 2.564, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.094, 19.089, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0010.geometry}
                material={materials['Material.529']}
                position={[-4.557, 7.157, 0.861]}
                rotation={[0, 0, 3.137]}
                scale={[1.001, 6.034, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-8.778, 19.089, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0011.geometry}
                material={materials['Material.530']}
                position={[-0.366, 11.389, 0.861]}
                rotation={[0, 0, 1.527]}
                scale={[1.001, 4.813, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-8.778, 19.594, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1059.85, -1938.1, 447.232]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0012.geometry}
                material={materials['Material.531']}
                position={[-0.366, 11.389, 0.861]}
                rotation={[0, 0, 1.527]}
                scale={[1.001, 4.813, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-10.094, 19.788, -93.161]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0013.geometry}
              material={materials['Material.532']}
              position={[-1.945, 1.75, 0.259]}
              rotation={[0, 0, -1.617]}
              scale={[1.001, 1.38, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-10.094, 20.274, -93.161]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0014.geometry}
              material={materials['Material.533']}
              position={[-0.865, 3.599, 0.259]}
              rotation={[0, 0, 3.138]}
              scale={[1.001, 2.128, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.92, 19.788, -93.161]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0015.geometry}
              material={materials['Material.534']}
              position={[-0.865, 3.599, 0.768]}
              rotation={[0, 0, 3.138]}
              scale={[1.001, 2.128, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-2.92, 19.788, -93.161]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0016.geometry}
              material={materials['Material.535']}
              position={[-0.865, 3.599, 0.259]}
              rotation={[0, 0, 3.138]}
              scale={[1.001, 2.128, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[-4.891, 20.305, -98.061]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1058.628, -2017.252, 615.117]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube483_Material002_0005.geometry}
                material={materials['Material.536']}
                position={[2.155, -0.016, 0]}
                scale={[1, 3.782, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-4.891, 20.305, -106.205]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1058.628, -2017.252, 615.116]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0006.geometry}
              material={materials['Material.537']}
              position={[2.155, -0.016, 0]}
              scale={[1, 3.782, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[1.187, 20.305, -106.205]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1058.628, -2017.252, 615.116]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0007.geometry}
              material={materials['Material.538']}
              position={[2.093, 0.003, 0]}
              scale={[1, 2.363, 1]}
            />
          </group>
        </group>
      </group>
      <group position={[1.187, 20.305, -98.059]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0.001]}>
            <group
              position={[-1058.628, -2017.252, 615.116]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube483_Material002_0008.geometry}
                material={materials['Material.539']}
                position={[2.092, -0.225, 0]}
                scale={[1, 2.363, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[-8.316, 20.305, -75.356]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.849, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0017.geometry}
              material={materials['Material.543']}
              position={[-0.001, -0.073, 0]}
              scale={[1, 1.892, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-10.272, 20.305, -75.348]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0018.geometry}
              material={materials['Material.544']}
              position={[-0.001, -0.073, 0]}
              scale={[1, 2.037, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-6.813, 20.305, -75.669]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1058.628, -2017.252, 615.116]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0009.geometry}
              material={materials['Material.545']}
              scale={[1, 2.044, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.317, 20.305, -75.663]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1058.629, -2017.252, 615.116]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0010.geometry}
              material={materials['Material.546']}
              scale={[1, 2.044, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.317, 20.305, -75.719]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0064.geometry}
              material={materials['Material.547']}
              position={[0.008, 1.101, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.318, 20.305, -76.133]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0065.geometry}
              material={materials['Material.548']}
              position={[0.005, 0.734, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.318, 20.305, -76.133]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0066.geometry}
              material={materials['Material.549']}
              position={[0.008, 1.101, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.32, 20.305, -76.597]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0.001, 0, 0]}>
            <group
              position={[-975.123, -2012.551, 538.971]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0067.geometry}
                material={materials['Material.550']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[-8.321, 20.305, -77.052]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0068.geometry}
              material={materials['Material.551']}
              position={[0.002, 0.335, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.321, 20.305, -77.052]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0069.geometry}
              material={materials['Material.552']}
              position={[0.005, 0.734, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.323, 20.305, -77.506]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0070.geometry}
              material={materials['Material.553']}
              position={[-0.001, -0.073, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.323, 20.305, -77.506]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0071.geometry}
              material={materials['Material.554']}
              position={[0.002, 0.335, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.324, 20.305, -77.986]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0072.geometry}
              material={materials['Material.555']}
              position={[-0.001, -0.073, 0]}
            />
          </group>
          <group
            position={[-1130.274, -1965.781, 457.661]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder292_Material006_0005.geometry}
              material={materials['Material.541']}
              position={[0.009, 1.303, 0]}
            />
          </group>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0014.geometry}
              material={materials['Material.541']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.324, 20.305, -73.888]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0073.geometry}
              material={materials['Material.563']}
              position={[-0.001, -0.073, 0]}
            />
          </group>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0015.geometry}
              material={materials['Material.556']}
              position={[0.01, 1.361, 0]}
            />
          </group>
          <group
            position={[-1130.275, -1965.781, 457.661]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder292_Material006_0006.geometry}
              material={materials['Material.556']}
              position={[0.009, 1.303, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.323, 20.305, -73.408]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0074.geometry}
              material={materials['Material.564']}
              position={[0.002, 0.335, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.323, 20.305, -73.408]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0075.geometry}
              material={materials['Material.565']}
              position={[-0.001, -0.073, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.321, 20.305, -72.954]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0076.geometry}
              material={materials['Material.566']}
              position={[0.005, 0.734, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.321, 20.305, -72.954]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0077.geometry}
              material={materials['Material.567']}
              position={[0.002, 0.335, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.32, 20.305, -72.499]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0.001, 0, 0]}>
            <group
              position={[-975.123, -2012.551, 538.971]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0078.geometry}
                material={materials['Material.568']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[-8.318, 20.305, -72.035]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0.001, 0, 0]}>
            <group
              position={[-975.123, -2012.551, 538.971]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0079.geometry}
                material={materials['Material.569']}
                position={[0.008, 1.101, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[-8.318, 20.305, -72.035]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0.001, 0, 0]}>
            <group
              position={[-975.123, -2012.551, 538.971]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0080.geometry}
                material={materials['Material.570']}
                position={[0.005, 0.734, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group
        position={[-8.317, 20.305, -71.621]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.123, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0081.geometry}
              material={materials['Material.571']}
              position={[0.008, 1.101, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.317, 20.305, -71.565]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1058.628, -2017.252, 615.116]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0011.geometry}
              material={materials['Material.561']}
              scale={[1, 2.044, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-6.813, 20.305, -71.571]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1058.628, -2017.252, 615.116]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube483_Material002_0012.geometry}
              material={materials['Material.562']}
              scale={[1, 2.044, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.313, 20.305, -70.199]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1130.275, -1965.781, 457.661]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder292_Material006_0007.geometry}
              material={materials['Material.557']}
              position={[0.009, 1.303, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.312, 20.305, -70.043]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1128.482, -1977.951, 628.47]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cylinder290_Material006_0016.geometry}
              material={materials['Material.558']}
              position={[0.01, 1.361, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-10.272, 20.305, -71.25]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-1059.85, -1938.1, 447.231]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube485_Material002_0019.geometry}
              material={materials['Material.559']}
              position={[-0.001, -0.073, 0]}
              scale={[1, 1.784, 1]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-8.316, 20.305, -71.258]}
        rotation={[-Math.PI / 2, 0, -1.567]}
        scale={[1.159, 1, 1]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0.001, 0, 0]}>
            <group
              position={[-1059.849, -1938.1, 447.231]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube485_Material002_0020.geometry}
                material={materials['Material.560']}
                position={[-0.001, -0.073, 0]}
                scale={[1, 1.784, 1]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[0, 3.862, -122.206]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0, -0.001]}>
          <group position={[173.768, 64.025, -163.209]} rotation={[-Math.PI / 2, 0, 1.725]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_34011.geometry}
              material={materials['lambert15.007']}
              position={[-2803.062, -286.203, -366.706]}
            />
          </group>
        </group>
      </group>
      <group position={[0, 3.862, -122.129]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, 0, 0.001]} rotation={[-Math.PI / 2, 0, 0]}>
              <group rotation={[Math.PI / 2, 0, 0]}>
                <group position={[166.619, 21.069, 12.044]} rotation={[-Math.PI / 2, 0, -0.988]}>
                  <group position={[-0.002, 0, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_8008.geometry}
                      material={materials['lambert1.003']}
                      position={[2465.919, -686.145, -367.384]}
                      rotation={[-0.013, 0, 0.998]}
                    />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-16.408, 0, -90.048]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_8009.geometry}
            material={materials['Table_Kitchen_A.001']}
            position={[-1.5, 0, -0.5]}
          />
        </group>
      </group>
      <group position={[-16.219, 0, 0]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1, 1, -2]} scale={0.857}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_22002.geometry}
              material={materials['Trims_Painted_A.008']}
              position={[-2.801, -1.178, 4.142]}
              rotation={[0, 1.565, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[7.229, 3.509, -159.286]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0, 0.001]}>
          <group position={[0, -0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, 0, -0.002]}>
              <group position={[0, 0, -0.002]} scale={29.485}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_20005.geometry}
                  material={materials['lambert17.001']}
                  position={[95.043, -11.974, 530.614]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-16.219, 1.179, 0]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1, 1, -2]} scale={0.857}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_22003.geometry}
              material={materials['Trims_Painted_A.009']}
              position={[-2.801, -1.178, 4.142]}
              rotation={[0, 1.565, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-16.219, 0, -1.606]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1, 1, -2]} scale={0.857}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_22004.geometry}
              material={materials['Trims_Painted_A.010']}
              position={[-2.801, -1.178, 4.142]}
              rotation={[0, 1.565, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-31.036, 0, 10.023]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_Material001_0008.geometry}
              material={materials['Material.572']}
              position={[-8.829, 5.752, 0]}
              scale={[1, 1, 1.942]}
            />
          </group>
        </group>
      </group>
      <group position={[-42.349, 0, -1.751]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[40.958, 0.335, 379.494]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[84.165, 84.165, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.endtable1_top__low006_endtable1_0001.geometry}
              material={materials['endtable1.003']}
              position={[2.34, 1.34, -0.023]}
            />
          </group>
          <group
            position={[-18.719, -1.463, 379.494]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[85.331, 85.331, 95.766]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.endtable1_top__low003_endtable1_0003.geometry}
              material={materials['endtable1.003']}
              position={[3.703, -0.198, 0.202]}
              rotation={[-0.036, 0, 0]}
            />
          </group>
          <group position={[39.627, 158.43, 384.004]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.lampscrew_low001_lamp01_0002.geometry}
              material={materials['lamp01.002']}
              position={[2.01, 1.195, -0.047]}
            />
          </group>
        </group>
      </group>
      <group position={[-37.847, -0.929, 0.339]} rotation={[-Math.PI / 2, 0, 3.124]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_19008.geometry}
            material={materials['Trims_Painted_A.011']}
            position={[0.5, 1, -2]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={0.904}
          />
        </group>
      </group>
      <group position={[-36.531, -0.929, 0.339]} rotation={[-Math.PI / 2, 0, 3.124]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_19009.geometry}
            material={materials['Trims_Painted_A.012']}
            position={[0.5, 1, -2]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={0.904}
          />
        </group>
      </group>
      <group position={[-42.349, 0, -1.751]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-18.719, -1.463, 379.494]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[85.331, 85.331, 95.766]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.endtable1_top__low003_endtable1_0004.geometry}
              material={materials['endtable1.004']}
              position={[3.703, 0.375, 0.202]}
              rotation={[-1.534, 0, 0]}
            />
          </group>
        </group>
      </group>
      <group position={[-30.382, 20.65, -0.452]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0082.geometry}
              material={materials['Material.573']}
              position={[-3.945, 1.081, 0.897]}
              rotation={[-1.501, -0.336, 0.03]}
              scale={[1.059, 1, 1.008]}
            />
          </group>
        </group>
      </group>
      <group position={[-30.382, 20.203, -0.452]} rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.971]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0083.geometry}
              material={materials['Material.574']}
              position={[-3.945, 1.081, 0.897]}
              rotation={[-1.441, -0.318, 0.214]}
              scale={[1.059, 1, 1.008]}
            />
          </group>
        </group>
      </group>
 
      <group position={[-35.774, -0.929, -0.844]} rotation={[-Math.PI / 2, 0, -0.008]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_19010.geometry}
            material={materials['Trims_Painted_A.013']}
            position={[0.5, 1, -2]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={0.904}
          />
        </group>
      </group>
      <group position={[-34.458, -0.929, -0.857]} rotation={[-Math.PI / 2, 0, -0.008]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_19011.geometry}
            material={materials['Trims_Painted_A.014']}
            position={[0.5, 1, -2]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={0.904}
          />
        </group>
      </group>
      <group position={[-39.718, 0, -22.459]} rotation={[-Math.PI / 2, 0, 1.575]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_8010.geometry}
            material={materials['Table_Kitchen_A.002']}
            position={[-1.5, 0, -0.5]}
          />
        </group>
      </group>
      <group position={[-39.718, 0, -20.449]} rotation={[-Math.PI / 2, 0, 1.575]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_8011.geometry}
            material={materials['Table_Kitchen_A.003']}
            position={[-1.5, 0, -0.5]}
          />
        </group>
      </group>
      <group position={[-42.349, 0, -17.212]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[39.627, 158.43, 384.004]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.lampscrew_low001_lamp01_0003.geometry}
              material={materials['lamp01.003']}
              position={[2.327, 4.963, -0.047]}
            />
          </group>
        </group>
      </group>
      <group position={[-42.025, 1.594, -22.2]} rotation={[1.577, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[2, 0, -0.5]} scale={1.252}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_14005.geometry}
              material={materials['Chairs_A.010']}
              position={[0, 0.121, -0.001]}
            />
          </group>
        </group>
      </group>
      <group position={[-42.025, 1.435, -21.677]} rotation={[1.577, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_14006.geometry}
            material={materials['Chairs_A.011']}
            position={[2, 0, -0.5]}
            scale={1.252}
          />
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube870.geometry}
        material={materials['Material.576']}
        position={[-41.757, 0.863, -1.926]}
        rotation={[0, 0.727, 0]}
        scale={[0.151, 0.964, 2.454]}
      />
      <group position={[-39.819, 0, 21.82]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1, 1, -2]} scale={0.857}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_22005.geometry}
              material={materials['Trims_Painted_A.015']}
              position={[1.142, -1.192, 1.348]}
              rotation={[-Math.PI, 0.004, -Math.PI]}
            />
          </group>
        </group>
      </group>
      <group position={[-41.456, 0, 21.82]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1, 1, -2]} scale={0.857}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_22006.geometry}
              material={materials['Trims_Painted_A.016']}
              position={[1.142, -1.192, 1.348]}
              rotation={[-Math.PI, 0.004, -Math.PI]}
            />
          </group>
        </group>
      </group>
      <group position={[-41.021, 1.16, 19.299]} rotation={[-2.605, -1.526, 2.107]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12009.geometry}
              material={materials['Chairs_A.012']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-40.398, 1.16, 19.287]} rotation={[-2.605, -1.526, 2.107]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12010.geometry}
              material={materials['Chairs_A.013']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-40.254, 1.1, 19.278]} rotation={[2.391, -0.188, -0.521]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12011.geometry}
              material={materials['Chairs_A.014']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-40.471, 0.078, 19.898]} rotation={[-1.819, -0.005, -1.552]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12012.geometry}
              material={materials['Chairs_A.015']}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-40.177, 0.057, 18.359]} rotation={[-Math.PI / 2, 0, -1.552]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12013.geometry}
              material={materials['Chairs_A.016']}
              position={[0, 0.262, -1.144]}
              rotation={[1.525, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-40.165, 0.057, 19.01]} rotation={[-Math.PI / 2, 0, -1.552]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12014.geometry}
              material={materials['Chairs_A.017']}
              position={[0, 0, -0.162]}
              rotation={[-0.805, 0, 0]}
              scale={[1, 1.078, 1.148]}
            />
          </group>
        </group>
      </group>
      <group position={[-27.187, 3.509, -156.305]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0, -0.001]}>
          <group rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, 0, -0.001]}>
              <group position={[0, 0, -0.001]} scale={29.485}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_20006.geometry}
                  material={materials['lambert17.002']}
                  position={[112.018, -12.127, 464.499]}
                  rotation={[0, 1.56, 0]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-80.192, 0, -40.633]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[-11.904, -5.057, -23.303]}>
              <group position={[-96.543, 1.311, -13.606]} rotation={[0, -0.546, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.UBH_ConeShape_zOther_Props_01_0001.geometry}
                  material={materials['zOther_Props_01_0.001']}
                  position={[209.913, 0, -127.47]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-80.842, 0, -39.956]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[-11.903, -5.057, -23.303]}>
              <group position={[78.475, 5.057, 47.209]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.UBH_Garbage_01Shape_zMechanical_Parts_0002.geometry}
                  material={materials['zMechanical_Parts_1.002']}
                  position={[-19.874, 0, -83.871]}
                />
              </group>
              <group position={[56.66, 5.057, -82.174]} rotation={[0, 0.418, 0]}>
                <group position={[0, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zGarbage_0002.geometry}
                    material={materials['zGarbage.002']}
                    position={[0, 0, 0]}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zMechanical_Parts_0002.geometry}
                    material={materials['zMechanical_Parts_0.002']}
                    position={[0, 0, 0]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-80.842, 0, -39.956]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[-11.903, -5.057, -23.303]}>
              <group position={[78.475, 5.057, 47.209]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.UBH_Garbage_01Shape_zMechanical_Parts_0003.geometry}
                  material={materials['zMechanical_Parts_1.003']}
                  position={[124.045, 11.023, -118.785]}
                />
              </group>
              <group position={[56.66, 5.057, -82.174]} rotation={[0, 0.418, 0]}>
                <group position={[0, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zGarbage_0003.geometry}
                    material={materials['zGarbage.003']}
                    position={[0, 0, 0]}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zMechanical_Parts_0003.geometry}
                    material={materials['zMechanical_Parts_0.003']}
                    position={[0, 0, 0]}
                  />
                </group>
              </group>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.UBH_Machine_Part_03Shape_zMechanical_Parts_0001.geometry}
                material={materials['zMechanical_Parts.001']}
                position={[-29.551, 15.929, -16.758]}
                rotation={[1.08, 0, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-79.396, 0, -17.449]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-11.903, -5.057, -23.303]}>
            <group position={[56.66, 5.057, -82.174]} rotation={[0, 0.418, 0]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.UBH_Garbage_05Shape_zOther_Props_01_0001.geometry}
                material={materials['zOther_Props_01_1.001']}
                position={[661.246, 0, -1992.081]}
                rotation={[0, -0.861, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-79.396, 0, -17.37]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-11.903, -5.057, -23.303]}>
            <group position={[56.66, 5.057, -82.175]} rotation={[0, 0.418, 0]}>
              <group position={[-0.001, 0, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.UBH_Garbage_05Shape_zOther_Props_01_0002.geometry}
                  material={materials['zOther_Props_01_1.002']}
                  position={[688.99, 0, -1913.53]}
                  rotation={[0, -0.626, 0]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-106.687, 0, -17.37]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0.001, 0, 0]}>
            <group position={[-11.902, -5.057, -23.303]}>
              <group position={[56.659, 5.057, -82.175]} rotation={[0, 0.418, 0]}>
                <group position={[-0.001, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zOther_Props_01_0003.geometry}
                    material={materials['zOther_Props_01_1.003']}
                    position={[1060.454, 0, -1574.546]}
                    rotation={[0, -1.253, 0]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-107.483, 0, -40.633]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-11.903, -5.057, -23.303]}>
            <group position={[-96.544, 1.311, -13.606]} rotation={[0, -0.546, 0]}>
              <group position={[0, 0, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.UBH_ConeShape_zOther_Props_01_0002.geometry}
                  material={materials['zOther_Props_01_0.002']}
                  position={[814.216, 0, -496.385]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-104.7, 0, -17.449]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group position={[-11.904, -5.057, -23.303]}>
              <group position={[78.475, 5.057, 47.209]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.UBH_Garbage_01Shape_zOther_Props_01_0001.geometry}
                  material={materials['zOther_Props_01_2.001']}
                  position={[228.033, 0, -2077.608]}
                  rotation={[0, -1.399, 0]}
                />
              </group>
              <group position={[56.66, 5.057, -82.174]} rotation={[0, 0.418, 0]}>
                <group position={[0.001, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zOther_Props_01_0004.geometry}
                    material={materials['zOther_Props_01_1.004']}
                    position={[1412.06, 0, -1587.005]}
                    rotation={[0, 0.387, 0]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-104.7, 0, -20.087]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group position={[-11.904, -5.057, -23.303]}>
              <group position={[56.66, 5.057, -82.174]} rotation={[0, 0.418, 0]}>
                <group position={[0.001, 0, 0]}>
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.UBH_Garbage_05Shape_zOther_Props_01_0005.geometry}
                    material={materials['zOther_Props_01_1.005']}
                    position={[1370.636, 0, -1493.626]}
                    rotation={[0, -1.019, 0]}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube871.geometry}
        material={materials['Material.578']}
        position={[-120.592, 1.841, -40.092]}
        rotation={[0, -Math.PI / 2, 0]}
        scale={[0.15, 2.01, 1.774]}
      />
      <group position={[-120.691, -0.529, -57.31]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19012.geometry}
              material={materials['Trims_Painted_A.018']}
              position={[0, -0.539, 1.178]}
            />
          </group>
        </group>
      </group>
      <group position={[-120.691, -0.529, -57.31]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1, 1, -2]} scale={0.857}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_22007.geometry}
              material={materials['Trims_Painted_A.017']}
              position={[0, -0.48, -1.242]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_23001.geometry}
              material={materials['Glass_Cupboard_A.001']}
              position={[0, -0.503, -1.217]}
            />
          </group>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19013.geometry}
              material={materials['Trims_Painted_A.017']}
              position={[-1.14, -0.505, 2.001]}
              rotation={[0, -1.522, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_20007.geometry}
              material={materials['Glass_Cupboard_A.001']}
              position={[0, -0.559, 1.155]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column155.geometry}
        material={materials['Column_material.109']}
        position={[-121.874, 1.418, -60.086]}
        rotation={[0.078, -0.063, -1.335]}
        scale={[2.202, 3.597, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column156.geometry}
        material={materials['Column_material.110']}
        position={[-131.552, 3.559, -59.942]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 4.187, 2.374]}
      />
      <group position={[-120.691, -0.529, -58.61]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1, -2]} rotation={[Math.PI, 0, Math.PI]} scale={0.904}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_19014.geometry}
              material={materials['Trims_Painted_A.019']}
              position={[-1.14, -0.53, 2.001]}
              rotation={[0, -1.522, 0]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column153.geometry}
        material={materials['Column_material.111']}
        position={[-131.552, 3.559, -68.355]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[2.202, 7.756, 2.374]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube872.geometry}
        material={materials['Material.579']}
        position={[-120.511, 1.945, -99.269]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.993]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube873.geometry}
        material={materials['Material.579']}
        position={[-119.42, 1.946, -100.106]}
        rotation={[0, 0, -3.14]}
        scale={[0.21, 2.01, 0.777]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube874.geometry}
        material={materials['Material.579']}
        position={[-120.204, 1.945, -101.058]}
        rotation={[-1.597, 1.564, -1.577]}
        scale={[0.15, 2.01, 0.993]}
      />
      <group position={[-79.73, -0.415, -120.638]} rotation={[Math.PI / 2, 0, 0]} scale={-0.01}>
        <group position={[0, 0.001, 0]}>
          <group position={[0, 0.001, 0]} rotation={[Math.PI / 2, 0, 0]}>
            <group position={[0, -0.001, 0]}>
              <group position={[-0.001, 0, -0.001]}>
                <group position={[172.522, 64.025, -55.286]} rotation={[-Math.PI / 2, 0, 0.563]}>
                  <group position={[-0.001, 0.001, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_14007.geometry}
                      material={materials['lambert15.008']}
                      position={[12.91, 20.466, 0]}
                    />
                  </group>
                </group>
                <group position={[133.577, 51.778, 43.17]} rotation={[-0.316, 0.254, 0]}>
                  <group position={[0, 0, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_37003.geometry}
                      material={materials['lambert16.002']}
                      position={[0, 0, 0]}
                    />
                  </group>
                </group>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_17005.geometry}
                  material={materials['lambert16.002']}
                  position={[136.863, 50.917, -3.398]}
                  rotation={[0, 0.254, 0]}
                />
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_20008.geometry}
                  material={materials['lambert17.003']}
                  position={[-0.001, 0, -0.001]}
                  scale={29.485}
                />
                <group position={[144.172, 41.14, 116.911]} rotation={[-Math.PI / 2, 0, 0.815]}>
                  <group position={[0.001, 0.001, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_11004.geometry}
                      material={materials['material.004']}
                      position={[0.001, 0.001, 0]}
                    />
                  </group>
                </group>
                <group position={[166.618, 21.069, 12.043]} rotation={[-Math.PI / 2, 0, -0.988]}>
                  <group position={[-0.001, 0.001, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_8012.geometry}
                      material={materials['lambert1.004']}
                      position={[-0.001, 0.001, 0]}
                    />
                  </group>
                </group>
                <group position={[138.834, 148.788, -68.904]} rotation={[-Math.PI / 2, -0.245, 0]}>
                  <group position={[0, 0.001, 0]}>
                    <mesh
                      castShadow
                      receiveShadow
                      geometry={nodes.Object_40002.geometry}
                      material={materials['lambert1.004']}
                      position={[0, 0.001, 0]}
                    />
                  </group>
                </group>
                <group position={[92.832, 238.193, -130.573]} rotation={[0, -1.149, 0]}>
                  <group position={[29.971, -107.166, -607.938]}>
                    <group position={[0, 0, -0.001]}>
                      <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Object_31002.geometry}
                        material={materials['lambert18.001']}
                        position={[0, 0, -0.001]}
                      />
                    </group>
                  </group>
                  <group position={[29.971, -241.799, -554.01]} rotation={[-0.231, 0, 0]}>
                    <group position={[0, 0, -0.001]}>
                      <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Object_28001.geometry}
                        material={materials['emission1.001']}
                        position={[0, 0, -0.001]}
                      />
                    </group>
                    <group position={[0, 0, -0.001]}>
                      <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Object_24003.geometry}
                        material={materials['fenster.001']}
                        position={[0, 0, -0.001]}
                      />
                    </group>
                    <group position={[0, 0, -0.001]}>
                      <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes.Object_26003.geometry}
                        material={materials['lambert19.001']}
                        position={[0, 0, -0.001]}
                      />
                    </group>
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
      <group position={[-88.077, 20.203, -77.946]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.972]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0084.geometry}
              material={materials['Material.580']}
              position={[-3.945, 1.081, 0.897]}
              rotation={[-1.441, -0.318, 0.214]}
              scale={[1.059, 1, 1.008]}
            />
          </group>
        </group>
      </group>
      <group position={[-88.077, 20.65, -77.946]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group
            position={[-975.124, -2012.551, 538.972]}
            rotation={[-Math.PI / 2, 0, -1.564]}
            scale={[99.782, 100.003, 100]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube480_Material002_0085.geometry}
              material={materials['Material.581']}
              position={[-3.945, 1.081, 0.897]}
              rotation={[-1.501, -0.336, 0.03]}
              scale={[1.059, 1, 1.008]}
            />
          </group>
        </group>
      </group>
      <group position={[-76.1, 0, -76.748]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group
              position={[-18.719, -1.463, 379.494]}
              rotation={[-Math.PI / 2, 0, 0]}
              scale={[85.331, 85.331, 95.766]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.endtable1_top__low003_endtable1_0005.geometry}
                material={materials['endtable1.006']}
                position={[3.703, 0.375, 0.202]}
                rotation={[-1.534, 0, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-81.935, -0.929, -78.789]} rotation={[-Math.PI / 2, 0, -0.009]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_19015.geometry}
            material={materials['Trims_Painted_A.020']}
            position={[0.5, 1, -2]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={0.904}
          />
        </group>
      </group>
      <group position={[-80.619, -0.929, -78.8]} rotation={[-Math.PI / 2, 0, -0.009]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_19016.geometry}
            material={materials['Trims_Painted_A.021']}
            position={[0.5, 1, -2]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={0.904}
          />
        </group>
      </group>
      <group position={[-76.1, 0, -76.748]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group
              position={[-18.719, -1.463, 379.494]}
              rotation={[-Math.PI / 2, 0, 0]}
              scale={[85.331, 85.331, 95.766]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.endtable1_top__low003_endtable1_0006.geometry}
                material={materials['endtable1.005']}
                position={[3.703, -0.198, 0.202]}
                rotation={[-0.036, 0, 0]}
              />
            </group>
            <group
              position={[40.958, 0.335, 379.495]}
              rotation={[-Math.PI / 2, 0, 0]}
              scale={[84.165, 84.165, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.endtable1_top__low006_endtable1_0002.geometry}
                material={materials['endtable1.005']}
                position={[2.423, 1.481, -0.023]}
              />
            </group>
            <group position={[39.627, 158.43, 384.004]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.lampscrew_low001_lamp01_0004.geometry}
                material={materials['lamp01.004']}
                position={[2.08, 1.313, -0.047]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-142.008, 0, -77.946]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_12015.geometry}
              material={materials['Chairs_A.018']}
              position={[2.114, 0.418, 63.701]}
              rotation={[1.126, 1.496, Math.PI]}
            />
          </group>
          <group position={[1, 0, -0.5]} rotation={[0, -1.571, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_10004.geometry}
              material={materials['Chairs_A.018']}
              position={[0.663, 0, 64.249]}
              rotation={[Math.PI, -1.51, Math.PI]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Column154.geometry}
        material={materials['Column_material.112']}
        position={[-79.291, 0.023, -78.639]}
        scale={[1, 1.714, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Column_box_top087.geometry}
          material={materials['Column_rect.083']}
          position={[0, 2.3, 0]}
        />
      </mesh>
      <group position={[-86.065, 20.65, -58.859]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group
              position={[-975.125, -2012.551, 538.97]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0086.geometry}
                material={materials['Material.582']}
                position={[-3.723, 1.615, 0.897]}
                rotation={[-1.505, 0.069, 0.003]}
                scale={[1.059, 1, 1.008]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-86.065, 20.048, -58.859]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group
              position={[-975.125, -2012.551, 538.97]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0087.geometry}
                material={materials['Material.584']}
                position={[-3.723, 1.615, 0.897]}
                rotation={[-1.505, 0.069, 0.003]}
                scale={[1.059, 1, 1.008]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-86.065, 20.048, -58.859]} rotation={[-Math.PI / 2, 0, -3.133]}>
        <group position={[0, 0, 0.017]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-0.001, 0, 0]}>
            <group
              position={[-975.125, -2012.551, 538.97]}
              rotation={[-Math.PI / 2, 0, -1.564]}
              scale={[99.782, 100.003, 100]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube480_Material002_0088.geometry}
                material={materials['Material.585']}
                position={[-3.723, 1.615, 1.901]}
                rotation={[-1.538, 0.094, 0.501]}
                scale={[1.059, 1, 1.008]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[-78.875, 0, -60.526]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-11.903, -5.057, -23.303]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.UBH_Burning_BarrelShape_zOther_Props_01_0001.geometry}
              material={materials['zOther_Props_01.001']}
              position={[-113.684, 5.057, 80.593]}
            />
          </group>
        </group>
      </group>
      <group position={[-79.053, 0, -60.509]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[0, 0, 0]}>
            <group position={[-11.904, -5.057, -23.303]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.UBH_ConeShape_zOther_Props_01_0003.geometry}
                material={materials['zOther_Props_01_0.003']}
                position={[-96.545, 1.311, -13.605]}
                rotation={[0, -0.546, 0]}
              />
            </group>
          </group>
        </group>
      </group>
      <group position={[18.902, 0, -25.802]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-204.22, 0, -413.621]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.wall_pillar_thing_Material001_0027.geometry}
              material={materials['Material.586']}
              position={[-36.733, -9.232, 0]}
              scale={[1.585, 1.636, 2.03]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-1.708, 0.837, -8.379]}
        rotation={[-Math.PI / 2, 0, 0.455]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6003.geometry}
              material={materials['bullet_holder.001']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8014.geometry}
              material={materials['bullet_bottom.001']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9001.geometry}
              material={materials['ammo_body.001']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4005.geometry}
              material={materials['material.006']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-1.436, 0.814, -8.296]}
        rotation={[-Math.PI / 2, 0, -2.569]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.528]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4006.geometry}
            material={materials['material.003']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube198.geometry}
        material={materials['Material.540']}
        position={[-1.882, 3.869, -7.508]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.433, -0.081, -1.147]}
      />
      <group
        position={[-49.62, 0.814, -8.296]}
        rotation={[-Math.PI / 2, 0, -2.569]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.528]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4007.geometry}
            material={materials['material.007']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <group position={[-50.029, 0.789, -8.545]} rotation={[-Math.PI, -0.812, 0]} scale={0.001}>
        <group position={[-0.001, 0, 0.001]} rotation={[Math.PI / 2, 0, 0]}>
          <group position={[125.787, 4.915, -2.966]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial002.geometry}
              material={materials['Material.542']}
              position={[-0.072, -0.161, 0.068]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial003.geometry}
              material={materials['Material_001.001']}
              position={[-0.072, -0.138, 0.068]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-49.891, 0.837, -8.379]}
        rotation={[-Math.PI / 2, 0, 0.455]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6004.geometry}
              material={materials['bullet_holder.002']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8015.geometry}
              material={materials['bullet_bottom.002']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9002.geometry}
              material={materials['ammo_body.002']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4008.geometry}
              material={materials['material.008']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-49.742, 0.837, -8.527]}
        rotation={[-Math.PI / 2, 0, -0.759]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6005.geometry}
              material={materials['bullet_holder.003']}
              position={[-3.529, -5.366, 6.05]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8016.geometry}
              material={materials['bullet_bottom.003']}
              position={[0, -0.789, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9003.geometry}
              material={materials['ammo_body.003']}
              position={[0, -0.774, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4009.geometry}
              material={materials['material.009']}
              position={[-0.853, 2.649, 0.55]}
            />
          </group>
        </group>
      </group>
      <group position={[-24.637, 0, 0]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1.5, 0, -0.5]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8017.geometry}
              material={materials['Table_Kitchen_A.004']}
              position={[-24.319, 0, -8.16]}
              rotation={[Math.PI, 0, Math.PI]}
            />
          </group>
        </group>
      </group>
      <group position={[-38.967, 0, 3.228]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1.5, 0, -0.5]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8018.geometry}
              material={materials['Table_Kitchen_A.005']}
              position={[10.352, 0, -124.024]}
              rotation={[0, -0.019, 0]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-30.826, 0.837, -121.444]}
        rotation={[-Math.PI / 2, 0, 2.364]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6006.geometry}
              material={materials['bullet_holder.004']}
              position={[-3.529, -5.366, 6.05]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8019.geometry}
              material={materials['bullet_bottom.004']}
              position={[0, -0.789, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9004.geometry}
              material={materials['ammo_body.004']}
              position={[0, -0.774, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4010.geometry}
              material={materials['material.010']}
              position={[-0.853, 2.649, 0.55]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-30.673, 0.837, -121.588]}
        rotation={[-Math.PI / 2, 0, -2.706]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6007.geometry}
              material={materials['bullet_holder.005']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8020.geometry}
              material={materials['bullet_bottom.005']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9005.geometry}
              material={materials['ammo_body.005']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4011.geometry}
              material={materials['material.011']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group position={[-30.539, 0.789, -121.42]} rotation={[0, 0.792, -Math.PI]} scale={0.001}>
        <group position={[0.012, 0, 0.003]} rotation={[Math.PI / 2, 0, 0]}>
          <group position={[125.799, 4.919, -2.966]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial004.geometry}
              material={materials['Material_001.002']}
              position={[-0.072, -0.138, 0.068]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial005.geometry}
              material={materials['Material.587']}
              position={[-0.072, -0.161, 0.068]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-30.943, 0.814, -121.676]}
        rotation={[-Math.PI / 2, 0, 0.553]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.528]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4012.geometry}
            material={materials['material.012']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <group
        position={[-72.886, 0.814, -40.749]}
        rotation={[-Math.PI / 2, 0, -2.569]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.528]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4013.geometry}
            material={materials['material.013']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <group position={[-73.295, 0.789, -40.998]} rotation={[-Math.PI, -0.812, 0]} scale={0.001}>
        <group position={[-0.002, 0, -0.001]} rotation={[Math.PI / 2, 0, 0]}>
          <group position={[125.795, 4.917, -2.965]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial006.geometry}
              material={materials['Material.588']}
              position={[-0.072, -0.161, 0.067]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial007.geometry}
              material={materials['Material_001.003']}
              position={[-0.072, -0.138, 0.067]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-73.158, 0.837, -40.832]}
        rotation={[-Math.PI / 2, 0, 0.455]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6008.geometry}
              material={materials['bullet_holder.006']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8021.geometry}
              material={materials['bullet_bottom.006']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9006.geometry}
              material={materials['ammo_body.006']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.527]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4014.geometry}
              material={materials['material.014']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-73.008, 0.837, -40.98]}
        rotation={[-Math.PI / 2, 0, -0.759]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6009.geometry}
              material={materials['bullet_holder.007']}
              position={[-3.529, -5.366, 6.05]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8022.geometry}
              material={materials['bullet_bottom.007']}
              position={[0, -0.789, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9007.geometry}
              material={materials['ammo_body.007']}
              position={[0, -0.774, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.527]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4015.geometry}
              material={materials['material.015']}
              position={[-0.853, 2.649, 0.55]}
            />
          </group>
        </group>
      </group>
      <group position={[-47.904, 0, -32.453]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1.5, 0, -0.5]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8023.geometry}
              material={materials['Table_Kitchen_A.006']}
              position={[-24.319, 0, -8.16]}
              rotation={[Math.PI, 0, Math.PI]}
            />
          </group>
        </group>
      </group>
      <group position={[-47.904, 0, -32.453]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1.5, 0, -0.5]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8024.geometry}
              material={materials['Table_Kitchen_A.007']}
              position={[-24.319, 0, -8.16]}
              rotation={[Math.PI, 0, Math.PI]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-73.008, 0.837, -40.98]}
        rotation={[-Math.PI / 2, 0, -0.759]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6010.geometry}
              material={materials['bullet_holder.008']}
              position={[-3.529, -5.366, 6.05]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8025.geometry}
              material={materials['bullet_bottom.008']}
              position={[0, -0.789, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9008.geometry}
              material={materials['ammo_body.008']}
              position={[0, -0.774, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.527]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4016.geometry}
              material={materials['material.016']}
              position={[-0.853, 2.649, 0.55]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-73.158, 0.837, -40.832]}
        rotation={[-Math.PI / 2, 0, 0.455]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6011.geometry}
              material={materials['bullet_holder.009']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8026.geometry}
              material={materials['bullet_bottom.009']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9009.geometry}
              material={materials['ammo_body.009']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.527]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4017.geometry}
              material={materials['material.017']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group position={[-73.295, 0.789, -40.998]} rotation={[-Math.PI, -0.812, 0]} scale={0.001}>
        <group position={[-0.002, 0, -0.001]} rotation={[Math.PI / 2, 0, 0]}>
          <group position={[125.795, 4.917, -2.965]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial008.geometry}
              material={materials['Material_001.004']}
              position={[-0.072, -0.138, 0.067]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial009.geometry}
              material={materials['Material.589']}
              position={[-0.072, -0.161, 0.067]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-72.886, 0.814, -40.749]}
        rotation={[-Math.PI / 2, 0, -2.569]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.528]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4018.geometry}
            material={materials['material.018']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <group
        position={[-61.328, 0.814, -78.937]}
        rotation={[-Math.PI / 2, 0, -2.569]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.528]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4019.geometry}
            material={materials['material.019']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <group position={[-61.737, 0.789, -79.186]} rotation={[-Math.PI, -0.812, 0]} scale={0.001}>
        <group position={[0.006, 0, -0.003]} rotation={[Math.PI / 2, 0, 0]}>
          <group position={[125.795, 4.919, -2.966]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial010.geometry}
              material={materials['Material.590']}
              position={[-0.072, -0.161, 0.068]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial011.geometry}
              material={materials['Material_001.005']}
              position={[-0.072, -0.138, 0.068]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-61.6, 0.837, -79.02]}
        rotation={[-Math.PI / 2, 0, 0.455]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6012.geometry}
              material={materials['bullet_holder.010']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8027.geometry}
              material={materials['bullet_bottom.010']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9010.geometry}
              material={materials['ammo_body.010']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4020.geometry}
              material={materials['material.020']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-61.45, 0.837, -79.167]}
        rotation={[-Math.PI / 2, 0, -0.759]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6013.geometry}
              material={materials['bullet_holder.011']}
              position={[-3.529, -5.366, 6.05]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8028.geometry}
              material={materials['bullet_bottom.011']}
              position={[0, -0.789, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9011.geometry}
              material={materials['ammo_body.011']}
              position={[0, -0.774, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4021.geometry}
              material={materials['material.021']}
              position={[-0.853, 2.649, 0.55]}
            />
          </group>
        </group>
      </group>
      <group position={[-36.346, 0, -70.641]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1.5, 0, -0.5]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8029.geometry}
              material={materials['Table_Kitchen_A.008']}
              position={[-24.319, 0, -8.16]}
              rotation={[Math.PI, 0, Math.PI]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-120.186, 0.814, -103.899]}
        rotation={[-Math.PI / 2, 0, -1.01]}
        scale={[0.132, 0.124, 0.093]}>
        <group position={[0, 0.266, -0.527]} scale={[1.138, 0.938, 1.138]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4022.geometry}
            material={materials['material.022']}
            position={[0, 0, 0.272]}
          />
        </group>
      </group>
      <group position={[-120.439, 0.789, -103.493]} rotation={[0, -0.771, Math.PI]} scale={0.001}>
        <group position={[0, 0, 0.001]} rotation={[Math.PI / 2, 0, 0]}>
          <group position={[125.797, 4.911, -2.966]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial012.geometry}
              material={materials['Material.591']}
              position={[-0.071, -0.161, 0.067]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.defaultMaterial013.geometry}
              material={materials['Material_001.006']}
              position={[-0.071, -0.138, 0.067]}
              rotation={[0.059, 0.071, -0.057]}
              scale={[1.032, 1.296, 0.99]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-120.271, 0.837, -103.629]}
        rotation={[-Math.PI / 2, 0, 2.014]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6014.geometry}
              material={materials['bullet_holder.012']}
              position={[0, -6.106, 0]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8030.geometry}
              material={materials['bullet_bottom.012']}
              position={[0, -0.733, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9012.geometry}
              material={materials['ammo_body.012']}
              position={[0, -0.735, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4023.geometry}
              material={materials['material.023']}
              position={[2.777, -1.868, 0.584]}
            />
          </group>
        </group>
      </group>
      <group
        position={[-120.417, 0.837, -103.78]}
        rotation={[-Math.PI / 2, 0, 0.801]}
        scale={[0.132, 0.124, 0.093]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, 0.14, 0.13]} scale={[0.277, 0.12, 0.456]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_6015.geometry}
              material={materials['bullet_holder.013']}
              position={[-3.53, -5.366, 6.05]}
            />
          </group>
          <group position={[-0.008, 0.149, 0.433]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8031.geometry}
              material={materials['bullet_bottom.013']}
              position={[0, -0.789, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_9013.geometry}
              material={materials['ammo_body.013']}
              position={[0, -0.774, 0]}
            />
          </group>
          <group
            position={[0, 0.266, -0.528]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={[1.138, 0.938, 1.138]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_4024.geometry}
              material={materials['material.024']}
              position={[-0.853, 2.649, 0.55]}
            />
          </group>
        </group>
      </group>
      <group position={[-111.604, 0, -128.785]} rotation={[-Math.PI / 2, 0, 1.559]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[-1.5, 0, -0.5]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Object_8032.geometry}
              material={materials['Table_Kitchen_A.009']}
              position={[-24.319, 0, -8.16]}
              rotation={[Math.PI, 0, Math.PI]}
            />
          </group>
        </group>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0028.geometry}
        material={materials['Material.109']}
        position={[-15.556, 3.548, -120.125]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0029.geometry}
        material={materials['Material.120']}
        position={[-15.556, 3.548, -125.953]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0030.geometry}
        material={materials['Material.121']}
        position={[-7.917, 3.548, -125.953]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0031.geometry}
        material={materials['Material.172']}
        position={[-23.465, 3.548, -125.953]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0032.geometry}
        material={materials['Material.468']}
        position={[-7.958, 3.548, -113.502]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0033.geometry}
        material={materials['Material.577']}
        position={[-15.475, 3.548, -113.502]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0001.geometry}
        material={materials['Material.583']}
        position={[7.53, -0.02, -38.452]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0002.geometry}
        material={materials['Material.592']}
        position={[7.53, -0.02, -32.495]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0004.geometry}
        material={materials['Material.593']}
        position={[7.53, -0.02, -26.437]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wall_pillar_thing_Material001_0006.geometry}
        material={materials['Material.594']}
        position={[7.53, -0.02, -51.319]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1.585, 1.636, 2.03]}
      />
    </group>
  )
}

useGLTF.preload("/bloccc.glb")
</file>

<file path="src/models/Car1.tsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 car1.glb --types 
Author: Renafox (https://sketchfab.com/kryik1023)
License: CC-BY-NC-4.0 (http://creativecommons.org/licenses/by-nc/4.0/)
Source: https://sketchfab.com/3d-models/old-rusty-car-95baa20ebc5d4d2e869f0b549be838fe
Title: Old Rusty Car
*/

import * as THREE from "three";
import React from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    ["Object006_Material_#294_0"]: THREE.Mesh;
    ["Object007_Material_#295_0"]: THREE.Mesh;
    ["Plane001_Material_#316_0"]: THREE.Mesh;
  };
  materials: {
    Material_294: THREE.MeshStandardMaterial;
    Material_295: THREE.MeshStandardMaterial;
    Material_316: THREE.MeshStandardMaterial;
  };
  // animations: GLTFAction[]
};

export function Car1(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/car1.glb"
  ) as GLTFResult;
  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes["Object006_Material_#294_0"].geometry}
        material={materials.Material_294}
        position={[0, -4.76, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes["Object007_Material_#295_0"].geometry}
        material={materials.Material_295}
        position={[0, -4.76, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes["Plane001_Material_#316_0"].geometry}
        material={materials.Material_316}
        position={[2.13, 0, -46.352]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
    </group>
  );
}

useGLTF.preload(
  "/car1.glb"
);
</file>

<file path="src/models/Entity1.tsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: üáßüá∑ SamelCookies üáßüá∑ (https://sketchfab.com/ZamuelWarrior)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/hound-backrooms-b835cbb0440942a0856da6cefd365d38
Title: Hound [Backrooms]
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Object_7: THREE.SkinnedMesh
    Object_8: THREE.SkinnedMesh
    Object_10: THREE.SkinnedMesh
    Object_12: THREE.SkinnedMesh
    Object_14: THREE.SkinnedMesh
    Object_15: THREE.SkinnedMesh
    Object_17: THREE.SkinnedMesh
    Object_18: THREE.SkinnedMesh
    Object_20: THREE.SkinnedMesh
    Object_22: THREE.SkinnedMesh
    Object_24: THREE.SkinnedMesh
    Object_26: THREE.SkinnedMesh
    Object_27: THREE.SkinnedMesh
    Object_28: THREE.SkinnedMesh
    GLTF_created_0_rootJoint: THREE.Bone
  }
  materials: {
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.001']: THREE.MeshStandardMaterial
    Material: THREE.MeshStandardMaterial
    ['Material.004']: THREE.MeshStandardMaterial
    ['Material.007']: THREE.MeshStandardMaterial
    ['Material.005']: THREE.MeshStandardMaterial
    ['Material.006']: THREE.MeshStandardMaterial
  }
}

export function Model(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF("/entity1.glb") as GLTFResult
  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={0.273}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0, -0.658, -3.66]} rotation={[1.623, 0, 0]}>
            <primitive object={nodes.GLTF_created_0_rootJoint} />
            <skinnedMesh
              geometry={nodes.Object_7.geometry}
              material={materials['Material.002']}
              skeleton={nodes.Object_7.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_8.geometry}
              material={materials['Material.003']}
              skeleton={nodes.Object_8.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_10.geometry}
              material={materials['Material.001']}
              skeleton={nodes.Object_10.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_12.geometry}
              material={materials.Material}
              skeleton={nodes.Object_12.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_14.geometry}
              material={materials['Material.004']}
              skeleton={nodes.Object_14.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_15.geometry}
              material={materials['Material.007']}
              skeleton={nodes.Object_15.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_17.geometry}
              material={materials['Material.004']}
              skeleton={nodes.Object_17.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_18.geometry}
              material={materials['Material.007']}
              skeleton={nodes.Object_18.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_20.geometry}
              material={materials['Material.005']}
              skeleton={nodes.Object_20.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_22.geometry}
              material={materials['Material.001']}
              skeleton={nodes.Object_22.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_24.geometry}
              material={materials['Material.006']}
              skeleton={nodes.Object_24.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_26.geometry}
              material={materials.Material}
              skeleton={nodes.Object_26.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_27.geometry}
              material={materials.Material}
              skeleton={nodes.Object_27.skeleton}
            />
            <skinnedMesh
              geometry={nodes.Object_28.geometry}
              material={materials.Material}
              skeleton={nodes.Object_28.skeleton}
            />
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload("/entity1.glb")
</file>

<file path="src/models/Ghost.tsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx (adapted to isolate instances)
Author: LostBoyz2078 (https://sketchfab.com/LostModels2025)
License: CC-BY-NC-4.0 (http://creativecommons.org/licenses/by-nc/4.0/)
Source: https://sketchfab.com/3d-models/ghost-daughter-89850ac12e0f468582d4d0dcebd4efbc
Title: Ghost Daughter
*/

import * as THREE from 'three'
import React, { useRef, useEffect, useMemo } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF, SkeletonUtils } from 'three-stdlib'

type GhostGLTF = GLTF

export function Ghost(props: JSX.IntrinsicElements['group']) {
  // Load once from cache
  const { scene, animations } = useGLTF("/ghost.glb") as GhostGLTF

  // ‚õëÔ∏è Per-instance deep clone (bones + meshes). No refs shared with others.
  const model = useMemo(() => SkeletonUtils.clone(scene) as THREE.Group, [scene])

  // One-time per-instance material localization + render flags
  useEffect(() => {
    model.traverse((o: any) => {
      if (o?.isMesh || o?.isSkinnedMesh) {
        o.frustumCulled = false

        // üîí Give this instance its own materials
        if (Array.isArray(o.material)) {
          o.material = o.material.map((m: any) =>
            m?.isMaterial && m.clone ? m.clone() : m
          )
        } else if (o.material?.isMaterial && o.material.clone) {
          o.material = o.material.clone()
        }

        // Friendly defaults for translucent ghost parts
        const mats = Array.isArray(o.material) ? o.material : [o.material]
        for (const m of mats) {
          if (!m) continue
          if ('transparent' in m) m.transparent = true
          if ('depthWrite' in m) m.depthWrite = false
          if ('side' in m) m.side = THREE.DoubleSide
        }
      }
    })
  }, [model])

  // Play the single clip
  const { actions } = useAnimations(animations, model)
  useEffect(() => {
    const a = actions['GltfAnimation 0']
    a?.reset().fadeIn(0.3).play()
    return () => { a?.fadeOut(0.2).stop() }
  }, [actions])

  // IMPORTANT: prevent R3F disposing children when this unmounts
  return (
    <primitive
      object={model}
      {...props}
      dispose={null}
      userData={{ isEntity: true }}
    />
  )
}

useGLTF.preload('/ghost.glb')
</file>

<file path="src/models/GhostPatrol.tsx">
// client/src/models/GhostPatrol.tsx
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  loops?: number;
  speed?: number;
  yawOffset?: number;
  scale?: number;
  debug?: boolean;

  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;

  collideRadius?: number;
  showCollider?: boolean;
    healthPct?: number;
};

export default function GhostPatrol({
  y = 0.7,
  loops = 4,
  speed = 2.5,
  yawOffset = 0,
  scale = 1,
  debug = false,

  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,

  collideRadius = 3,
  showCollider = false,
   healthPct = 1
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);
  const culledFixedRef = useRef(false);
const materialsLocalizedRef = useRef(false);

  // Fixed X, patrol along Z
  const spawnX = 372;
  const spawnZ = 396;
  const topZ = 402;
  const bottomZ = 393;

  const goingRightRef = useRef(true);
  const loopsDoneRef = useRef(0);
  const hitRightRef = useRef(false);
const qTarget = useRef(new THREE.Quaternion());
const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));
const autoYawFixRef = useRef<number | null>(null); // computed once from GLTF forward

  // Ensure GLTF subtree is de-cull'ed once it exists
  useEffect(() => {
    let raf = 0;
    const ensureNoCulling = () => {
      const root = ghostRoot.current;
      if (!root) {
        raf = requestAnimationFrame(ensureNoCulling);
        return;
      }
      // Skip if we already processed successfully
      if (culledFixedRef.current) return;

      let foundMeshes = 0;
      root.traverse((o: any) => {
        if (o?.isMesh || o?.isSkinnedMesh) {
          o.frustumCulled = false;
          foundMeshes++;
          // Helpful defaults for translucent/glowy ghost parts
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats) {
            if (!m) continue;
            if ("transparent" in m) m.transparent = true;
            if ("depthWrite" in m) m.depthWrite = false;
            if ("side" in m) m.side = THREE.DoubleSide;
          }
        }
        // Force default layer in case model came with odd layers
        o.layers?.enable?.(0);
      });
// Give this instance its own materials so edits don't affect other ghosts
if (!materialsLocalizedRef.current) {
  root.traverse((o: any) => {
    if (o?.isMesh || o?.isSkinnedMesh) {
      if (Array.isArray(o.material)) {
        o.material = o.material.map((m: any) =>
          m?.isMaterial && m.clone ? m.clone() : m
        );
      } else if (o.material?.isMaterial && o.material.clone) {
        o.material = o.material.clone();
      }
    }
  });
  materialsLocalizedRef.current = true;
}

      if (foundMeshes > 0) {
        culledFixedRef.current = true;
        // Also disable culling on parent ghosts
        root.frustumCulled = false;

        // --- Auto-calibrate yaw: what's the model's current forward yaw? ---
// getWorldDirection returns the object's local -Z in world space.
const fwd = new THREE.Vector3();
(ghostRoot.current as THREE.Object3D).getWorldDirection(fwd);
const modelYaw0 = Math.atan2(fwd.x, fwd.z);   // yaw of current (-Z) forward
autoYawFixRef.current = -modelYaw0;           // correction so our +Z-aim formula works

      } else {
        // Try again next frame until Ghost GLTF is mounted
        raf = requestAnimationFrame(ensureNoCulling);
      }
    };

    raf = requestAnimationFrame(ensureNoCulling);
    return () => cancelAnimationFrame(raf);
  }, []);

  // Place & face +Z on mount
  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
// initial yaw handled by face-player slerp


    // Parent helpers (non-GLTF children)
    group.current.traverse((o: any) => {
      if (o?.isMesh) {
        o.castShadow = true;
        o.receiveShadow = false;
      }
      // Do not rely on this for GLTF meshes (handled above once loaded)
    });

    console.log("[GhostPatrol] spawned at", group.current.position.toArray());
  }, [y, yawOffset]);
// ‚¨ÜÔ∏è keep your imports

function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}

  useFrame((_, dt) => {
    const g = group.current;
    if (!g) return;

    // Patrol motion (along Z)
    if (loopsDoneRef.current < loops) {
      const targetZ = goingRightRef.current ? topZ : bottomZ;
      const dirZ = Math.sign(targetZ - g.position.z) || 1;
      const step = dirZ * speed * dt;

      const willOvershoot =
        (dirZ > 0 && g.position.z + step >= targetZ) ||
        (dirZ < 0 && g.position.z + step <= targetZ);

      if (willOvershoot) {
        g.position.z = targetZ;
        if (goingRightRef.current) {
          goingRightRef.current = false;
          hitRightRef.current = true;
        } else {
          if (hitRightRef.current) {
            loopsDoneRef.current += 1;
            hitRightRef.current = false;
          }
          if (loopsDoneRef.current < loops) goingRightRef.current = true;
        }
        const nextDirZ = goingRightRef.current ? 1 : -1;
       // yaw handled by face-player slerp

      } else {
        g.position.z += step;
      // yaw handled by face-player slerp

      }
    }

    
// === FACE PLAYER (smooth yaw via quaternion slerp + auto-calibration) ===
{
  const { position: playerPos } = useAppStore.getState();
  if (playerPos) {
    const dx = playerPos.x - g.position.x;
    const dz = playerPos.z - g.position.z;
    const distSq = dx * dx + dz * dz;
    if (distSq > 1e-6) {
      // combine the auto-calibrated correction (from GLTF forward) with any manual yawOffset (radians)
      const autoFix = (autoYawFixRef.current ?? 0) + (yawOffset ?? 0);
      const yaw = Math.atan2(dx, dz) + autoFix;

      eTmp.current.set(0, yaw, 0, "YXZ");
      qTarget.current.setFromEuler(eTmp.current);

      // dt-stable smoothing (raise 8 for snappier turning)
      const t = 1 - Math.exp(-8 * dt);
      g.quaternion.slerp(qTarget.current, t);
    }
  }
}


    // Soft collision pushback
    const { position: playerPos, updatePosition } = useAppStore.getState();
    if (playerPos && updatePosition) {
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist = Math.hypot(dx, dz);

      if (dist > 0 && dist < collideRadius) {
        const nx = dx / dist;
        const nz = dz / dist;
        const safeX = g.position.x + nx * collideRadius;
        const safeZ = g.position.z + nz * collideRadius;
        updatePosition(new THREE.Vector3(safeX, playerPos.y, safeZ));
      } else if (dist === 0) {
        updatePosition(new THREE.Vector3(g.position.x, playerPos.y, g.position.z + collideRadius));
      }
    }
  });

// (slerp handled inside the useFrame callback; duplicate outer block removed)

function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
  <group ref={group} position={[spawnX, y, spawnZ]} userData={{ isEntity: true }}>

        {/* ‚úÖ new: full-body hitbox */}
    <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[collideRadius, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {/* red face light */}
      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight color="#ff2a2a" intensity={faceLightIntensity} distance={faceLightDistance} decay={5} />
        </group>
      )}

      {/* Wrap Ghost with a ref so we can safely de-cull after GLTF mounts */}
      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
      </group>
    </group>
  );
}
</file>

<file path="src/models/GhostPatrol2.tsx">
// client/src/models/GhostPatrol2.tsx
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  loops?: number;
  speed?: number;
  yawOffset?: number;
  scale?: number;
  debug?: boolean;
  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;
  collideRadius?: number;
  showCollider?: boolean;
    healthPct?: number;
};

export default function GhostPatrol2({
  y = 0.7,
  loops = 4,
  speed = 2.5,
  yawOffset = 0,
  scale = 1,
  debug = false,
  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,
  collideRadius = 1.8,
  showCollider = false,
    healthPct = 1,
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);
  const culledFixedRef = useRef(false);
const materialsLocalizedRef = useRef(false);

  // Patrol along X between 338..357 at Z=354
  const spawnX = 347;
  const spawnZ = 354;
  const leftX = 338;
  const rightX = 357;

  const goingRightRef = useRef(true);
  const loopsDoneRef = useRef(0);
  const hitRightRef = useRef(false);
const qTarget = useRef(new THREE.Quaternion());
const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));

  useEffect(() => {
    let raf = 0;
    const ensureNoCulling = () => {
      const root = ghostRoot.current;
      if (!root) {
        raf = requestAnimationFrame(ensureNoCulling);
        return;
      }
      if (culledFixedRef.current) return;

      let found = 0;
      root.traverse((o: any) => {
        if (o?.isMesh || o?.isSkinnedMesh) {
          o.frustumCulled = false;
          found++;
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats) {
            if (!m) continue;
            if ("transparent" in m) m.transparent = true;
            if ("depthWrite" in m) m.depthWrite = false;
            if ("side" in m) m.side = THREE.DoubleSide;
          }
        }
        o.layers?.enable?.(0);
      });
      if (found > 0) {
        culledFixedRef.current = true;
        root.frustumCulled = false;
      } else {
        raf = requestAnimationFrame(ensureNoCulling);
      }
    };
    raf = requestAnimationFrame(ensureNoCulling);
    return () => cancelAnimationFrame(raf);
  }, []);
function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}
  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
    group.current.rotation.y = Math.atan2(0, 1) + yawOffset;
  }, [y, yawOffset]);

  useFrame((_, dt) => {
    const g = group.current;
    if (!g) return;

    // Patrol motion (along X)
    if (loopsDoneRef.current < loops) {
      const targetX = goingRightRef.current ? rightX : leftX;
      const dirX = Math.sign(targetX - g.position.x) || 1;
      const step = dirX * speed * dt;

      const willOvershoot =
        (dirX > 0 && g.position.x + step >= targetX) ||
        (dirX < 0 && g.position.x + step <= targetX);

      if (willOvershoot) {
        g.position.x = targetX;
        if (goingRightRef.current) {
          goingRightRef.current = false;
          hitRightRef.current = true;
        } else {
          if (hitRightRef.current) {
            loopsDoneRef.current += 1;
            hitRightRef.current = false;
          }
          if (loopsDoneRef.current < loops) goingRightRef.current = true;
        }
        const nextDirX = goingRightRef.current ? 1 : -1;
    // yaw handled by face-player slerp

      } else {
        g.position.x += step;
        // yaw handled by face-player slerp

      }
    }
// === FACE PLAYER (smooth yaw via quaternion slerp) ===
{
  const { position: playerPos } = useAppStore.getState();
  if (playerPos) {
    const dx = playerPos.x - g.position.x;
    const dz = playerPos.z - g.position.z;
    const distSq = dx * dx + dz * dz;
    if (distSq > 1e-6) {
      const yaw = Math.atan2(dx, dz) + yawOffset;
      eTmp.current.set(0, yaw, 0, "YXZ");
      qTarget.current.setFromEuler(eTmp.current);
      const t = 1 - Math.exp(-8 * dt);
      g.quaternion.slerp(qTarget.current, t);
    }
  }
}

    const { position: playerPos, updatePosition } = useAppStore.getState();
    if (playerPos && updatePosition) {
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist = Math.hypot(dx, dz);

      if (dist > 0 && dist < collideRadius) {
        const nx = dx / dist;
        const nz = dz / dist;
        const safeX = g.position.x + nx * collideRadius;
        const safeZ = g.position.z + nz * collideRadius;
        updatePosition(new THREE.Vector3(safeX, playerPos.y, safeZ));
      } else if (dist === 0) {
        updatePosition(new THREE.Vector3(g.position.x + collideRadius, playerPos.y, g.position.z));
      }
    }
  });
function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
    <group ref={group} position={[spawnX, y, spawnZ]} userData={{ isEntity: true }}>
        <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[collideRadius, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight color="#ff2a2a" intensity={faceLightIntensity} distance={faceLightDistance} decay={5} />
        </group>
      )}

      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
      </group>
    </group>
  );
}
</file>

<file path="src/models/GhostPatrol3.tsx">
// client/src/models/GhostPatrol2.tsx
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  loops?: number;
  speed?: number;
  yawOffset?: number;
  scale?: number;
  debug?: boolean;
  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;
  collideRadius?: number;
  showCollider?: boolean;
    healthPct?: number;
};

export default function GhostPatrol3({
  y = 0.7,
  loops = 4,
  speed = 2.5,
  yawOffset = 0,
  scale = 1,
  debug = false,
  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,
  collideRadius = 1.8,
  showCollider = false,
    healthPct = 1,
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);
  const culledFixedRef = useRef(false);
  const materialsLocalizedRef = useRef(false);

  const { camera } = useThree();


// Vanish when player looks at the ghost
const vanishedRef = useRef(false);
const rayRef = useRef(new THREE.Raycaster());
const tmpVec = useRef(new THREE.Vector3());
const fwd = useRef(new THREE.Vector3());


// Patrol at Z=381, spawn at X=295; light side-to-side sway (292..298)
const spawnX = 295;
const spawnZ = 381;
const leftX = 292;
const rightX = 298;


  const goingRightRef = useRef(true);
  const loopsDoneRef = useRef(0);
  const hitRightRef = useRef(false);
const qTarget = useRef(new THREE.Quaternion());
const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));

  useEffect(() => {
    let raf = 0;
    const ensureNoCulling = () => {
      const root = ghostRoot.current;
      if (!root) {
        raf = requestAnimationFrame(ensureNoCulling);
        return;
      }
      if (culledFixedRef.current) return;

      let found = 0;
      root.traverse((o: any) => {
        if (o?.isMesh || o?.isSkinnedMesh) {
          o.frustumCulled = false;
          found++;
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats) {
            if (!m) continue;
            if ("transparent" in m) m.transparent = true;
            if ("depthWrite" in m) m.depthWrite = false;
            if ("side" in m) m.side = THREE.DoubleSide;
          }
        }
        o.layers?.enable?.(0);
      });
      if (found > 0) {
        culledFixedRef.current = true;
        root.frustumCulled = false;
      } else {
        raf = requestAnimationFrame(ensureNoCulling);
      }
    };
    raf = requestAnimationFrame(ensureNoCulling);
    return () => cancelAnimationFrame(raf);
  }, []);

  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
    group.current.rotation.y = Math.atan2(0, 1) + yawOffset;
  }, [y, yawOffset]);
function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}
  useFrame((_, dt) => {
  const g = group.current;
  if (!g) return;

  // If already vanished, keep hidden and bail
  if (vanishedRef.current) {
    g.visible = false;
    return;
  }

  // === Patrol motion (gentle sway along X) ===
  if (loopsDoneRef.current < loops) {
    const targetX = goingRightRef.current ? rightX : leftX;
    const dirX = Math.sign(targetX - g.position.x) || 1;
    const step = dirX * speed * dt;

    const willOvershoot =
      (dirX > 0 && g.position.x + step >= targetX) ||
      (dirX < 0 && g.position.x + step <= targetX);

    if (willOvershoot) {
      g.position.x = targetX;
      if (goingRightRef.current) {
        goingRightRef.current = false;
        hitRightRef.current = true;
      } else {
        if (hitRightRef.current) {
          loopsDoneRef.current += 1;
          hitRightRef.current = false;
        }
        if (loopsDoneRef.current < loops) goingRightRef.current = true;
      }
    } else {
      g.position.x += step;
    }
  }

  // === FACE PLAYER (smooth yaw via quaternion slerp) ===
  {
    const { position: playerPos } = useAppStore.getState();
    if (playerPos) {
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const distSq = dx * dx + dz * dz;
      if (distSq > 1e-6) {
        const yaw = Math.atan2(dx, dz) + yawOffset;
        eTmp.current.set(0, yaw, 0, "YXZ");
        qTarget.current.setFromEuler(eTmp.current);
        const t = 1 - Math.exp(-8 * dt);
        g.quaternion.slerp(qTarget.current, t);
      }
    }
  }

  // === Player collision pushback (unchanged) ===
  {
    const { position: playerPos, updatePosition } = useAppStore.getState();
    if (playerPos && updatePosition) {
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist = Math.hypot(dx, dz);

      if (dist > 0 && dist < collideRadius) {
        const nx = dx / dist;
        const nz = dz / dist;
        const safeX = g.position.x + nx * collideRadius;
        const safeZ = g.position.z + nz * collideRadius;
        updatePosition(new THREE.Vector3(safeX, playerPos.y, safeZ));
      } else if (dist === 0) {
        updatePosition(new THREE.Vector3(g.position.x + collideRadius, playerPos.y, g.position.z));
      }
    }
  }

  // === VANISH IF PLAYER SEES IT ===
  // "Sees it" ‚âà within forward FOV & unobstructed ray from camera to ghost
  {
    const camPos = camera.position;
    const toGhost = tmpVec.current.subVectors(g.position, camPos);
    const dist = toGhost.length();
    if (dist < 100) {
      toGhost.normalize();
      camera.getWorldDirection(fwd.current);
      const aligned = fwd.current.dot(toGhost);
      // FOV gate (~60¬∞ FOV -> half-angle ~30¬∞; cos 30¬∞ ‚âà 0.866). Be slightly stricter:
      if (aligned > 0.90) {
        const rc = rayRef.current;
        rc.set(camPos, toGhost);
        // If the first hit along the ray is the ghost, it's visible to the player
        const hits = rc.intersectObject(g, true);
        if (hits.length > 0) {
          vanishedRef.current = true;
          g.visible = false;
          if (ghostRoot.current) ghostRoot.current.visible = false; // also hide inner meshes / light
        }
      }
    }
  }
});
function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
    <group ref={group} position={[spawnX, y, spawnZ]} userData={{ isEntity: true }}>
        <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
        
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[collideRadius, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight color="#ff2a2a" intensity={faceLightIntensity} distance={faceLightDistance} decay={5} />
        </group>
      )}

      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
      </group>
    </group>
  );
}
</file>

<file path="src/models/GhostPatrol4.tsx">
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  speed?: number;
  yawOffset?: number;
  scale?: number;
  debug?: boolean;
  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;
  collideRadius?: number;   // visual only
  showCollider?: boolean;
    healthPct?: number;
  onVanish?: () => void;
};

export default function GhostPatrol4({
  y = 0.7,
  speed = 2.5,
  yawOffset = 0,
  scale = 1,
  debug = false,
  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,
  collideRadius = 1.8,
  showCollider = false,
  onVanish,
    healthPct = 1,
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);
  const culledFixedRef = useRef(false);
  const materialsLocalizedRef = useRef(false);


  // spawn at x:295, z:345
  const spawnX = 295;
  const spawnZ = 345;

  // 10s lifetime + 1m standoff
  const lifeSecRef = useRef(0);
  const vanishedRef = useRef(false);
  const minDistance = 1.0;

  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
    group.current.rotation.y = yawOffset;
    vanishedRef.current = false;
    lifeSecRef.current = 0;
  }, [y, yawOffset]);

  // disable frustum culling & make materials transparent-friendly
  useEffect(() => {
    let raf = 0;
    const apply = () => {
      const root = ghostRoot.current;
      if (!root) { raf = requestAnimationFrame(apply); return; }
      if (culledFixedRef.current) return;

      let found = 0;
      root.traverse((o: any) => {
        if (o?.isMesh || o?.isSkinnedMesh) {
          o.frustumCulled = false;
          found++;
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats) {
            if (!m) continue;
            if ("transparent" in m) m.transparent = true;
            if ("depthWrite" in m) m.depthWrite = false;
            if ("side" in m) m.side = THREE.DoubleSide;
          }
        }
      });
      if (!materialsLocalizedRef.current) {
  root.traverse((o: any) => {
    if (o?.isMesh || o?.isSkinnedMesh) {
      if (Array.isArray(o.material)) {
        o.material = o.material.map((m: any) =>
          m?.isMaterial && m.clone ? m.clone() : m
        );
      } else if (o.material?.isMaterial && o.material.clone) {
        o.material = o.material.clone();
      }
    }
  });
  materialsLocalizedRef.current = true;
}

      if (found > 0) culledFixedRef.current = true;
      else raf = requestAnimationFrame(apply);
    };
    raf = requestAnimationFrame(apply);
    return () => cancelAnimationFrame(raf);
  }, []);

  // ----- hard hide helper -----
const hardHide = () => {
  const g = group.current
  if (!g) return
  // Just hide this instance; do not remove() or edit materials.
  g.visible = false
}

function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}
  // smooth face
  const qTarget = useRef(new THREE.Quaternion());
  const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));

  useFrame((_, dt) => {
    const g = group.current;
    if (!g) return;

    if (vanishedRef.current) return;

    lifeSecRef.current += dt;
    if (lifeSecRef.current >= 10) {
      vanishedRef.current = true;
      hardHide();
      onVanish?.();
      return;
    }

    // follow player but stop at 1m (no pushback ever)
    const { position: playerPos } = useAppStore.getState();
    if (playerPos) {
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist = Math.hypot(dx, dz);

      if (dist > minDistance) {
        const gap = dist - minDistance;
        const step = Math.min(speed * dt, gap);
        g.position.x += (dx / dist) * step;
        g.position.z += (dz / dist) * step;
      }

      if (dist > 1e-6) {
        const yaw = Math.atan2(dx, dz) + yawOffset;
        eTmp.current.set(0, yaw, 0, "YXZ");
        qTarget.current.setFromEuler(eTmp.current);
        const t = 1 - Math.exp(-8 * dt);
        g.quaternion.slerp(qTarget.current, t);
      }
    }
  });
function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
    <group ref={group} position={[spawnX, y, spawnZ]} userData={{ isEntity: true, ghostId: 4 }}>
        <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
        
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[collideRadius, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight color="#ff2a2a" intensity={faceLightIntensity} distance={faceLightDistance} decay={5} />
        </group>
      )}

      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
    </group>
    </group>
  );
}
</file>

<file path="src/models/GhostPatrol5.tsx">
// client/src/models/GhostPatrol5.tsx
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  speed?: number;         // kept for consistency (not moving in this behavior)
  yawOffset?: number;
  scale?: number;
  debug?: boolean;

  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;

  showCollider?: boolean;
    healthPct?: number;
  onVanish?: () => void;
};

export default function GhostPatrol5({
  y = 0.7,
  speed = 0,
  yawOffset = 0,
  scale = 1,
  debug = false,

  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,

  showCollider = false,
  onVanish,
    healthPct = 1,
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);

  // Spawn at x: 295, z: 278 (frontend "y" == world Z)
  const spawnX = 295;
  const spawnZ = 278;

  // Blink state
  const triggeredRef = useRef(false);   // becomes true once player is within 15 m
  const blinkTimerRef = useRef(0);      // accumulates time for 1s toggles
  const blinkOffCountRef = useRef(0);   // count how many times we turned invisible
  const vanishedRef = useRef(false);    // final state after sequence

  const qTarget = useRef(new THREE.Quaternion());
  const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));

  const { camera } = useThree();

  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
    group.current.rotation.y = yawOffset;
    // reset session state
    triggeredRef.current = false;
    blinkTimerRef.current = 0;
    blinkOffCountRef.current = 0;
    vanishedRef.current = false;
    // ensure visible at spawn
    group.current.visible = true;
    if (ghostRoot.current) ghostRoot.current.visible = true;
  }, [y, yawOffset]);

  // Hide whole instance (mesh + red ball + light) without touching materials
  const vanishHard = () => {
    const g = group.current;
    if (!g) return;
    g.visible = false;                  // hides light & children too
    if (ghostRoot.current) ghostRoot.current.visible = false;
    onVanish?.();
  };
function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}
  useFrame((_, dt) => {
    const g = group.current;
    if (!g || vanishedRef.current) return;

    // Smoothly face player (nice touch, optional)
    {
      const { position: playerPos } = useAppStore.getState();
      if (playerPos) {
        const dx = playerPos.x - g.position.x;
        const dz = playerPos.z - g.position.z;
        const distSq = dx * dx + dz * dz;
        if (distSq > 1e-6) {
          const yaw = Math.atan2(dx, dz) + yawOffset;
          eTmp.current.set(0, yaw, 0, "YXZ");
          qTarget.current.setFromEuler(eTmp.current);
          const t = 1 - Math.exp(-8 * dt);
          g.quaternion.slerp(qTarget.current, t);
        }
      }
    }

    const { position: playerPos } = useAppStore.getState();
    if (!triggeredRef.current && playerPos) {
      // Trigger when player is within 15 m (2D distance)
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist2D = Math.hypot(dx, dz);
      if (dist2D <= 35) {
        triggeredRef.current = true;
        blinkTimerRef.current = 0;
        blinkOffCountRef.current = 0;
        // Make sure we start visible for the first toggle to turn it off
        g.visible = true;
        if (ghostRoot.current) ghostRoot.current.visible = true;
      }
    }

    // Once triggered, blink: toggle visibility every 1 second.
    if (triggeredRef.current) {
      blinkTimerRef.current += dt;
      if (blinkTimerRef.current >= 1.0) {
        blinkTimerRef.current -= 1.0;

        // Toggle
        g.visible = !g.visible;
        if (ghostRoot.current) ghostRoot.current.visible = g.visible;

        // Count only the "off" moments as blinks
        if (!g.visible) {
          blinkOffCountRef.current += 1;
          // After 3 disappearances, vanish for good
          if (blinkOffCountRef.current >= 3) {
            vanishedRef.current = true;
            vanishHard();
            return;
          }
        }
      }
    }
  });
function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
    // NOTE: no userData.isEntity so this ghost doesn't interfere with AimProbe/F shooting UI
    <group ref={group} position={[spawnX, y, spawnZ]} userData={{ ghostId: 5 }}>
      
        <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[1.8 * scale, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {/* red face light + ball */}
      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06 * scale, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight
            color="#ff2a2a"
            intensity={faceLightIntensity}
            distance={faceLightDistance}
            decay={5}
          />
        </group>
      )}

      {/* Isolated GLTF instance (from Ghost.tsx, which deep-clones materials/skeleton) */}
      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
      </group>
    </group>
  );
}
</file>

<file path="src/models/GhostPatrol6.tsx">
// client/src/models/GhostPatrol5.tsx
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  speed?: number;         // kept for consistency (not moving in this behavior)
  yawOffset?: number;
  scale?: number;
  debug?: boolean;

  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;

  showCollider?: boolean;
    healthPct?: number;
  onVanish?: () => void;
};

export default function GhostPatrol6({
  y = 0.7,
  speed = 0,
  yawOffset = 0,
  scale = 1,
  debug = false,

  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,

  showCollider = false,
  onVanish,
    healthPct = 1,
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);

  // Spawn at x: 295, z: 278 (frontend "y" == world Z)
  const spawnX = 399;
  const spawnZ = 354;

  // Blink state
  const triggeredRef = useRef(false);   // becomes true once player is within 15 m
  const blinkTimerRef = useRef(0);      // accumulates time for 1s toggles
  const blinkOffCountRef = useRef(0);   // count how many times we turned invisible
  const vanishedRef = useRef(false);    // final state after sequence

  const qTarget = useRef(new THREE.Quaternion());
  const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));

  const { camera } = useThree();

  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
    group.current.rotation.y = yawOffset;
    // reset session state
    triggeredRef.current = false;
    blinkTimerRef.current = 0;
    blinkOffCountRef.current = 0;
    vanishedRef.current = false;
    // ensure visible at spawn
    group.current.visible = true;
    if (ghostRoot.current) ghostRoot.current.visible = true;
  }, [y, yawOffset]);

  // Hide whole instance (mesh + red ball + light) without touching materials
  const vanishHard = () => {
    const g = group.current;
    if (!g) return;
    g.visible = false;                  // hides light & children too
    if (ghostRoot.current) ghostRoot.current.visible = false;
    onVanish?.();
  };
function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}
  useFrame((_, dt) => {
    const g = group.current;
    if (!g || vanishedRef.current) return;

    // Smoothly face player (nice touch, optional)
    {
      const { position: playerPos } = useAppStore.getState();
      if (playerPos) {
        const dx = playerPos.x - g.position.x;
        const dz = playerPos.z - g.position.z;
        const distSq = dx * dx + dz * dz;
        if (distSq > 1e-6) {
          const yaw = Math.atan2(dx, dz) + yawOffset;
          eTmp.current.set(0, yaw, 0, "YXZ");
          qTarget.current.setFromEuler(eTmp.current);
          const t = 1 - Math.exp(-8 * dt);
          g.quaternion.slerp(qTarget.current, t);
        }
      }
    }

    const { position: playerPos } = useAppStore.getState();
    if (!triggeredRef.current && playerPos) {
      // Trigger when player is within 15 m (2D distance)
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist2D = Math.hypot(dx, dz);
      if (dist2D <= 15) {
        triggeredRef.current = true;
        blinkTimerRef.current = 0;
        blinkOffCountRef.current = 0;
        // Make sure we start visible for the first toggle to turn it off
        g.visible = true;
        if (ghostRoot.current) ghostRoot.current.visible = true;
      }
    }

    // Once triggered, blink: toggle visibility every 1 second.
    if (triggeredRef.current) {
      blinkTimerRef.current += dt;
      if (blinkTimerRef.current >= 1.0) {
        blinkTimerRef.current -= 1.0;

        // Toggle
        g.visible = !g.visible;
        if (ghostRoot.current) ghostRoot.current.visible = g.visible;

        // Count only the "off" moments as blinks
        if (!g.visible) {
          blinkOffCountRef.current += 1;
          // After 3 disappearances, vanish for good
          if (blinkOffCountRef.current >= 3) {
            vanishedRef.current = true;
            vanishHard();
            return;
          }
        }
      }
    }
  });
function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
    // NOTE: no userData.isEntity so this ghost doesn't interfere with AimProbe/F shooting UI
    <group ref={group} position={[spawnX, y, spawnZ]} userData={{ ghostId: 5 }}>
      
        <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[1.8 * scale, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {/* red face light + ball */}
      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06 * scale, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight
            color="#ff2a2a"
            intensity={faceLightIntensity}
            distance={faceLightDistance}
            decay={5}
          />
        </group>
      )}

      {/* Isolated GLTF instance (from Ghost.tsx, which deep-clones materials/skeleton) */}
      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
      </group>
    </group>
  );
}
</file>

<file path="src/models/GhostPatrol7.tsx">
import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useFrame } from "@react-three/fiber";
import { Ghost } from "./Ghost";
import useAppStore from "../zustand/store";

type Props = {
  y?: number;
  speed?: number;
  yawOffset?: number;
  scale?: number;
  debug?: boolean;
  faceLight?: boolean;
  faceLightIntensity?: number;
  faceLightDistance?: number;
  faceOffsetY?: number;
  faceOffsetZ?: number;
  collideRadius?: number;   // visual only
  showCollider?: boolean;
    healthPct?: number;
  onVanish?: () => void;
};

export default function GhostPatrol7({
  y = 0.7,
  speed = 2.5,
  yawOffset = 0,
  scale = 1,
  debug = false,
  faceLight = true,
  faceLightIntensity = 1,
  faceLightDistance = 6,
  faceOffsetY = 2,
  faceOffsetZ = 0.02,
  collideRadius = 1.8,
  showCollider = false,
  onVanish,
    healthPct = 1,
}: Props) {
  const group = useRef<THREE.Group>(null);
  const ghostRoot = useRef<THREE.Group>(null);
  const culledFixedRef = useRef(false);
  const materialsLocalizedRef = useRef(false);


  // spawn at x:295, z:345
  const spawnX = 402;
  const spawnZ = 322;

  // 10s lifetime + 1m standoff
  const lifeSecRef = useRef(0);
  const vanishedRef = useRef(false);
  const minDistance = 1.0;

  useEffect(() => {
    if (!group.current) return;
    group.current.position.set(spawnX, y, spawnZ);
    group.current.rotation.y = yawOffset;
    vanishedRef.current = false;
    lifeSecRef.current = 0;
  }, [y, yawOffset]);
function GhostHitbox({
  size = [3, 5, 1.5],     // [width, height, depth] ‚Äî tweak per ghost scale
  center = [0, 4, 0],
}: { size?: [number, number, number]; center?: [number, number, number] }) {
  return (
    <mesh
      position={center}
      visible={false}                 // invisible but raycastable
      userData={{ isEntity: true }}   // <-- makes hits count as enemy
    >
      <boxGeometry args={size} />
      <meshBasicMaterial transparent opacity={0} depthWrite={false} />
    </mesh>
  );
}
  // disable frustum culling & make materials transparent-friendly
  useEffect(() => {
    let raf = 0;
    const apply = () => {
      const root = ghostRoot.current;
      if (!root) { raf = requestAnimationFrame(apply); return; }
      if (culledFixedRef.current) return;

      let found = 0;
      root.traverse((o: any) => {
        if (o?.isMesh || o?.isSkinnedMesh) {
          o.frustumCulled = false;
          found++;
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats) {
            if (!m) continue;
            if ("transparent" in m) m.transparent = true;
            if ("depthWrite" in m) m.depthWrite = false;
            if ("side" in m) m.side = THREE.DoubleSide;
          }
        }
      });
      if (!materialsLocalizedRef.current) {
  root.traverse((o: any) => {
    if (o?.isMesh || o?.isSkinnedMesh) {
      if (Array.isArray(o.material)) {
        o.material = o.material.map((m: any) =>
          m?.isMaterial && m.clone ? m.clone() : m
        );
      } else if (o.material?.isMaterial && o.material.clone) {
        o.material = o.material.clone();
      }
    }
  });
  materialsLocalizedRef.current = true;
}

      if (found > 0) culledFixedRef.current = true;
      else raf = requestAnimationFrame(apply);
    };
    raf = requestAnimationFrame(apply);
    return () => cancelAnimationFrame(raf);
  }, []);

  // ----- hard hide helper -----
const hardHide = () => {
  const g = group.current
  if (!g) return
  // Just hide this instance; do not remove() or edit materials.
  g.visible = false
}


  // smooth face
  const qTarget = useRef(new THREE.Quaternion());
  const eTmp = useRef(new THREE.Euler(0, 0, 0, "YXZ"));

  useFrame((_, dt) => {
    const g = group.current;
    if (!g) return;

    if (vanishedRef.current) return;

    lifeSecRef.current += dt;
    if (lifeSecRef.current >= 10) {
      vanishedRef.current = true;
      hardHide();
      onVanish?.();
      return;
    }

    // follow player but stop at 1m (no pushback ever)
    const { position: playerPos } = useAppStore.getState();
    if (playerPos) {
      const dx = playerPos.x - g.position.x;
      const dz = playerPos.z - g.position.z;
      const dist = Math.hypot(dx, dz);

      if (dist > minDistance) {
        const gap = dist - minDistance;
        const step = Math.min(speed * dt, gap);
        g.position.x += (dx / dist) * step;
        g.position.z += (dz / dist) * step;
      }

      if (dist > 1e-6) {
        const yaw = Math.atan2(dx, dz) + yawOffset;
        eTmp.current.set(0, yaw, 0, "YXZ");
        qTarget.current.setFromEuler(eTmp.current);
        const t = 1 - Math.exp(-8 * dt);
        g.quaternion.slerp(qTarget.current, t);
      }
    }
  });
function HealthBar({ pct = 1, y = 2.6 }: { pct?: number; y?: number }) {
  const barRef = React.useRef<THREE.Group>(null);

  // keep the bar facing the camera
  useFrame(({ camera }) => {
    if (barRef.current) {
      barRef.current.quaternion.copy(camera.quaternion);
    }
  });

  // clamp
  const p = Math.max(0, Math.min(1, pct));
  const W = 1.6;        // total width of the bar
  const H = 0.12;       // height
  const innerW = W * p; // red width

  return (
    <group ref={barRef} position={[0, y, 0]}>
      {/* background */}
      <mesh>
        <planeGeometry args={[W, H]} />
        <meshBasicMaterial color="black" />
      </mesh>
      {/* red foreground (anchor left) */}
      <mesh position={[(-W / 2) + (innerW / 2), 0, 0.001]}>
        <planeGeometry args={[innerW, H * 0.8]} />
        <meshBasicMaterial color="#ff3b3b" />
      </mesh>
    </group>
  );
}

  return (
    <group ref={group} position={[spawnX, y, spawnZ]} userData={{ isEntity: true, ghostId: 4 }}>
      
        <GhostHitbox size={[3, 5, 1.5]} center={[0, 4, 0]} />
      {debug && (
        <mesh position={[0, 0.5, 0]}>
          <boxGeometry args={[0.5, 1, 0.5]} />
          <meshBasicMaterial wireframe />
        </mesh>
      )}

      {showCollider && (
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[collideRadius, 24, 16]} />
          <meshBasicMaterial color="#ff0000" wireframe transparent opacity={0.25} />
        </mesh>
      )}

      {faceLight && (
        <group position={[0, faceOffsetY, faceOffsetZ]}>
          <mesh>
            <sphereGeometry args={[0.06, 16, 16]} />
            <meshBasicMaterial color="#ff2a2a" toneMapped={false} />
          </mesh>
          <pointLight color="#ff2a2a" intensity={faceLightIntensity} distance={faceLightDistance} decay={5} />
        </group>
      )}

      <group ref={ghostRoot} scale={scale} renderOrder={1}>
        <Ghost />
    </group>
    </group>
  );
}
</file>

<file path="src/models/Gun1.tsx">
// client/src/models/Gun1.tsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/gun1.glb 
Author: DJMaesen (https://sketchfab.com/bumstrum)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/animated-pistol-bd896167e7ca44f19597d3afe6a8d83f
Title: animated pistol
Converted to TypeScript
*/
import React from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    [key: string]: THREE.Mesh | THREE.Bone | THREE.Object3D;
    stopper_beretta_0: THREE.Mesh;
    bullet_2_2_beretta_0: THREE.Mesh;
    shell_beretta_0: THREE.Mesh;
    bullet_beretta_0: THREE.Mesh;
    shell_1_2_beretta_0: THREE.Mesh;
    mag_beretta_0: THREE.Mesh;
    hammer_beretta_0: THREE.Mesh;
    trigger_beretta_0: THREE.Mesh;
    slide_beretta_0: THREE.Mesh;
    base_beretta_0: THREE.Mesh;
    bullet_2_beretta_0: THREE.Mesh;
    shell_1_beretta_0: THREE.Mesh;
    _rootJoint: THREE.Bone;
    Object_83: THREE.SkinnedMesh;
  };
  materials: {
    [key: string]: THREE.Material;
    beretta: THREE.Material;
    arms: THREE.Material;
  };
};

interface ModelProps {
  [key: string]: any;
}

export function Model(props: ModelProps): JSX.Element {
  const group = React.useRef<THREE.Group>(null);
  const { scene }: GLTF = useGLTF("/gun1.glb");
  const clone: THREE.Object3D = React.useMemo(
    () => SkeletonUtils.clone(scene),
    [scene]
  );
  const { nodes, materials }: GLTFResult = useGraph(clone) as GLTFResult;
  // const { actions } = useAnimations(animations, group);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group
            name="105d2810571c4501ba07ac55c5582245fbx"
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          >
            <group name="Object_2">
              <group name="RootNode">
                <group name="Root" position={[0, 16.327, -8.923]}>
                  <group name="Object_5">
                    <group name="pistol" position={[0, -12.318, 25.913]}>
                      <group name="stopper" position={[1.26, 5.502, 5.615]}>
                        <mesh
                          name="stopper_beretta_0"
                          geometry={nodes.stopper_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                      <group
                        name="mag"
                        position={[0, -0.379, 0.406]}
                        rotation={[0.262, 0, 0]}
                      >
                        <group
                          name="shell"
                          position={[0, 7.4, -0.455]}
                          rotation={[-0.262, 0, 0]}
                        >
                          <group name="bullet_2_2" position={[0, 0, 0.935]}>
                            <mesh
                              name="bullet_2_2_beretta_0"
                              geometry={nodes.bullet_2_2_beretta_0.geometry}
                              material={materials.beretta}
                            />
                          </group>
                          <mesh
                            name="shell_beretta_0"
                            geometry={nodes.shell_beretta_0.geometry}
                            material={materials.beretta}
                          />
                        </group>
                        <group
                          name="shell_1_2"
                          position={[0, 6.293, -0.158]}
                          rotation={[-0.262, 0, 0]}
                        >
                          <group name="bullet" position={[0, 0, 0.935]}>
                            <mesh
                              name="bullet_beretta_0"
                              geometry={nodes.bullet_beretta_0.geometry}
                              material={materials.beretta}
                            />
                          </group>
                          <mesh
                            name="shell_1_2_beretta_0"
                            geometry={nodes.shell_1_2_beretta_0.geometry}
                            material={materials.beretta}
                          />
                        </group>
                        <mesh
                          name="mag_beretta_0"
                          geometry={nodes.mag_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                      <group
                        name="hammer"
                        position={[0, 5.573, -1.608]}
                        rotation={[-1.242, 0, 0]}
                      >
                        <mesh
                          name="hammer_beretta_0"
                          geometry={nodes.hammer_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                      <group name="trigger" position={[0, 4.404, 6.033]}>
                        <mesh
                          name="trigger_beretta_0"
                          geometry={nodes.trigger_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                      <group name="slide" position={[0, 7.341, 3.872]}>
                        <mesh
                          name="slide_beretta_0"
                          geometry={nodes.slide_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                      <group name="base">
                        <mesh
                          name="base_beretta_0"
                          geometry={nodes.base_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                      <group name="shell_1" position={[0, 7.849, 6.937]}>
                        <group name="bullet_2" position={[0, 0, 0.935]}>
                          <mesh
                            name="bullet_2_beretta_0"
                            geometry={nodes.bullet_2_beretta_0.geometry}
                            material={materials.beretta}
                          />
                        </group>
                        <mesh
                          name="shell_1_beretta_0"
                          geometry={nodes.shell_1_beretta_0.geometry}
                          material={materials.beretta}
                        />
                      </group>
                    </group>
                    <primitive object={nodes._rootJoint} />
                    <group name="Object_82" position={[0, 3.036, -1.334]} />
                    <skinnedMesh
                      name="Object_83"
                      geometry={nodes.Object_83.geometry}
                      material={materials.arms}
                      skeleton={nodes.Object_83.skeleton}
                    />
                  </group>
                </group>
                <group
                  name="armsmesh"
                  position={[0, 3.036, -1.334]}
                  rotation={[-0.002, 0, -0.011]}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/gun1.glb");
</file>

<file path="src/models/index.ts">
// 3D Models
export { Model as HallModel } from "./Bloccc";
export { Model as GunModel } from "./Gun1";
</file>

<file path="src/models/Pop.tsx">
// client/src/models/Pop.tsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: DJMaesen (https://sketchfab.com/bumstrum)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/animated-pistol-bd896167e7ca44f19597d3afe6a8d83f
Title: animated pistol
*/

import * as THREE from "three";
import React, {
  useRef,
  forwardRef,
  useImperativeHandle,
  useEffect,
  useMemo,
  useLayoutEffect,
  useState,
} from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    Object_83: THREE.SkinnedMesh;
    base_beretta_0: THREE.Mesh;
    stopper_beretta_0: THREE.Mesh;
    shell_1_beretta_0: THREE.Mesh;
    bullet_2_beretta_0: THREE.Mesh;
    mag_beretta_0: THREE.Mesh;
    shell_beretta_0: THREE.Mesh;
    bullet_2_2_beretta_0: THREE.Mesh;
    shell_1_2_beretta_0: THREE.Mesh;
    bullet_beretta_0: THREE.Mesh;
    hammer_beretta_0: THREE.Mesh;
    trigger_beretta_0: THREE.Mesh;
    slide_beretta_0: THREE.Mesh;
    _rootJoint: THREE.Bone;
  };
  materials: { arms: THREE.MeshStandardMaterial; beretta: THREE.MeshStandardMaterial };
};

export type PopHandle = {
  playPickup: () => void;
  playShoot: () => void;
  playReloadShort: () => void;
  playReloadLong: () => void;
};

type SegmentSpec = { start: number; end: number };
type SegmentMap = {
  pickup?: SegmentSpec;
  shoot?: SegmentSpec;
  reloadShort?: SegmentSpec;
  reloadLong?: SegmentSpec;
};

type Props = JSX.IntrinsicElements["group"] & {
  segments?: SegmentMap;
  clipNames?: { pickup?: string; shoot?: string; reloadShort?: string; reloadLong?: string };
};

const FPS_DEFAULT = 30;

function makeSubclip(
  base: THREE.AnimationClip,
  name: string,
  startSec: number,
  endSec: number,
  fps = FPS_DEFAULT
) {
  const startFrame = Math.max(0, Math.round(startSec * fps));
  const endFrame = Math.max(startFrame + 1, Math.round(endSec * fps));
  return THREE.AnimationUtils.subclip(base, name, startFrame, endFrame, fps);
}

function playOnce(action?: THREE.AnimationAction) {
  if (!action) return;
  const mixer = action.getMixer();
  // @ts-ignore internal
  mixer._actions?.forEach((a: THREE.AnimationAction) => a !== action && a.stop());
  action.reset();
  action.clampWhenFinished = true;
  action.setLoop(THREE.LoopOnce, 1);
  action.fadeIn(0.04).play();
}

const Pop = forwardRef<PopHandle, Props>(function Pop({ segments, clipNames, ...props }, ref) {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF("/gun1.glb") as GLTFResult;
  const { actions, mixer } = useAnimations(animations, group);

  // Wait until the <group> ref is attached so mixer has a valid root
  const [ready, setReady] = useState(false);
  useEffect(() => {
    if (!ready && group.current) setReady(true);
  }, [ready]);

  useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      console.log(
        "[Pop] clips:",
        animations.map((c) => ({ name: c.name, dur: c.duration.toFixed(2) }))
      );
    }
  }, [animations]);

  const unified = useMemo(() => {
    // If the group isn‚Äôt mounted or mixer not present yet, avoid creating actions
    if (!ready || !group.current || !mixer) {
      return { pickup: undefined, shoot: undefined, reloadShort: undefined, reloadLong: undefined };
    }

    // Helper to fetch action by fuzzy name from existing actions (if GLB already split clips)
    const getNamed = (hints: string[]): THREE.AnimationAction | undefined => {
      const entries = Object.entries(actions ?? {});
      for (const [name, act] of entries) if (hints.includes(name)) return act!;
      for (const [name, act] of entries) {
        const low = name.toLowerCase();
        if (hints.some((h) => low.includes(h.toLowerCase()))) return act!;
      }
      return undefined;
    };

    const pickupA =
      (clipNames?.pickup && actions[clipNames.pickup]) ||
      getNamed(["pickup", "draw", "cock", "equip", "ready", "rack", "inspect"]);

    const shootA =
      (clipNames?.shoot && actions[clipNames.shoot]) ||
      getNamed(["shoot", "fire", "shot", "attack", "pistol"]);

    const shortA =
      (clipNames?.reloadShort && actions[clipNames.reloadShort]) ||
      getNamed(["reload short", "tac", "tactical", "reload"]);

    const longA =
      (clipNames?.reloadLong && actions[clipNames.reloadLong]) ||
      getNamed(["reload empty", "reload long", "empty", "from empty", "reload2", "long"]);

    // If model already ships separate clips, use them
    if (pickupA || shootA || shortA || longA) {
      return { pickup: pickupA, shoot: shootA, reloadShort: shortA, reloadLong: longA };
    }

    // Otherwise derive subclips from the first base clip (e.g., "allanimations")
    const base = animations[0];
    if (!base) {
      return { pickup: undefined, shoot: undefined, reloadShort: undefined, reloadLong: undefined };
    }
    const D = base.duration || 2.5;

    const seg = {
      pickup: segments?.pickup ?? { start: 0.0 * D, end: 0.18 * D },
      shoot: segments?.shoot ?? { start: 0.18 * D, end: 0.31 * D },
      reloadShort: segments?.reloadShort ?? { start: 0.35 * D, end: 0.66 * D },
      reloadLong: segments?.reloadLong ?? { start: 0.35 * D, end: 0.66 * D },
    };

    const clipPickup = makeSubclip(base, "pickup_sub", seg.pickup.start, seg.pickup.end);
    const clipShoot = makeSubclip(base, "shoot_sub", seg.shoot.start, seg.shoot.end);
    const clipShort = makeSubclip(base, "reloadS_sub", seg.reloadShort.start, seg.reloadShort.end);
    const clipLong = makeSubclip(base, "reloadL_sub", seg.reloadLong.start, seg.reloadLong.end);

    // Now safe to create actions; pass explicit root (group.current) just to be explicit
    const pickup = mixer.clipAction(clipPickup, group.current);
    const shoot = mixer.clipAction(clipShoot, group.current);
    const reloadShort = mixer.clipAction(clipShort, group.current);
    const reloadLong = mixer.clipAction(clipLong, group.current);

    return { pickup, shoot, reloadShort, reloadLong };
  }, [actions, animations, mixer, segments, clipNames, ready]);

  // Stop everything on unmount
  useEffect(() => {
    return () => {
      mixer?.stopAllAction();
    };
  }, [mixer]);

  // Clear any residual actions when mounted
  useLayoutEffect(() => {
    mixer?.stopAllAction();
  }, [mixer]);

  useImperativeHandle(ref, () => ({
    playPickup: () => playOnce(unified.pickup),
    playShoot: () => playOnce(unified.shoot),
    playReloadShort: () => playOnce(unified.reloadShort ?? unified.reloadLong),
    playReloadLong: () => playOnce(unified.reloadLong ?? unified.reloadShort),
  }));

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="105d2810571c4501ba07ac55c5582245fbx" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <group name="Object_2">
              <group name="RootNode">
                <group name="Root" position={[0, 16.327, -8.923]}>
                  <group name="Object_5">
                    <primitive object={nodes._rootJoint} />
                    <skinnedMesh
                      name="Object_83"
                      geometry={nodes.Object_83.geometry}
                      material={materials.arms}
                      skeleton={nodes.Object_83.skeleton}
                    />
                    <group name="pistol" position={[0, -12.318, 25.913]}>
                      <group name="base">
                        <mesh name="base_beretta_0" castShadow receiveShadow geometry={nodes.base_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name="stopper" position={[1.26, 5.502, 5.615]}>
                        <mesh name="stopper_beretta_0" castShadow receiveShadow geometry={nodes.stopper_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name="shell_1" position={[0, 7.849, 6.937]}>
                        <mesh name="shell_1_beretta_0" castShadow receiveShadow geometry={nodes.shell_1_beretta_0.geometry} material={materials.beretta} />
                        <group name="bullet_2" position={[0, 0, 0.935]}>
                          <mesh name="bullet_2_beretta_0" castShadow receiveShadow geometry={nodes.bullet_2_beretta_0.geometry} material={materials.beretta} />
                        </group>
                      </group>
                      <group name="mag" position={[0, -0.379, 0.406]} rotation={[0.262, 0, 0]}>
                        <mesh name="mag_beretta_0" castShadow receiveShadow geometry={nodes.mag_beretta_0.geometry} material={materials.beretta} />
                        <group name="shell" position={[0, 7.4, -0.455]} rotation={[-0.262, 0, 0]}>
                          <mesh name="shell_beretta_0" castShadow receiveShadow geometry={nodes.shell_beretta_0.geometry} material={materials.beretta} />
                          <group name="bullet_2_2" position={[0, 0, 0.935]}>
                            <mesh name="bullet_2_2_beretta_0" castShadow receiveShadow geometry={nodes.bullet_2_2_beretta_0.geometry} material={materials.beretta} />
                          </group>
                        </group>
                        <group name="shell_1_2" position={[0, 6.293, -0.158]} rotation={[-0.262, 0, 0]}>
                          <mesh name="shell_1_2_beretta_0" castShadow receiveShadow geometry={nodes.shell_1_2_beretta_0.geometry} material={materials.beretta} />
                          <group name="bullet" position={[0, 0, 0.935]}>
                            <mesh name="bullet_beretta_0" castShadow receiveShadow geometry={nodes.bullet_beretta_0.geometry} material={materials.beretta} />
                          </group>
                        </group>
                      </group>
                      <group name="hammer" position={[0, 5.573, -1.608]} rotation={[-1.242, 0, 0]}>
                        <mesh name="hammer_beretta_0" castShadow receiveShadow geometry={nodes.hammer_beretta_0.geometry} material={materials.beretta} />
                      </group>

                      <group name="trigger" position={[0, 4.404, 6.033]}>
                        <mesh name="trigger_beretta_0" castShadow receiveShadow geometry={nodes.trigger_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name="slide" position={[0, 7.341, 3.872]}>
                        <mesh name="slide_beretta_0" castShadow receiveShadow geometry={nodes.slide_beretta_0.geometry} material={materials.beretta} />
                      </group>
                    </group>
                    <group name="Object_82" position={[0, 3.036, -1.334]} />
                  </group>
                </group>
                <group name="armsmesh" position={[0, 3.036, -1.334]} rotation={[-0.002, 0, -0.011]} />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
});

export default Pop;

useGLTF.preload("/gun1.glb");
</file>

<file path="src/models/Shotgun.tsx">
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: iedalton (https://sketchfab.com/iedalton)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/shotgun-b427092de61d4a0ca5943e56458eb83d
Title: Shotgun
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import MuzzleFlash from "../components/game/MuzzleFlash";

type GLTFResult = GLTF & {
  nodes: {
    defaultMaterial: THREE.Mesh
    defaultMaterial_1: THREE.Mesh
    defaultMaterial_2: THREE.Mesh
  }
  materials: {
    Metal01: THREE.MeshStandardMaterial
    Wood_001: THREE.MeshStandardMaterial
    DarkSteel: THREE.MeshStandardMaterial
  }
}

export function Shotgun(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF("/shotgun.glb") as GLTFResult
  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial.geometry}
            material={materials.Metal01}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_1.geometry}
            material={materials.Wood_001}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_2.geometry}
            material={materials.DarkSteel}
          />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload("/shotgun.glb")
</file>

<file path="src/models/Shotgunshoot.tsx">
// client/src/components/game/ShotgunShoot.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import * as THREE from "three";
import { useFrame, useThree } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import useAppStore from "../zustand/store";
import MuzzleFlash from "../components/game/MuzzleFlash";

type ActionName =
  | "Armature|SG_FPS_Idle"
  | "Armature|SG_FPS_Walk"
  | "Armature|SG_FPS_Shot"
  | "Armature|SG_FPS_Reload";
type GLTFActions = Record<ActionName, THREE.AnimationAction>;

type ShotgunShootProps = {
  muzzleFlashTrigger?: number;
  isVisible?: boolean;
  onShoot?: (hit: THREE.Intersection, cameraPos: THREE.Vector3) => void;
};

export default function ShotgunShoot({ isVisible, onShoot, muzzleFlashTrigger }: ShotgunShootProps) {
  // --- MUZZLE FLASH ---
const muzzleRef = useRef<THREE.Group>(null);
/** bump this to trigger a flash */
const [flashKick, setFlashKick] = useState(0);
const trigger = (muzzleFlashTrigger ?? 0) + flashKick;

  const group = useRef<THREE.Group>(null);
  const { camera, scene } = useThree();
const showGunStore = useAppStore((s) => s.showGun);
const shouldShow = isVisible ?? showGunStore;

  // --- load animated rig (hands + shotgun) ---
  const gltf = useGLTF("/shotgunshoot.glb");
  const { actions, mixer } = useAnimations(gltf.animations, group) as { actions: Partial<GLTFActions>; mixer?: THREE.AnimationMixer };

  // --- ammo state (coach gun style 2+reserve) + HUD events ---
  const MAG_SIZE = 4;
  const RELOAD_SPEED = 1.4; // 1 = normal, >1 = faster

  const [mag, setMag] = useState(4);
  const [reserve, setReserve] = useState(8);

  const magRef = useRef(mag);
  const resRef = useRef(reserve);
  useEffect(() => { magRef.current = mag; }, [mag]);
  useEffect(() => { resRef.current = reserve; }, [reserve]);

  const [reloading, setReloading] = useState(false);
  useEffect(() => {
    window.dispatchEvent(new CustomEvent("hud:reloading", { detail: { reloading } }));
  }, [reloading]);
  useEffect(() => {
    window.dispatchEvent(new CustomEvent("hud:ammo", { detail: { mag, reserve } }));
  }, [mag, reserve]);

  useEffect(() => {
    const onAddAmmo = (e: Event) => {
      const ce = e as CustomEvent<{ amount?: number }>;
      const add = Math.max(0, Number(ce?.detail?.amount ?? 0));
      if (add) setReserve(r => r + add);
    };
    window.addEventListener("gun:addAmmo", onAddAmmo as EventListener);
    return () => window.removeEventListener("gun:addAmmo", onAddAmmo as EventListener);
  }, []);

  // --- animation helpers (cross-fade between states) ---
  const current = useRef<ActionName | null>(null);
  const fadeTo = (name: ActionName, fade = 0.12, loop: THREE.AnimationActionLoopStyles = THREE.LoopRepeat) => {
    const next = actions?.[name];
    if (!next) return;
    if (current.current && current.current !== name) {
      actions![current.current]?.fadeOut(fade);
    }
    next.reset().setLoop(loop, Infinity).fadeIn(fade).play();
    current.current = name;
  };

  const playIdle = () => fadeTo("Armature|SG_FPS_Idle");
  // const playWalk = () => fadeTo("Armature|SG_FPS_Walk");
  const playShot = () => {
    const act = actions?.["Armature|SG_FPS_Shot"];
    if (!act) return;
    if (current.current) actions![current.current]!.fadeOut(0.06);
    act.reset().setLoop(THREE.LoopOnce, 1).fadeIn(0.06).play();
    const dur = act.getClip().duration;
    setTimeout(() => playIdle(), (dur * 1000) - 40);
  };
 const playReload = (onDone?: () => void) => {
  const act = actions?.["Armature|SG_FPS_Reload"];
  if (!act) { onDone?.(); return; }
  if (current.current) actions![current.current]!.fadeOut(0.06);

  act.reset();
  act.timeScale = RELOAD_SPEED; // speed up reload
  act.setLoop(THREE.LoopOnce, 1).fadeIn(0.06).play();

  const clipDur = act.getClip().duration / RELOAD_SPEED; // adjust for speed
  const ms = Math.max(0, (clipDur * 1000) - 40);
  setTimeout(() => { onDone?.(); playIdle(); }, ms);
};

  // start in Idle when the weapon is shown
  const shownOnce = useRef(false);
  useEffect(() => {
    if (shouldShow && !shownOnce.current) {
      playIdle();
      shownOnce.current = true;
    }
  }, [shouldShow]);

  // --- left click shoot ---
  const ray = useMemo(() => new THREE.Raycaster(), []);
  const center = useMemo(() => new THREE.Vector2(0, 0), []);
  useEffect(() => {
    const onDown = (e: MouseEvent) => {
      if (e.button !== 0) return;
      if (!shouldShow || reloading) return;
           if (magRef.current <= 0) {
        beginReload();      // auto-reload if empty
        return;
      }


      // consume a shell
      setMag(m => Math.max(0, m - 1));
      playShot();

      // raycast
      ray.setFromCamera(center, camera);
      const hits = ray.intersectObjects(scene.children, true);
      const first = hits[0];
      // trigger muzzle flash
setFlashKick((n) => n + 1);

      if (first) onShoot?.(first, camera.position.clone());

    };
    window.addEventListener("mousedown", onDown);
    return () => window.removeEventListener("mousedown", onDown);
  }, [shouldShow, reloading, camera, scene, onShoot, ray, center]);


    // Centralized reload logic (fills up to MAG_SIZE)
  const beginReload = () => {
    if (reloading) return;
    if (magRef.current >= MAG_SIZE) return;
    if (resRef.current <= 0) return;

    setReloading(true);
    playReload(() => {
      const need = MAG_SIZE - magRef.current;
      const take = Math.min(need, resRef.current);
      setMag(m => m + take);
      setReserve(r => r - take);
      setReloading(false);
    });
  };

  // --- R reload (manual) ---
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if ((e.key.toLowerCase?.() === "r" || e.code === "KeyR")) {
        beginReload();
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [reloading]);
  // Auto-reload as soon as the magazine is empty and we have reserve
  useEffect(() => {
    if (!shouldShow) return;
    if (reloading) return;
    if (mag === 0 && reserve > 0) beginReload();
  }, [mag, reserve, reloading, shouldShow]);


  // --- anchor weapon to camera with slight sway ---
  const base = new THREE.Vector3(0.15, -0.28, -0.05); // screen placement
  const tmp = new THREE.Vector3();
  const prevPlayer = useRef<THREE.Vector3 | null>(null);
  const walkTimer = useRef<number>(0);
 useFrame((_, dt) => {
  if (!group.current) return;

  // attach to camera
group.current.position.copy(camera.position);
tmp.copy(base).applyQuaternion(camera.quaternion);
group.current.position.add(tmp);
group.current.quaternion.copy(camera.quaternion);

  // ‚úÖ read the latest position WITHOUT subscribing/re-rendering
  const p = useAppStore.getState().position;

  if (!prevPlayer.current) {
    prevPlayer.current = new THREE.Vector3(p.x, p.y ?? 0, p.z);
  }
  const speed =
    prevPlayer.current.distanceTo(new THREE.Vector3(p.x, p.y ?? 0, p.z)) /
    Math.max(dt, 1e-4);
  prevPlayer.current.set(p.x, p.y ?? 0, p.z);

  const moving = speed > 0.3;
  if (!reloading && shouldShow) {
    if (moving) {
      walkTimer.current += dt;
      // if (current.current !== "Armature|SG_FPS_Walk") playWalk();
    } else {
      if (current.current !== "Armature|SG_FPS_Idle") playIdle();
    }
  }
});


  if (!shouldShow) return null;

return (
  <group ref={group} dispose={null}>
    {/* rotate the rig 180¬∞ around Y */}
    <group rotation={[0, Math.PI, 0]}>
      <primitive object={(gltf as any).scene} />
            {/* muzzle flash ‚Äî tweak position to your muzzle */}
      <group ref={muzzleRef} position={[0.22, -0.06, -0.6]}>
        <MuzzleFlash trigger={trigger} />
      </group>

    </group>
  </group>
);

}

useGLTF.preload("/shotgunshoot.glb");
</file>

<file path="src/models/Table.tsx">
// client/src/models/Table.tsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 table.glb --types 
*/
import * as THREE from "three";
import React from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

// read showGun from store to hide props after pickup (pure UI)
import useAppStore from "../zustand/store";

type GLTFResult = GLTF & {
  nodes: {
    Object_8002: THREE.Mesh;
    Object_6002: THREE.Mesh;
    Object_9: THREE.Mesh;
    Object_4004: THREE.Mesh;
    defaultMaterial: THREE.Mesh;
    defaultMaterial001: THREE.Mesh;
    Object_6003: THREE.Mesh;
    Object_8014: THREE.Mesh;
    Object_4005: THREE.Mesh;
    Object_4006: THREE.Mesh;
  };
  materials: {
    Table_Kitchen_A: THREE.MeshStandardMaterial;
    bullet_holder: THREE.MeshStandardMaterial;
    ammo_body: THREE.MeshStandardMaterial;
    ["material.005"]: THREE.MeshStandardMaterial;
    Material_001: THREE.MeshStandardMaterial;
    ["Material.039"]: THREE.MeshStandardMaterial;
    ["bullet_holder.001"]: THREE.MeshStandardMaterial;
    ["bullet_bottom.001"]: THREE.MeshStandardMaterial;
    ["material.006"]: THREE.MeshStandardMaterial;
    ["material.003"]: THREE.MeshStandardMaterial;
  };
};

export function Table(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/table.glb") as GLTFResult;
  const showGun = useAppStore((s) => s.showGun); // becomes true after pressing T

  return (
    <group {...props} dispose={null}>
      {/* Main table */}
      <mesh
        geometry={nodes.Object_8002.geometry}
        material={materials.Table_Kitchen_A}
        position={[-2.272, 0, -8.66]}
        rotation={[Math.PI, 0, Math.PI]}
      />

      {/* Hide the small props once the gun is picked up */}
      {!showGun && (
        <>
          <mesh
            geometry={nodes.Object_6002.geometry}
            material={materials.bullet_holder}
            position={[-1.897, 0.79, -8.356]}
            rotation={[0, -0.759, 0]}
            scale={[0.037, 0.011, 0.056]}
          />
          <mesh
            geometry={nodes.Object_9.geometry}
            material={materials.ammo_body}
            position={[-1.595, 0.779, -8.488]}
            rotation={[0, -0.759, 0]}
            scale={[0.132, 0.093, 0.124]}
          />
          <mesh
            geometry={nodes.Object_4004.geometry}
            material={materials["material.005"]}
            position={[-1.818, 0.804, -8.439]}
            rotation={[Math.PI / 2, 0, 0.759]}
            scale={[0.151, 0.116, 0.106]}
          />
          <mesh
            geometry={nodes.defaultMaterial.geometry}
            material={materials.Material_001}
            position={[-1.789, 0.798, -8.619]}
            rotation={[-3.065, -0.739, 0]}
            scale={[0.081, 0.107, 0.086]}
          />
          <mesh
            geometry={nodes.defaultMaterial001.geometry}
            material={materials["Material.039"]}
            position={[-1.789, 0.8, -8.619]}
            rotation={[-3.065, -0.739, 0]}
            scale={[0.081, 0.107, 0.086]}
          />
          <mesh
            geometry={nodes.Object_6003.geometry}
            material={materials["bullet_holder.001"]}
            position={[-1.7, 0.782, -8.364]}
            rotation={[0, 0.455, 0]}
            scale={[0.037, 0.011, 0.056]}
          />
          <mesh
            geometry={nodes.Object_8014.geometry}
            material={materials["bullet_bottom.001"]}
            position={[-1.685, 0.783, -8.33]}
            rotation={[0, 0.455, 0]}
            scale={[0.132, 0.093, 0.124]}
          />
          <mesh
            geometry={nodes.Object_4005.geometry}
            material={materials["material.006"]}
            position={[-1.456, 0.8, -8.816]}
            rotation={[Math.PI / 2, 0, -0.455]}
            scale={[0.151, 0.116, 0.106]}
          />
          <mesh
            geometry={nodes.Object_4006.geometry}
            material={materials["material.003"]}
            position={[-1.401, 0.81, -8.241]}
            rotation={[Math.PI / 2, 0, 2.569]}
            scale={[0.151, 0.116, 0.106]}
          />
        </>
      )}
    </group>
  );
}

useGLTF.preload("/table.glb");
export default Table;
</file>

<file path="src/types/game.ts">
import { Vector3 } from "three";
import * as THREE from "three";

// Core game interfaces
export interface WarningDialogProps {
  onAccept: () => void;
}

export interface Keys {
  forward: boolean;
  backward: boolean;
  left: boolean;
  right: boolean;
}

export interface FirstPersonControlsProps {
  onPositionUpdate?: (position: Vector3) => void;
  onRotationUpdate?: (rotation: number) => void; // New prop for rotation updates
}

export type GunProps = {
  isVisible?: boolean;
  onShoot?: (hit: THREE.Intersection, cameraPosition: THREE.Vector3) => void;
  canShoot?: boolean;
};


export interface RoomNotificationProps {
  roomNumber: number;
  onClose: () => void;
}

export interface EnemyProps {
  position: [number, number, number];
  roomNumber: number;
  onDeath: (roomNumber: number) => void;
  onPlayerDetected?: () => void;
}

export interface RoomDetectorProps {
  playerPosition: Vector3 | null;
  onRoomEnter: (roomNumber: number) => void;
}

export interface BloodEffectProps {
  position: Vector3;
  onComplete: () => void;
}

export interface BulletHoleProps {
  position: Vector3;
  normal: Vector3;
  cameraPosition: Vector3;
  onComplete: () => void;
}



// Data structures
export interface RoomBounds {
  x: [number, number];
  z: [number, number];
}

export interface EnemyData {
  roomNumber: number;
  position: [number, number, number];
  id: number;
}

export interface BloodEffect {
  id: number;
  position: Vector3;
}

export interface BulletHole {
  id: number;
  position: Vector3;
  normal: Vector3;
  cameraPosition: Vector3;
}

export interface Keys {
  forward: boolean;
  backward: boolean;
  left: boolean;
  right: boolean;
}

// --- UI-only helpers for ammo/reload overlays ---
export type GunUiState = {
  gunAmmo?: number;
  gunMag?: number;
  gunReloading?: boolean;
};
</file>

<file path="src/utils/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src/zustand/store.ts">
import { create } from "zustand";
import { persist } from "zustand/middleware";
import * as models from "../dojo/models.gen";

enum GamePhase {
  UNINITIALIZED = "uninitialized",
  INITIALIZED = "initialized",
  ACTIVE = "active",
  COMPLETED = "completed",
  GAME_OVER = "game_over",
}

interface AppState {
  // Core player data (from blockchain)
  player: models.Player | null;
  playerStats: models.PlayerStats | null;
  gameSession: models.GameSession | null;
  gameConfig: models.GameConfig | null;

  // Current room and world state
  currentRoom: models.Room | null;
  rooms: Map<string, models.Room>;
  entities: models.Entity[];
  entityStates: models.EntityState[];
  shardLocations: models.ShardLocation[];

  // Door state
  nearbyDoors: any[];

  // Game state
  gamePhase: GamePhase;
  isPlayerInitialized: boolean;
  canTakeActions: boolean;
  actionsThisTurn: number; // Add this back
  maxActionsPerTurn: number; // Add this back

  // Recent events (for UI feedback and animations)
  recentEvents: {
    gameStarted: models.GameStarted[];
    gameCompleted: models.GameCompleted[];
    victoriesAchieved: models.VictoryAchieved[];
    roomsCleared: models.RoomCleared[];
    roomsEntered: models.RoomEntered[];
    roomsExited: models.RoomExited[];
    playerDeaths: models.PlayerDeath[];
    shardsCollected: models.NumberedShardCollected[];
  };

  // UI/UX state
  isLoading: boolean;
  error: string | null;
  lastTransaction: string | null;
  actionInProgress: boolean;
  connectionStatus: "connected" | "connecting" | "disconnected";

  // Game statistics (derived from player data)
  gameStats: {
    currentHealth: number;
    maxHealth: number;
    currentShards: number;
    roomsCleared: number;
    turnNumber: number; // Add this back
    dodgeActiveTurns: number; // Add this back
    hasAllNumberedShards: boolean;
    hasKey: boolean;
    isAlive: boolean;
    gameActive: boolean;
    movementLocked: boolean; // Add this back
    specialAbilityCooldown: number;
  };

  // UI/Game state for 3D game compatibility
  gameStarted: boolean;
  showWarning: boolean;
  showGun: boolean;
  showCrosshair: boolean;
  showMapTracker: boolean;
  position: { x: number; y: number; z: number };
  rotation: number;
  moving: boolean;
  velocity: { x: number; y: number; z: number };
}

// Define actions interface
interface AppActions {
  // Core state setters (from blockchain data)
  setPlayer: (player: models.Player | null) => void;
  setPlayerStats: (stats: models.PlayerStats | null) => void;
  setGameSession: (session: models.GameSession | null) => void;
  setGameConfig: (config: models.GameConfig | null) => void;

  // World state management
  setCurrentRoom: (room: models.Room | null) => void;
  updateRoom: (room: models.Room) => void;
  setRooms: (rooms: models.Room[]) => void;
  setNearbyDoors: (doors: any[]) => void;
  setEntities: (entities: models.Entity[]) => void;
  updateEntity: (entity: models.Entity) => void;
  removeEntity: (entityId: string) => void;

  setEntityStates: (states: models.EntityState[]) => void;
  updateEntityState: (state: models.EntityState) => void;

  setShardLocations: (locations: models.ShardLocation[]) => void;
  updateShardLocation: (location: models.ShardLocation) => void;

  // Game state management
  setGamePhase: (phase: GamePhase) => void;
  setPlayerInitialized: (initialized: boolean) => void;
  setCanTakeActions: (can: boolean) => void;
  setActionsThisTurn: (count: number) => void; // Add this back
  incrementActionsThisTurn: () => void; // Add this back
  resetActionsThisTurn: () => void; // Add this back

  // Event handling (for UI feedback)
  addGameStarted: (event: models.GameStarted) => void;
  addGameCompleted: (event: models.GameCompleted) => void;
  addVictoryAchieved: (event: models.VictoryAchieved) => void;
  addRoomCleared: (event: models.RoomCleared) => void;
  addRoomEntered: (event: models.RoomEntered) => void;
  addRoomExited: (event: models.RoomExited) => void;
  addPlayerDeath: (event: models.PlayerDeath) => void;
  addShardCollected: (event: models.NumberedShardCollected) => void;
  clearRecentEvents: () => void;

  // UI actions
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setLastTransaction: (txHash: string | null) => void;
  setActionInProgress: (inProgress: boolean) => void;
  setConnectionStatus: (
    status: "connected" | "connecting" | "disconnected"
  ) => void;

  // Game lifecycle
  initializeGame: () => void;
  startNewGame: () => void;
  endGame: () => void;
  respawnPlayer: () => void;
  resetGame: () => void;

  // UI/Game actions for 3D game compatibility
  startGame: () => void;
  hideWarning: () => void;
  setShowWarning: (show: boolean) => void;
  setShowGun: (show: boolean) => void;
  setShowCrosshair: (show: boolean) => void;
  setShowMapTracker: (show: boolean) => void;
  updatePosition: (position: { x: number; y: number; z: number }) => void;
  updateRotation: (rotation: number) => void;
  setMoving: (moving: boolean) => void;
  setVelocity: (velocity: { x: number; y: number; z: number }) => void;

  // Utility getters
  canMove: () => boolean;
  canAttack: () => boolean;
  canCollectShard: (roomId: string, shardId: string) => boolean | undefined;
  getEntitiesInCurrentRoom: () => models.Entity[];
  getShardsInCurrentRoom: () => models.ShardLocation[];
  getRoomById: (roomId: string) => models.Room | null;
  getEntityById: (entityId: string) => models.Entity | null;
  hasNumberedShard: (shardType: models.NumberedShardEnum) => boolean;
  isRoomCleared: (roomId: string) => boolean;
  getActionsRemaining: () => number; // Add this function
}

// Combine state and actions
type AppStore = AppState & AppActions;

// Helper to update game stats from player data
const updateGameStats = (
  player: models.Player | null
): AppState["gameStats"] => {
  if (!player) {
    return {
      currentHealth: 0,
      maxHealth: 0,
      currentShards: 0,
      roomsCleared: 0,
      turnNumber: 0,
      dodgeActiveTurns: 0,
      hasAllNumberedShards: false,
      hasKey: false,
      isAlive: false,
      gameActive: false,
      movementLocked: false,
      specialAbilityCooldown: 0,
    };
  }

  return {
    currentHealth: Number(player.health),
    maxHealth: Number(player.max_health),
    currentShards: Number(player.shards),
    roomsCleared: Number(player.rooms_cleared),
    turnNumber: 1, // Default value since turn-based removed
    dodgeActiveTurns: 0, // Default value
    hasAllNumberedShards:
      player.has_shard_one && player.has_shard_two && player.has_shard_three,
    hasKey: player.has_key,
    isAlive: player.is_alive,
    gameActive: player.game_active,
    movementLocked: false, // Default value
    specialAbilityCooldown: Number(player.special_ability_cooldown),
  };
};

// Helper to determine game phase based on state
const determineGamePhase = (
  player: models.Player | null,
  gameSession: models.GameSession | null
): GamePhase => {
  if (!player) return GamePhase.UNINITIALIZED;

  if (!player.is_alive) return GamePhase.GAME_OVER;

  if (gameSession?.victory_achieved) return GamePhase.COMPLETED;

  if (gameSession?.session_complete && !gameSession.victory_achieved)
    return GamePhase.GAME_OVER;

  if (player.game_active) return GamePhase.ACTIVE;

  return GamePhase.INITIALIZED;
};

// Initial state
const initialState: AppState = {
  // Core data
  player: null,
  playerStats: null,
  gameSession: null,
  gameConfig: null,

  // World state
  currentRoom: null,
  rooms: new Map(),
  entities: [],
  entityStates: [],
  shardLocations: [],
  nearbyDoors: [],
  // Game state
  gamePhase: GamePhase.UNINITIALIZED,
  isPlayerInitialized: false,
  canTakeActions: false,
  actionsThisTurn: 0,
  maxActionsPerTurn: 3, // Default value

  // Events (limited recent history for UI feedback)
  recentEvents: {
    gameStarted: [],
    gameCompleted: [],
    victoriesAchieved: [],
    roomsCleared: [],
    roomsEntered: [],
    roomsExited: [],
    playerDeaths: [],
    shardsCollected: [],
  },

  // UI state
  isLoading: false,
  error: null,
  lastTransaction: null,
  actionInProgress: false,
  connectionStatus: "disconnected",

  // Stats
  gameStats: {
    currentHealth: 0,
    maxHealth: 0,
    currentShards: 0,
    roomsCleared: 0,
    turnNumber: 0,
    dodgeActiveTurns: 0,
    hasAllNumberedShards: false,
    hasKey: false,
    isAlive: false,
    gameActive: false,
    movementLocked: false,
    specialAbilityCooldown: 0,
  },

  // UI/Game state for 3D game compatibility
  gameStarted: false,
  showWarning: true,
  showGun: false,
  showCrosshair: true,
  showMapTracker: true,
  position: { x: 400, y: 1.5, z: 400 },
  rotation: 0,
  moving: false,
  velocity: { x: 0, y: 0, z: 0 },
};

// Maximum recent events to keep (for performance)
const MAX_RECENT_EVENTS = 50;

// Create the store
const useAppStore = create<AppStore>()(
  persist(
    (set, get) => ({
      // Initial state
      ...initialState,

      // Core state setters
      setPlayer: (player) =>
        set((state) => {
          const gameStats = updateGameStats(player);
          const gamePhase = determineGamePhase(player, state.gameSession);
          const canTakeActions = player?.game_active && player?.is_alive;

          return {
            player,
            gameStats,
            gamePhase,
            canTakeActions: canTakeActions || false,
          };
        }),

      setPlayerStats: (playerStats) => {
        const isPlayerInitialized = playerStats !== null;
        set({
          playerStats,
          isPlayerInitialized,
        });
      },

      setGameSession: (gameSession) =>
        set((state) => {
          const gamePhase = determineGamePhase(state.player, gameSession);
          return { gameSession, gamePhase };
        }),

      setGameConfig: (gameConfig) =>
        set({
          gameConfig,
          maxActionsPerTurn: gameConfig ? 3 : 3, // Set default since no actions per turn in new model
        }),

      // World state management
      setCurrentRoom: (currentRoom) => set({ currentRoom }),

      updateRoom: (room) =>
        set((state) => {
          const newRooms = new Map(state.rooms);
          newRooms.set(room.room_id.toString(), room);

          // Update current room if it matches
          const currentRoom =
            state.currentRoom?.room_id.toString() === room.room_id.toString()
              ? room
              : state.currentRoom;

          return { rooms: newRooms, currentRoom };
        }),

      setRooms: (rooms) =>
        set(() => {
          const roomMap = new Map(rooms.map((r) => [r.room_id.toString(), r]));
          return { rooms: roomMap };
        }),
      setNearbyDoors: (nearbyDoors) => set({ nearbyDoors }),
      setEntities: (entities) =>
        set(() => {
          console.log("entities update in zustand", entities);
          return { entities: entities };
        }),

      // Fixed updateEntity - update existing or add new
      updateEntity: (entity) =>
        set((state) => {
          const entityId = entity.entity_id.toString();
          const entities = state.entities.filter(
            (e) => e.entity_id.toString() !== entityId
          );
          return { entities: [...entities, entity] };
        }),

      // Fixed removeEntity - proper ID comparison
      removeEntity: (entityId) =>
        set((state) => ({
          entities: state.entities.filter(
            (e) => e.entity_id.toString() !== entityId.toString()
          ),
        })),

      // Fixed updateShardLocation - update existing or add new
      updateShardLocation: (location) =>
        set((state) => {
          const shardId = location.shard_id.toString();
          const shards = state.shardLocations.filter(
            (s) => s.shard_id.toString() !== shardId
          );
          return { shardLocations: [...shards, location] };
        }),

      // Fixed updateEntityState - update existing or add new
      updateEntityState: (entityState) =>
        set((state) => {
          const entityId = entityState.entity_id.toString();
          const states = state.entityStates.filter(
            (s) => s.entity_id.toString() !== entityId
          );
          return { entityStates: [...states, entityState] };
        }),

      setEntityStates: (states) =>
        set(() => {
          return { entityStates: states };
        }),

      setShardLocations: (locations) =>
        set(() => {
          return { shardLocations: locations };
        }),

      // Game state management
      setGamePhase: (gamePhase) => set({ gamePhase }),
      setPlayerInitialized: (isPlayerInitialized) =>
        set({ isPlayerInitialized }),
      setCanTakeActions: (canTakeActions) => set({ canTakeActions }),
      setActionsThisTurn: (actionsThisTurn) => set({ actionsThisTurn }),
      incrementActionsThisTurn: () =>
        set((state) => ({ actionsThisTurn: state.actionsThisTurn + 1 })),
      resetActionsThisTurn: () => set({ actionsThisTurn: 0 }),

      // Event handling (keep recent events for UI feedback)
      addGameStarted: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            gameStarted: [
              ...state.recentEvents.gameStarted.slice(-MAX_RECENT_EVENTS + 1),
              event,
            ],
          },
          gamePhase: GamePhase.ACTIVE,
        })),

      addGameCompleted: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            gameCompleted: [
              ...state.recentEvents.gameCompleted.slice(-MAX_RECENT_EVENTS + 1),
              event,
            ],
          },
          gamePhase: GamePhase.COMPLETED,
        })),

      addVictoryAchieved: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            victoriesAchieved: [
              ...state.recentEvents.victoriesAchieved.slice(
                -MAX_RECENT_EVENTS + 1
              ),
              event,
            ],
          },
          gamePhase: GamePhase.COMPLETED,
        })),

      addRoomCleared: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            roomsCleared: [
              ...state.recentEvents.roomsCleared.slice(-MAX_RECENT_EVENTS + 1),
              event,
            ],
          },
        })),

      addRoomEntered: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            roomsEntered: [
              ...state.recentEvents.roomsEntered.slice(-MAX_RECENT_EVENTS + 1),
              event,
            ],
          },
        })),

      addRoomExited: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            roomsExited: [
              ...state.recentEvents.roomsExited.slice(-MAX_RECENT_EVENTS + 1),
              event,
            ],
          },
        })),

      addPlayerDeath: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            playerDeaths: [
              ...state.recentEvents.playerDeaths.slice(-MAX_RECENT_EVENTS + 1),
              event,
            ],
          },
          gamePhase: GamePhase.GAME_OVER,
        })),

      addShardCollected: (event) =>
        set((state) => ({
          recentEvents: {
            ...state.recentEvents,
            shardsCollected: [
              ...state.recentEvents.shardsCollected.slice(
                -MAX_RECENT_EVENTS + 1
              ),
              event,
            ],
          },
        })),

      clearRecentEvents: () =>
        set({
          recentEvents: {
            gameStarted: [],
            gameCompleted: [],
            victoriesAchieved: [],
            roomsCleared: [],
            roomsEntered: [],
            roomsExited: [],
            playerDeaths: [],
            shardsCollected: [],
          },
        }),

      // UI actions
      setLoading: (isLoading) => set({ isLoading }),
      setError: (error) => set({ error }),
      setLastTransaction: (lastTransaction) => set({ lastTransaction }),
      setActionInProgress: (actionInProgress) => set({ actionInProgress }),
      setConnectionStatus: (connectionStatus) => set({ connectionStatus }),

      // Game lifecycle
      initializeGame: () =>
        set({
          gamePhase: GamePhase.INITIALIZED,
          error: null,
          isLoading: true,
        }),

      startNewGame: () =>
        set({
          gamePhase: GamePhase.ACTIVE,
          error: null,
          actionsThisTurn: 0,
        }),

      endGame: () =>
        set({
          gamePhase: GamePhase.COMPLETED,
          canTakeActions: false,
        }),

      respawnPlayer: () =>
        set({
          gamePhase: GamePhase.ACTIVE,
          error: null,
          actionsThisTurn: 0,
        }),

      resetGame: () =>
        set({
          ...initialState,
          connectionStatus: get().connectionStatus, // Keep connection status
        }),

      // UI/Game actions for 3D game compatibility
      // Around line 620, update the startGame action:
      startGame: () =>
        set((state) => {
          console.log("üéÆ Starting game UI...");
          console.log("Previous state:", {
            gameStarted: state.gameStarted,
            gamePhase: state.gamePhase,
            playerGameActive: state.player?.game_active,
          });

          const newState = {
            gameStarted: true,
            showWarning: false,
            gamePhase: GamePhase.ACTIVE, // Always set to ACTIVE when starting UI
          };

          console.log("New state:", newState);
          return newState;
        }),

      hideWarning: () => set({ showWarning: false }),
      setShowWarning: (showWarning) => set({ showWarning }),
      setShowGun: (showGun) => set({ showGun }),
      setShowCrosshair: (showCrosshair) => set({ showCrosshair }),
      setShowMapTracker: (showMapTracker) => set({ showMapTracker }),

      updatePosition: (position) =>
        set((state) => {
          // Also update blockchain player position if available
          if (state.player) {
            return {
              position,
              player: {
                ...state.player,
                position: {
                  x: Math.round(position.x),
                  y: Math.round(position.z), // Frontend Z maps to Contract Y
                },
              },
            };
          }
          return { position };
        }),

      updateRotation: (rotation) => set({ rotation }),
      setMoving: (moving) => set({ moving }),
      setVelocity: (velocity) => set({ velocity }),

      // Utility getters
      canMove: () => {
        const state = get();
        return (
          state.canTakeActions &&
          !state.actionInProgress &&
          !state.gameStats.movementLocked &&
          state.gamePhase === GamePhase.ACTIVE &&
          state.actionsThisTurn < state.maxActionsPerTurn
        );
      },

      canAttack: () => {
        const state = get();
        return (
          state.canTakeActions &&
          !state.actionInProgress &&
          state.gamePhase === GamePhase.ACTIVE &&
          state.actionsThisTurn < state.maxActionsPerTurn
        );
      },

      canCollectShard: (roomId: string, shardId: string) => {
        const state = get();
        const shard = state.shardLocations.find(
          (s) => s.shard_id.toString() === shardId
        );

        return (
          state.canTakeActions &&
          !state.actionInProgress &&
          state.gamePhase === GamePhase.ACTIVE &&
          shard &&
          !shard.collected &&
          shard.room_id.toString() === roomId &&
          state.actionsThisTurn < state.maxActionsPerTurn
        );
      },

      getEntitiesInCurrentRoom: () => {
        const state = get();
        if (!state.currentRoom) return [];

        return Array.from(state.entities.values()).filter(
          (entity) =>
            entity.room_id.toString() ===
              state.currentRoom?.room_id.toString() && entity.is_alive
        );
      },

      getShardsInCurrentRoom: () => {
        const state = get();
        if (!state.currentRoom) return [];

        return Array.from(state.shardLocations.values()).filter(
          (shard) =>
            shard.room_id.toString() ===
              state.currentRoom?.room_id.toString() && !shard.collected
        );
      },

      getRoomById: (roomId: string) => {
        const state = get();
        return state.rooms.get(roomId) || null;
      },

      getEntityById: (entityId: string) => {
        const state = get();
        return (
          state.entities.find((e) => e.entity_id.toString() === entityId) ||
          null
        );
      },

      hasNumberedShard: (shardType: models.NumberedShardEnum) => {
        const state = get();
        if (!state.player) return false;

        // This would need to be adapted based on how NumberedShardEnum is structured
        const shardTypeStr = Object.keys(shardType)[0];
        switch (shardTypeStr) {
          case "One":
            return state.player.has_shard_one;
          case "Two":
            return state.player.has_shard_two;
          case "Three":
            return state.player.has_shard_three;
          default:
            return false;
        }
      },

      isRoomCleared: (roomId: string) => {
        const state = get();
        const room = state.rooms.get(roomId);
        return room?.cleared || false;
      },

      getActionsRemaining: () => {
        const state = get();
        return Math.max(0, state.maxActionsPerTurn - state.actionsThisTurn);
      },
    }),
    {
      name: "blockrooms-store",
      partialize: (state) => ({
        // Persist only essential data
        player: state.player,
        playerStats: state.playerStats,
        gameSession: state.gameSession,
        gameConfig: state.gameConfig,
        currentRoom: state.currentRoom,
        isPlayerInitialized: state.isPlayerInitialized,
        gameStats: state.gameStats,
        gamePhase: state.gamePhase,
        // UI state that should persist
        gameStarted: state.gameStarted,
        position: state.position,
      }),
    }
  )
);

export default useAppStore;
export { GamePhase };
export type { AppState, AppActions, AppStore };
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "./index.html",
    "*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.app.json">
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "module": "ESNext",
        "skipLibCheck": true,

        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "isolatedModules": true,
        "moduleDetection": "force",
        "noEmit": true,
        "jsx": "react-jsx",

        /* Linting */
        "strict": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": ["src"]
}
</file>

<file path="tsconfig.app.tsbuildinfo">
{"root":["./src/main.tsx","./src/vite-env.d.ts","./src/app/app.tsx","./src/components/index.ts","./src/components/game/bloodeffect.tsx","./src/components/game/bullethole.tsx","./src/components/game/entitycube.tsx","./src/components/game/floorgrid.tsx","./src/components/game/gun.tsx","./src/components/game/muzzleflash.tsx","./src/components/systems/audiomanager.tsx","./src/components/systems/firstpersoncontrols.tsx","./src/components/systems/maptracker.tsx","./src/components/ui/blockroomscard.tsx","./src/components/ui/crosshair.tsx","./src/components/ui/darknessmask.tsx","./src/components/ui/flashlight.tsx","./src/components/ui/grainvignetteoverlay.tsx","./src/components/ui/hud.tsx","./src/components/ui/instructions.tsx","./src/components/ui/lightproximity.tsx","./src/components/ui/mainmenu.tsx","./src/components/ui/playerhud.tsx","./src/components/ui/transactionpopup.tsx","./src/components/ui/warningpopup.tsx","./src/config/cartridgeconnector.tsx","./src/config/manifest.ts","./src/context/game-context.tsx","./src/dojo/contracts.gen.ts","./src/dojo/dojoconfig.ts","./src/dojo/models.gen.ts","./src/dojo/starknet-provider.tsx","./src/dojo/hooks/fetchnearbydoors.tsx","./src/dojo/hooks/useattackentity.tsx","./src/dojo/hooks/usecollectshard.tsx","./src/dojo/hooks/usedoor.tsx","./src/dojo/hooks/useendgame.tsx","./src/dojo/hooks/usegamedata.tsx","./src/dojo/hooks/useinitializeplayer.tsx","./src/dojo/hooks/usemoveplayer.tsx","./src/dojo/hooks/useplayermovement.tsx","./src/dojo/hooks/usestarknetconnect.tsx","./src/dojo/hooks/usestartgame.tsx","./src/models/bloccc.tsx","./src/models/car1.tsx","./src/models/entity1.tsx","./src/models/ghost.tsx","./src/models/ghostpatrol.tsx","./src/models/ghostpatrol2.tsx","./src/models/ghostpatrol3.tsx","./src/models/ghostpatrol4.tsx","./src/models/ghostpatrol5.tsx","./src/models/ghostpatrol6.tsx","./src/models/ghostpatrol7.tsx","./src/models/gun1.tsx","./src/models/pop.tsx","./src/models/shotgun.tsx","./src/models/shotgunshoot.tsx","./src/models/table.tsx","./src/models/index.ts","./src/types/game.ts","./src/utils/utils.ts","./src/zustand/store.ts"],"version":"5.9.2"}
</file>

<file path="tsconfig.json">
{
    "files": [],
    "references": [
        { "path": "./tsconfig.app.json" },
        { "path": "./tsconfig.node.json" }
    ]
}
</file>

<file path="tsconfig.node.json">
{
    "compilerOptions": {
        "target": "ES2022",
        "lib": ["ES2023"],
        "module": "ESNext",
        "skipLibCheck": true,

        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "isolatedModules": true,
        "moduleDetection": "force",
        "noEmit": true,

        /* Linting */
        "strict": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": ["vite.config.ts"]
}
</file>

<file path="tsconfig.node.tsbuildinfo">
{"root":["./vite.config.ts"],"version":"5.9.2"}
</file>

<file path="vercel.json">
{
  "headers": [
    {
      "source": "/(.*)\\.(glb|gltf|bin|ktx2|wasm)",
      "headers": [
        { "key": "Cache-Control", "value": "public, max-age=31536000, s-maxage=31536000, immutable" },
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Timing-Allow-Origin", "value": "*" }
      ]
    },
    {
      "source": "/(.*)\\.glb",
      "headers": [{ "key": "Content-Type", "value": "model/gltf-binary" }]
    },
    {
      "source": "/(.*)\\.wasm",
      "headers": [{ "key": "Content-Type", "value": "application/wasm" }]
    }
  ]
}
</file>

<file path="vite.config.ts">
import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";
import topLevelAwait from "vite-plugin-top-level-await";
import wasm from "vite-plugin-wasm";
import fs from "fs";
import path from "path";

export default defineConfig(({ command }) => {
  const isDev = command === 'serve';
  const isLocalHttps = process.env.VITE_LOCAL_HTTPS === 'true';

  const getHttpsConfig = () => {
    if (!isDev || !isLocalHttps) return {};
    
    const keyPath = path.resolve('./dev-key.pem');
    const certPath = path.resolve('./dev.pem');
    
    try {
      if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
        return {
          https: {
            key: fs.readFileSync(keyPath),
            cert: fs.readFileSync(certPath),
          }
        };
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  Error reading HTTPS certificates. Using HTTP.');
    }
    
    return {};
  };

  return {
    plugins: [react(), wasm(), topLevelAwait()],
    server: {
      port: 3002,
      ...getHttpsConfig(),
      ...(isDev && {
        host: true,
        cors: true,
      }),
    },
    define: {
      global: 'globalThis',
    },
    optimizeDeps: {
      include: ['buffer'],
    },
  };
});
</file>

</files>
