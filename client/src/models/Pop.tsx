// client/src/models/Pop.tsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: DJMaesen (https://sketchfab.com/bumstrum)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/animated-pistol-bd896167e7ca44f19597d3afe6a8d83f
Title: animated pistol
*/

import * as THREE from "three";
import React, {
  useRef,
  forwardRef,
  useImperativeHandle,
  useEffect,
  useMemo,
  useLayoutEffect,
  useState,
} from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    Object_83: THREE.SkinnedMesh;
    base_beretta_0: THREE.Mesh;
    stopper_beretta_0: THREE.Mesh;
    shell_1_beretta_0: THREE.Mesh;
    bullet_2_beretta_0: THREE.Mesh;
    mag_beretta_0: THREE.Mesh;
    shell_beretta_0: THREE.Mesh;
    bullet_2_2_beretta_0: THREE.Mesh;
    shell_1_2_beretta_0: THREE.Mesh;
    bullet_beretta_0: THREE.Mesh;
    hammer_beretta_0: THREE.Mesh;
    trigger_beretta_0: THREE.Mesh;
    slide_beretta_0: THREE.Mesh;
    _rootJoint: THREE.Bone;
  };
  materials: { arms: THREE.MeshStandardMaterial; beretta: THREE.MeshStandardMaterial };
};

export type PopHandle = {
  playPickup: () => void;
  playShoot: () => void;
  playReloadShort: () => void;
  playReloadLong: () => void;
};

type SegmentSpec = { start: number; end: number };
type SegmentMap = {
  pickup?: SegmentSpec;
  shoot?: SegmentSpec;
  reloadShort?: SegmentSpec;
  reloadLong?: SegmentSpec;
};

type Props = JSX.IntrinsicElements["group"] & {
  segments?: SegmentMap;
  clipNames?: { pickup?: string; shoot?: string; reloadShort?: string; reloadLong?: string };
};

const FPS_DEFAULT = 30;

function makeSubclip(
  base: THREE.AnimationClip,
  name: string,
  startSec: number,
  endSec: number,
  fps = FPS_DEFAULT
) {
  const startFrame = Math.max(0, Math.round(startSec * fps));
  const endFrame = Math.max(startFrame + 1, Math.round(endSec * fps));
  return THREE.AnimationUtils.subclip(base, name, startFrame, endFrame, fps);
}

function playOnce(action?: THREE.AnimationAction) {
  if (!action) return;
  const mixer = action.getMixer();
  // @ts-ignore internal
  mixer._actions?.forEach((a: THREE.AnimationAction) => a !== action && a.stop());
  action.reset();
  action.clampWhenFinished = true;
  action.setLoop(THREE.LoopOnce, 1);
  action.fadeIn(0.04).play();
}

const Pop = forwardRef<PopHandle, Props>(function Pop({ segments, clipNames, ...props }, ref) {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF("/gun1.glb") as GLTFResult;
  const { actions, mixer } = useAnimations(animations, group);

  // Wait until the <group> ref is attached so mixer has a valid root
  const [ready, setReady] = useState(false);
  useEffect(() => {
    if (!ready && group.current) setReady(true);
  }, [ready]);

  useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      console.log(
        "[Pop] clips:",
        animations.map((c) => ({ name: c.name, dur: c.duration.toFixed(2) }))
      );
    }
  }, [animations]);

  const unified = useMemo(() => {
    // If the group isnâ€™t mounted or mixer not present yet, avoid creating actions
    if (!ready || !group.current || !mixer) {
      return { pickup: undefined, shoot: undefined, reloadShort: undefined, reloadLong: undefined };
    }

    // Helper to fetch action by fuzzy name from existing actions (if GLB already split clips)
    const getNamed = (hints: string[]): THREE.AnimationAction | undefined => {
      const entries = Object.entries(actions ?? {});
      for (const [name, act] of entries) if (hints.includes(name)) return act!;
      for (const [name, act] of entries) {
        const low = name.toLowerCase();
        if (hints.some((h) => low.includes(h.toLowerCase()))) return act!;
      }
      return undefined;
    };

    const pickupA =
      (clipNames?.pickup && actions[clipNames.pickup]) ||
      getNamed(["pickup", "draw", "cock", "equip", "ready", "rack", "inspect"]);

    const shootA =
      (clipNames?.shoot && actions[clipNames.shoot]) ||
      getNamed(["shoot", "fire", "shot", "attack", "pistol"]);

    const shortA =
      (clipNames?.reloadShort && actions[clipNames.reloadShort]) ||
      getNamed(["reload short", "tac", "tactical", "reload"]);

    const longA =
      (clipNames?.reloadLong && actions[clipNames.reloadLong]) ||
      getNamed(["reload empty", "reload long", "empty", "from empty", "reload2", "long"]);

    // If model already ships separate clips, use them
    if (pickupA || shootA || shortA || longA) {
      return { pickup: pickupA, shoot: shootA, reloadShort: shortA, reloadLong: longA };
    }

    // Otherwise derive subclips from the first base clip (e.g., "allanimations")
    const base = animations[0];
    if (!base) {
      return { pickup: undefined, shoot: undefined, reloadShort: undefined, reloadLong: undefined };
    }
    const D = base.duration || 2.5;

    const seg = {
      pickup: segments?.pickup ?? { start: 0.0 * D, end: 0.18 * D },
      shoot: segments?.shoot ?? { start: 0.18 * D, end: 0.31 * D },
      reloadShort: segments?.reloadShort ?? { start: 0.35 * D, end: 0.66 * D },
      reloadLong: segments?.reloadLong ?? { start: 0.35 * D, end: 0.66 * D },
    };

    const clipPickup = makeSubclip(base, "pickup_sub", seg.pickup.start, seg.pickup.end);
    const clipShoot = makeSubclip(base, "shoot_sub", seg.shoot.start, seg.shoot.end);
    const clipShort = makeSubclip(base, "reloadS_sub", seg.reloadShort.start, seg.reloadShort.end);
    const clipLong = makeSubclip(base, "reloadL_sub", seg.reloadLong.start, seg.reloadLong.end);

    // Now safe to create actions; pass explicit root (group.current) just to be explicit
    const pickup = mixer.clipAction(clipPickup, group.current);
    const shoot = mixer.clipAction(clipShoot, group.current);
    const reloadShort = mixer.clipAction(clipShort, group.current);
    const reloadLong = mixer.clipAction(clipLong, group.current);

    return { pickup, shoot, reloadShort, reloadLong };
  }, [actions, animations, mixer, segments, clipNames, ready]);

  // Stop everything on unmount
  useEffect(() => {
    return () => {
      mixer?.stopAllAction();
    };
  }, [mixer]);

  // Clear any residual actions when mounted
  useLayoutEffect(() => {
    mixer?.stopAllAction();
  }, [mixer]);

  useImperativeHandle(ref, () => ({
    playPickup: () => playOnce(unified.pickup),
    playShoot: () => playOnce(unified.shoot),
    playReloadShort: () => playOnce(unified.reloadShort ?? unified.reloadLong),
    playReloadLong: () => playOnce(unified.reloadLong ?? unified.reloadShort),
  }));

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="105d2810571c4501ba07ac55c5582245fbx" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <group name="Object_2">
              <group name="RootNode">
                <group name="Root" position={[0, 16.327, -8.923]}>
                  <group name="Object_5">
                    <primitive object={nodes._rootJoint} />
                    <skinnedMesh
                      name="Object_83"
                      geometry={nodes.Object_83.geometry}
                      material={materials.arms}
                      skeleton={nodes.Object_83.skeleton}
                    />
                    <group name="pistol" position={[0, -12.318, 25.913]}>
                      <group name="base">
                        <mesh name="base_beretta_0" castShadow receiveShadow geometry={nodes.base_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name="stopper" position={[1.26, 5.502, 5.615]}>
                        <mesh name="stopper_beretta_0" castShadow receiveShadow geometry={nodes.stopper_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name="shell_1" position={[0, 7.849, 6.937]}>
                        <mesh name="shell_1_beretta_0" castShadow receiveShadow geometry={nodes.shell_1_beretta_0.geometry} material={materials.beretta} />
                        <group name="bullet_2" position={[0, 0, 0.935]}>
                          <mesh name="bullet_2_beretta_0" castShadow receiveShadow geometry={nodes.bullet_2_beretta_0.geometry} material={materials.beretta} />
                        </group>
                      </group>
                      <group name="mag" position={[0, -0.379, 0.406]} rotation={[0.262, 0, 0]}>
                        <mesh name="mag_beretta_0" castShadow receiveShadow geometry={nodes.mag_beretta_0.geometry} material={materials.beretta} />
                        <group name="shell" position={[0, 7.4, -0.455]} rotation={[-0.262, 0, 0]}>
                          <mesh name="shell_beretta_0" castShadow receiveShadow geometry={nodes.shell_beretta_0.geometry} material={materials.beretta} />
                          <group name="bullet_2_2" position={[0, 0, 0.935]}>
                            <mesh name="bullet_2_2_beretta_0" castShadow receiveShadow geometry={nodes.bullet_2_2_beretta_0.geometry} material={materials.beretta} />
                          </group>
                        </group>
                        <group name="shell_1_2" position={[0, 6.293, -0.158]} rotation={[-0.262, 0, 0]}>
                          <mesh name="shell_1_2_beretta_0" castShadow receiveShadow geometry={nodes.shell_1_2_beretta_0.geometry} material={materials.beretta} />
                          <group name="bullet" position={[0, 0, 0.935]}>
                            <mesh name="bullet_beretta_0" castShadow receiveShadow geometry={nodes.bullet_beretta_0.geometry} material={materials.beretta} />
                          </group>
                        </group>
                      </group>
                      <group name="hammer" position={[0, 5.573, -1.608]} rotation={[-1.242, 0, 0]}>
                        <mesh name="hammer_beretta_0" castShadow receiveShadow geometry={nodes.hammer_beretta_0.geometry} material={materials.beretta} />
                      </group>

                      <group name="trigger" position={[0, 4.404, 6.033]}>
                        <mesh name="trigger_beretta_0" castShadow receiveShadow geometry={nodes.trigger_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name="slide" position={[0, 7.341, 3.872]}>
                        <mesh name="slide_beretta_0" castShadow receiveShadow geometry={nodes.slide_beretta_0.geometry} material={materials.beretta} />
                      </group>
                    </group>
                    <group name="Object_82" position={[0, 3.036, -1.334]} />
                  </group>
                </group>
                <group name="armsmesh" position={[0, 3.036, -1.334]} rotation={[-0.002, 0, -0.011]} />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
});

export default Pop;

useGLTF.preload("/gun1.glb");
